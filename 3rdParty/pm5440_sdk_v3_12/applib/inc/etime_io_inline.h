/******************************************************************************
 *   COPYRIGHT (C) 2013 PMC-SIERRA, INC. ALL RIGHTS RESERVED.
 * --------------------------------------------------------------------------
 *  This software embodies materials and concepts which are proprietary and
 *  confidential to PMC-Sierra, Inc.
 *  PMC-Sierra distributes this software to its customers pursuant to the
 *  terms and conditions of the Software License Agreement
 *  contained in the text file software.lic that is distributed along with
 *  the software. This software can only be utilized if all
 *  terms and conditions of the Software License Agreement are
 *  accepted. If there are any questions, concerns, or if the
 *  Software License Agreement text file, software.lic, is missing please
 *  contact PMC-Sierra for assistance.
 * -------------------------------------------------------------------------
 *   DESCRIPTION:
 *     contains the inline implementation of all the field accessor functions
 *     and register accessor functions for the etime block
 *****************************************************************************/
#ifndef _ETIME_IO_INLINE_H
#define _ETIME_IO_INLINE_H

#include "etime_loc.h"
#include "etime_regs.h"

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#define ETIME_IO_VERSION 2

/*
 * ==================================================================================
 *  tsb level structure and access functions for etime
 * ==================================================================================
 */
/* if logging is disabled then so is IO_LOGGING */
#ifndef NO_IO_LOGGING
# ifdef LOGGING_DISABLED
#  define NO_IO_LOGGING
# endif
#endif

/* log messages in the generated files log the caller's file/line/function instead of itself.*/
#ifndef IOLOG
# ifdef NO_IO_LOGGING
#  define IOLOG(...)
# else
#  define IOLOG(...) LOG( __VA_ARGS__)
# endif
#endif
#ifndef IO_RANGE_CHECK
# ifdef NO_IO_LOGGING
#  define IO_RANGE_CHECK(...)
# else
#  define IO_RANGE_CHECK(...) LOG( "** range check ** " __VA_ARGS__)
# endif
#endif
#ifndef IOLOG_DATA
# ifdef NO_IO_LOGGING
#  define IOLOG_DATA(...)
# else
#  define IOLOG_DATA(...) LOG_DATA( __VA_ARGS__)
# endif
#endif
typedef struct {
    coalesce_buffer_t coalesce_handle[1]; /* only used if register coalescing is enabled */
    etime_handle_t * h_ptr;
    pmc_sys_handle_t * sys_handle;
    PMC_VAR_CONST UINT32 base_address;
    /* maybe eventually need to add some fields here per io handle */
} etime_buffer_t;
static INLINE void etime_buffer_init( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ALWAYS_INLINE;
static INLINE void etime_buffer_init( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    b_ptr->h_ptr                    = h_ptr;
    b_ptr->sys_handle               = ((pmc_handle_t *)h_ptr)->sys_handle;
    *(UINT32 *)&b_ptr->base_address = ((pmc_handle_t *)h_ptr)->base_address;
    /* currently this just checks that the previous function remembered to flush. */
    l1sys_init( b_ptr->coalesce_handle, b_ptr->sys_handle );
    IOLOG( "%s", "etime_buffer_init");
    
}

/* flush any changed fields to the register file and invalidate the read cache. */
static INLINE void etime_buffer_flush( etime_buffer_t *b_ptr ) ALWAYS_INLINE;
static INLINE void etime_buffer_flush( etime_buffer_t *b_ptr )
{
    IOLOG( "etime_buffer_flush" );
    l1sys_flush( b_ptr->coalesce_handle );
}
static INLINE UINT32 etime_reg_read( etime_buffer_t *b_ptr,
                                     etime_handle_t *h_ptr,
                                     UINT32 mem_type,
                                     UINT32 reg ) ALWAYS_INLINE;
static INLINE UINT32 etime_reg_read( etime_buffer_t *b_ptr,
                                     etime_handle_t *h_ptr,
                                     UINT32 mem_type,
                                     UINT32 reg )
{
    UINT32 value;
    if (b_ptr != NULL)
        value = l1sys_reg_read( b_ptr->coalesce_handle,
                                mem_type,
                                b_ptr->base_address,
                                reg);
    else
        value = l2sys_reg_read( ((pmc_handle_t *)h_ptr)->sys_handle,
                                mem_type,
                                ((pmc_handle_t *)h_ptr)->base_address + reg);
    return value;
}
static INLINE void etime_reg_write( etime_buffer_t *b_ptr,
                                    etime_handle_t *h_ptr,
                                    UINT32 mem_type,
                                    UINT32 reg,
                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_write( etime_buffer_t *b_ptr,
                                    etime_handle_t *h_ptr,
                                    UINT32 mem_type,
                                    UINT32 reg,
                                    UINT32 value )
{
    if (b_ptr != NULL)
        l1sys_reg_write( b_ptr->coalesce_handle,
                         mem_type,
                         b_ptr->base_address,
                         reg,
                         value);
    else
        l2sys_reg_write( ((pmc_handle_t *)h_ptr)->sys_handle,
                         mem_type,
                         ((pmc_handle_t *)h_ptr)->base_address + reg,
                         value);
}

static INLINE void etime_field_set( etime_buffer_t *b_ptr,
                                    etime_handle_t *h_ptr,
                                    UINT32 mem_type,
                                    UINT32 reg,
                                    UINT32 mask,
                                    UINT32 unused_mask,
                                    UINT32 ofs,
                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_set( etime_buffer_t *b_ptr,
                                    etime_handle_t *h_ptr,
                                    UINT32 mem_type,
                                    UINT32 reg,
                                    UINT32 mask,
                                    UINT32 unused_mask,
                                    UINT32 ofs,
                                    UINT32 value )
{
    if (b_ptr != NULL)
        l1sys_field_set2( b_ptr->coalesce_handle,
                          mem_type,
                          b_ptr->base_address,
                          reg,
                          mask,
                          unused_mask,
                          ofs,
                          value);
    else
    {
        if ((mask | unused_mask) == 0xffffffff)
        {
            l2sys_reg_write( ((pmc_handle_t *)h_ptr)->sys_handle,
                             mem_type,
                             ((pmc_handle_t *)h_ptr)->base_address + reg,
                             value<<ofs);
        }
        else
        {
            l2sys_reg_read_modify_write( ((pmc_handle_t *)h_ptr)->sys_handle,
                                         mem_type,
                                         ((pmc_handle_t *)h_ptr)->base_address + reg,
                                         mask,
                                         value<<ofs);
        }
    }
}

static INLINE void etime_action_on_write_field_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 mem_type,
                                                    UINT32 reg,
                                                    UINT32 mask,
                                                    UINT32 ofs,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_action_on_write_field_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 mem_type,
                                                    UINT32 reg,
                                                    UINT32 mask,
                                                    UINT32 ofs,
                                                    UINT32 value )
{
    if (b_ptr != NULL)
        l1sys_action_on_write_field_set( b_ptr->coalesce_handle,
                                         mem_type,
                                         b_ptr->base_address,
                                         reg,
                                         mask,
                                         ofs,
                                         value);
    else
        l2sys_reg_write( ((pmc_handle_t *)h_ptr)->sys_handle,
                         mem_type,
                         ((pmc_handle_t *)h_ptr)->base_address + reg,
                         value<<ofs);
}

static INLINE void etime_burst_read( etime_buffer_t *b_ptr,
                                     etime_handle_t *h_ptr,
                                     UINT32 mem_type,
                                     UINT32 reg,
                                     UINT32 len,
                                     UINT32 *value ) ALWAYS_INLINE;
static INLINE void etime_burst_read( etime_buffer_t *b_ptr,
                                     etime_handle_t *h_ptr,
                                     UINT32 mem_type,
                                     UINT32 reg,
                                     UINT32 len,
                                     UINT32 *value )
{
    if (b_ptr != NULL)
        l1sys_burst_read( b_ptr->coalesce_handle,
                          mem_type,
                          b_ptr->base_address,
                          reg,
                          len,
                          value);
    else
        l2sys_burst_read( ((pmc_handle_t *)h_ptr)->sys_handle,
                          mem_type,
                          ((pmc_handle_t *)h_ptr)->base_address + reg,
                          len,
                          value);
}

static INLINE void etime_burst_write( etime_buffer_t *b_ptr,
                                      etime_handle_t *h_ptr,
                                      UINT32 mem_type,
                                      UINT32 reg,
                                      UINT32 len,
                                      UINT32 *value ) ALWAYS_INLINE;
static INLINE void etime_burst_write( etime_buffer_t *b_ptr,
                                      etime_handle_t *h_ptr,
                                      UINT32 mem_type,
                                      UINT32 reg,
                                      UINT32 len,
                                      UINT32 *value )
{
    if (b_ptr != NULL)
        l1sys_burst_write( b_ptr->coalesce_handle,
                           mem_type,
                           b_ptr->base_address,
                           reg,
                           len,
                           value);
    else
        l2sys_burst_write( ((pmc_handle_t *)h_ptr)->sys_handle,
                           mem_type,
                           ((pmc_handle_t *)h_ptr)->base_address + reg,
                           len,
                           value);
}

static INLINE PMC_POLL_RETURN_TYPE etime_poll( etime_buffer_t *b_ptr,
                                               etime_handle_t *h_ptr,
                                               UINT32 mem_type,
                                               UINT32 reg,
                                               UINT32 mask,
                                               UINT32 value,
                                               PMC_POLL_COMPARISON_TYPE cmp,
                                               UINT32 max_count,
                                               UINT32 *num_failed_polls,
                                               UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_poll( etime_buffer_t *b_ptr,
                                               etime_handle_t *h_ptr,
                                               UINT32 mem_type,
                                               UINT32 reg,
                                               UINT32 mask,
                                               UINT32 value,
                                               PMC_POLL_COMPARISON_TYPE cmp,
                                               UINT32 max_count,
                                               UINT32 *num_failed_polls,
                                               UINT32 delay_between_polls_in_microseconds )
{
    if (b_ptr != NULL)
        return l1sys_poll( b_ptr->coalesce_handle,
                           mem_type,
                           b_ptr->base_address,
                           reg,
                           mask,
                           value,
                           cmp,
                           max_count,
                           num_failed_polls,
                           delay_between_polls_in_microseconds);
    else
        return l2sys_poll( ((pmc_handle_t *)h_ptr)->sys_handle,
                           mem_type,
                           ((pmc_handle_t *)h_ptr)->base_address + reg,
                           mask,
                           value,
                           cmp,
                           max_count,
                           num_failed_polls,
                           delay_between_polls_in_microseconds);
}

/*
 * ==================================================================================
 *  register access functions for etime
 * ==================================================================================
 */

static INLINE void etime_reg_INT_BEHAV_CTRL_write( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_INT_BEHAV_CTRL_write( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_INT_BEHAV_CTRL_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_INT_BEHAV_CTRL,
                     value);
}

static INLINE void etime_reg_INT_BEHAV_CTRL_field_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 mask,
                                                       UINT32 ofs,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_INT_BEHAV_CTRL_field_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 mask,
                                                       UINT32 ofs,
                                                       UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_INT_BEHAV_CTRL_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_INT_BEHAV_CTRL,
                     mask,
                     PMC_ETIME120_REG_INT_BEHAV_CTRL_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_INT_BEHAV_CTRL_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_INT_BEHAV_CTRL_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_INT_BEHAV_CTRL);

    IOLOG( "%s -> 0x%08x;", "etime_reg_INT_BEHAV_CTRL_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_RAM_BIST_CTRL_write( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_RAM_BIST_CTRL_write( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_RAM_BIST_CTRL_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_RAM_BIST_CTRL,
                     value);
}

static INLINE void etime_reg_RAM_BIST_CTRL_field_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 mask,
                                                      UINT32 ofs,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_RAM_BIST_CTRL_field_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 mask,
                                                      UINT32 ofs,
                                                      UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_RAM_BIST_CTRL_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_RAM_BIST_CTRL,
                     mask,
                     PMC_ETIME120_REG_RAM_BIST_CTRL_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_RAM_BIST_CTRL_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_RAM_BIST_CTRL_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_RAM_BIST_CTRL);

    IOLOG( "%s -> 0x%08x;", "etime_reg_RAM_BIST_CTRL_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_ING_47B_M_write( etime_buffer_t *b_ptr,
                                              etime_handle_t *h_ptr,
                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_ING_47B_M_write( etime_buffer_t *b_ptr,
                                              etime_handle_t *h_ptr,
                                              UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_ING_47B_M_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_ING_47B_M,
                     value);
}

static INLINE void etime_reg_ING_47B_M_field_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 mask,
                                                  UINT32 ofs,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_ING_47B_M_field_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 mask,
                                                  UINT32 ofs,
                                                  UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_ING_47B_M_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_ING_47B_M,
                     mask,
                     PMC_ETIME120_REG_ING_47B_M_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_ING_47B_M_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_ING_47B_M_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_ING_47B_M);

    IOLOG( "%s -> 0x%08x;", "etime_reg_ING_47B_M_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_EGR_47B_M_write( etime_buffer_t *b_ptr,
                                              etime_handle_t *h_ptr,
                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_EGR_47B_M_write( etime_buffer_t *b_ptr,
                                              etime_handle_t *h_ptr,
                                              UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_EGR_47B_M_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_EGR_47B_M,
                     value);
}

static INLINE void etime_reg_EGR_47B_M_field_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 mask,
                                                  UINT32 ofs,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_EGR_47B_M_field_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 mask,
                                                  UINT32 ofs,
                                                  UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_EGR_47B_M_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_EGR_47B_M,
                     mask,
                     PMC_ETIME120_REG_EGR_47B_M_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_EGR_47B_M_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_EGR_47B_M_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_EGR_47B_M);

    IOLOG( "%s -> 0x%08x;", "etime_reg_EGR_47B_M_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_ING_TS_ENA_REG_write( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_ING_TS_ENA_REG_write( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_ING_TS_ENA_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_ING_TS_ENA_REG,
                     value);
}

static INLINE void etime_reg_ING_TS_ENA_REG_field_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 mask,
                                                       UINT32 ofs,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_ING_TS_ENA_REG_field_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 mask,
                                                       UINT32 ofs,
                                                       UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_ING_TS_ENA_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_ING_TS_ENA_REG,
                     mask,
                     PMC_ETIME120_REG_ING_TS_ENA_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_ING_TS_ENA_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_ING_TS_ENA_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_ING_TS_ENA_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_ING_TS_ENA_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_REFL_DEST_write( etime_buffer_t *b_ptr,
                                              etime_handle_t *h_ptr,
                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_REFL_DEST_write( etime_buffer_t *b_ptr,
                                              etime_handle_t *h_ptr,
                                              UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_REFL_DEST_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_REFL_DEST,
                     value);
}

static INLINE void etime_reg_REFL_DEST_field_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 mask,
                                                  UINT32 ofs,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_REFL_DEST_field_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 mask,
                                                  UINT32 ofs,
                                                  UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_REFL_DEST_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_REFL_DEST,
                     mask,
                     PMC_ETIME120_REG_REFL_DEST_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_REFL_DEST_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_REFL_DEST_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_REFL_DEST);

    IOLOG( "%s -> 0x%08x;", "etime_reg_REFL_DEST_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_EGR_TS_ENA_REG_write( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_EGR_TS_ENA_REG_write( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_EGR_TS_ENA_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_EGR_TS_ENA_REG,
                     value);
}

static INLINE void etime_reg_EGR_TS_ENA_REG_field_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 mask,
                                                       UINT32 ofs,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_EGR_TS_ENA_REG_field_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 mask,
                                                       UINT32 ofs,
                                                       UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_EGR_TS_ENA_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_EGR_TS_ENA_REG,
                     mask,
                     PMC_ETIME120_REG_EGR_TS_ENA_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_EGR_TS_ENA_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_EGR_TS_ENA_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_EGR_TS_ENA_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_EGR_TS_ENA_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TOD_OFFS_SEC_HI_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_OFFS_SEC_HI_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TOD_OFFS_SEC_HI_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_OFFS_SEC_HI,
                     value);
}

static INLINE void etime_reg_TOD_OFFS_SEC_HI_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_OFFS_SEC_HI_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TOD_OFFS_SEC_HI_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_OFFS_SEC_HI,
                     mask,
                     PMC_ETIME120_REG_TOD_OFFS_SEC_HI_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TOD_OFFS_SEC_HI_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_OFFS_SEC_HI_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TOD_OFFS_SEC_HI);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_OFFS_SEC_HI_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TOD_OFFS_SEC_LO_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_OFFS_SEC_LO_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TOD_OFFS_SEC_LO_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_OFFS_SEC_LO,
                     value);
}

static INLINE void etime_reg_TOD_OFFS_SEC_LO_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_OFFS_SEC_LO_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TOD_OFFS_SEC_LO_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_OFFS_SEC_LO,
                     mask,
                     PMC_ETIME120_REG_TOD_OFFS_SEC_LO_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TOD_OFFS_SEC_LO_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_OFFS_SEC_LO_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TOD_OFFS_SEC_LO);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_OFFS_SEC_LO_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TOD_OFFS_NSEC_write( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_OFFS_NSEC_write( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TOD_OFFS_NSEC_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_OFFS_NSEC,
                     value);
}

static INLINE void etime_reg_TOD_OFFS_NSEC_field_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 mask,
                                                      UINT32 ofs,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_OFFS_NSEC_field_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 mask,
                                                      UINT32 ofs,
                                                      UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TOD_OFFS_NSEC_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_OFFS_NSEC,
                     mask,
                     PMC_ETIME120_REG_TOD_OFFS_NSEC_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TOD_OFFS_NSEC_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_OFFS_NSEC_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TOD_OFFS_NSEC);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_OFFS_NSEC_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CFC_OFFS_NSEC_HI_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_OFFS_NSEC_HI_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CFC_OFFS_NSEC_HI_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_OFFS_NSEC_HI,
                     value);
}

static INLINE void etime_reg_CFC_OFFS_NSEC_HI_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_OFFS_NSEC_HI_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CFC_OFFS_NSEC_HI_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_OFFS_NSEC_HI,
                     mask,
                     PMC_ETIME120_REG_CFC_OFFS_NSEC_HI_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CFC_OFFS_NSEC_HI_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_OFFS_NSEC_HI_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CFC_OFFS_NSEC_HI);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_OFFS_NSEC_HI_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CFC_OFFS_NSEC_LO_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_OFFS_NSEC_LO_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CFC_OFFS_NSEC_LO_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_OFFS_NSEC_LO,
                     value);
}

static INLINE void etime_reg_CFC_OFFS_NSEC_LO_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_OFFS_NSEC_LO_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CFC_OFFS_NSEC_LO_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_OFFS_NSEC_LO,
                     mask,
                     PMC_ETIME120_REG_CFC_OFFS_NSEC_LO_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CFC_OFFS_NSEC_LO_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_OFFS_NSEC_LO_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CFC_OFFS_NSEC_LO);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_OFFS_NSEC_LO_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TOD_ING_DLY_CH0_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_ING_DLY_CH0_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TOD_ING_DLY_CH0_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH0,
                     value);
}

static INLINE void etime_reg_TOD_ING_DLY_CH0_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_ING_DLY_CH0_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TOD_ING_DLY_CH0_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH0,
                     mask,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH0_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TOD_ING_DLY_CH0_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_ING_DLY_CH0_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TOD_ING_DLY_CH0);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_ING_DLY_CH0_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TOD_ING_DLY_CH1_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_ING_DLY_CH1_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TOD_ING_DLY_CH1_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH1,
                     value);
}

static INLINE void etime_reg_TOD_ING_DLY_CH1_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_ING_DLY_CH1_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TOD_ING_DLY_CH1_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH1,
                     mask,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH1_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TOD_ING_DLY_CH1_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_ING_DLY_CH1_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TOD_ING_DLY_CH1);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_ING_DLY_CH1_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TOD_ING_DLY_CH2_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_ING_DLY_CH2_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TOD_ING_DLY_CH2_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH2,
                     value);
}

static INLINE void etime_reg_TOD_ING_DLY_CH2_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_ING_DLY_CH2_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TOD_ING_DLY_CH2_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH2,
                     mask,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH2_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TOD_ING_DLY_CH2_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_ING_DLY_CH2_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TOD_ING_DLY_CH2);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_ING_DLY_CH2_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TOD_ING_DLY_CH3_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_ING_DLY_CH3_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TOD_ING_DLY_CH3_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH3,
                     value);
}

static INLINE void etime_reg_TOD_ING_DLY_CH3_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_ING_DLY_CH3_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TOD_ING_DLY_CH3_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH3,
                     mask,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH3_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TOD_ING_DLY_CH3_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_ING_DLY_CH3_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TOD_ING_DLY_CH3);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_ING_DLY_CH3_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TOD_ING_DLY_CH4_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_ING_DLY_CH4_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TOD_ING_DLY_CH4_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH4,
                     value);
}

static INLINE void etime_reg_TOD_ING_DLY_CH4_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_ING_DLY_CH4_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TOD_ING_DLY_CH4_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH4,
                     mask,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH4_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TOD_ING_DLY_CH4_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_ING_DLY_CH4_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TOD_ING_DLY_CH4);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_ING_DLY_CH4_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TOD_ING_DLY_CH5_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_ING_DLY_CH5_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TOD_ING_DLY_CH5_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH5,
                     value);
}

static INLINE void etime_reg_TOD_ING_DLY_CH5_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_ING_DLY_CH5_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TOD_ING_DLY_CH5_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH5,
                     mask,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH5_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TOD_ING_DLY_CH5_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_ING_DLY_CH5_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TOD_ING_DLY_CH5);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_ING_DLY_CH5_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TOD_ING_DLY_CH6_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_ING_DLY_CH6_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TOD_ING_DLY_CH6_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH6,
                     value);
}

static INLINE void etime_reg_TOD_ING_DLY_CH6_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_ING_DLY_CH6_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TOD_ING_DLY_CH6_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH6,
                     mask,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH6_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TOD_ING_DLY_CH6_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_ING_DLY_CH6_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TOD_ING_DLY_CH6);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_ING_DLY_CH6_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TOD_ING_DLY_CH7_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_ING_DLY_CH7_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TOD_ING_DLY_CH7_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH7,
                     value);
}

static INLINE void etime_reg_TOD_ING_DLY_CH7_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_ING_DLY_CH7_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TOD_ING_DLY_CH7_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH7,
                     mask,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH7_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TOD_ING_DLY_CH7_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_ING_DLY_CH7_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TOD_ING_DLY_CH7);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_ING_DLY_CH7_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TOD_ING_DLY_CH8_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_ING_DLY_CH8_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TOD_ING_DLY_CH8_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH8,
                     value);
}

static INLINE void etime_reg_TOD_ING_DLY_CH8_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_ING_DLY_CH8_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TOD_ING_DLY_CH8_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH8,
                     mask,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH8_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TOD_ING_DLY_CH8_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_ING_DLY_CH8_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TOD_ING_DLY_CH8);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_ING_DLY_CH8_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TOD_ING_DLY_CH9_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_ING_DLY_CH9_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TOD_ING_DLY_CH9_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH9,
                     value);
}

static INLINE void etime_reg_TOD_ING_DLY_CH9_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_ING_DLY_CH9_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TOD_ING_DLY_CH9_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH9,
                     mask,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH9_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TOD_ING_DLY_CH9_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_ING_DLY_CH9_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TOD_ING_DLY_CH9);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_ING_DLY_CH9_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TOD_ING_DLY_CH10_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_ING_DLY_CH10_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TOD_ING_DLY_CH10_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH10,
                     value);
}

static INLINE void etime_reg_TOD_ING_DLY_CH10_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_ING_DLY_CH10_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TOD_ING_DLY_CH10_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH10,
                     mask,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH10_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TOD_ING_DLY_CH10_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_ING_DLY_CH10_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TOD_ING_DLY_CH10);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_ING_DLY_CH10_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TOD_ING_DLY_CH11_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_ING_DLY_CH11_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TOD_ING_DLY_CH11_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH11,
                     value);
}

static INLINE void etime_reg_TOD_ING_DLY_CH11_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_ING_DLY_CH11_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TOD_ING_DLY_CH11_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH11,
                     mask,
                     PMC_ETIME120_REG_TOD_ING_DLY_CH11_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TOD_ING_DLY_CH11_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_ING_DLY_CH11_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TOD_ING_DLY_CH11);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_ING_DLY_CH11_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CFC_ING_DLY_CH0_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_ING_DLY_CH0_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CFC_ING_DLY_CH0_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH0,
                     value);
}

static INLINE void etime_reg_CFC_ING_DLY_CH0_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_ING_DLY_CH0_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CFC_ING_DLY_CH0_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH0,
                     mask,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH0_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CFC_ING_DLY_CH0_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_ING_DLY_CH0_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CFC_ING_DLY_CH0);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_ING_DLY_CH0_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CFC_ING_DLY_CH1_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_ING_DLY_CH1_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CFC_ING_DLY_CH1_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH1,
                     value);
}

static INLINE void etime_reg_CFC_ING_DLY_CH1_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_ING_DLY_CH1_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CFC_ING_DLY_CH1_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH1,
                     mask,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH1_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CFC_ING_DLY_CH1_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_ING_DLY_CH1_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CFC_ING_DLY_CH1);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_ING_DLY_CH1_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CFC_ING_DLY_CH2_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_ING_DLY_CH2_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CFC_ING_DLY_CH2_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH2,
                     value);
}

static INLINE void etime_reg_CFC_ING_DLY_CH2_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_ING_DLY_CH2_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CFC_ING_DLY_CH2_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH2,
                     mask,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH2_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CFC_ING_DLY_CH2_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_ING_DLY_CH2_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CFC_ING_DLY_CH2);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_ING_DLY_CH2_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CFC_ING_DLY_CH3_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_ING_DLY_CH3_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CFC_ING_DLY_CH3_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH3,
                     value);
}

static INLINE void etime_reg_CFC_ING_DLY_CH3_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_ING_DLY_CH3_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CFC_ING_DLY_CH3_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH3,
                     mask,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH3_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CFC_ING_DLY_CH3_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_ING_DLY_CH3_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CFC_ING_DLY_CH3);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_ING_DLY_CH3_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CFC_ING_DLY_CH4_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_ING_DLY_CH4_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CFC_ING_DLY_CH4_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH4,
                     value);
}

static INLINE void etime_reg_CFC_ING_DLY_CH4_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_ING_DLY_CH4_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CFC_ING_DLY_CH4_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH4,
                     mask,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH4_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CFC_ING_DLY_CH4_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_ING_DLY_CH4_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CFC_ING_DLY_CH4);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_ING_DLY_CH4_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CFC_ING_DLY_CH5_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_ING_DLY_CH5_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CFC_ING_DLY_CH5_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH5,
                     value);
}

static INLINE void etime_reg_CFC_ING_DLY_CH5_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_ING_DLY_CH5_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CFC_ING_DLY_CH5_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH5,
                     mask,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH5_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CFC_ING_DLY_CH5_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_ING_DLY_CH5_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CFC_ING_DLY_CH5);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_ING_DLY_CH5_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CFC_ING_DLY_CH6_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_ING_DLY_CH6_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CFC_ING_DLY_CH6_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH6,
                     value);
}

static INLINE void etime_reg_CFC_ING_DLY_CH6_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_ING_DLY_CH6_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CFC_ING_DLY_CH6_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH6,
                     mask,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH6_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CFC_ING_DLY_CH6_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_ING_DLY_CH6_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CFC_ING_DLY_CH6);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_ING_DLY_CH6_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CFC_ING_DLY_CH7_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_ING_DLY_CH7_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CFC_ING_DLY_CH7_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH7,
                     value);
}

static INLINE void etime_reg_CFC_ING_DLY_CH7_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_ING_DLY_CH7_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CFC_ING_DLY_CH7_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH7,
                     mask,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH7_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CFC_ING_DLY_CH7_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_ING_DLY_CH7_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CFC_ING_DLY_CH7);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_ING_DLY_CH7_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CFC_ING_DLY_CH8_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_ING_DLY_CH8_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CFC_ING_DLY_CH8_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH8,
                     value);
}

static INLINE void etime_reg_CFC_ING_DLY_CH8_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_ING_DLY_CH8_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CFC_ING_DLY_CH8_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH8,
                     mask,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH8_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CFC_ING_DLY_CH8_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_ING_DLY_CH8_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CFC_ING_DLY_CH8);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_ING_DLY_CH8_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CFC_ING_DLY_CH9_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_ING_DLY_CH9_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CFC_ING_DLY_CH9_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH9,
                     value);
}

static INLINE void etime_reg_CFC_ING_DLY_CH9_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_ING_DLY_CH9_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CFC_ING_DLY_CH9_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH9,
                     mask,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH9_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CFC_ING_DLY_CH9_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_ING_DLY_CH9_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CFC_ING_DLY_CH9);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_ING_DLY_CH9_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CFC_ING_DLY_CH10_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_ING_DLY_CH10_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CFC_ING_DLY_CH10_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH10,
                     value);
}

static INLINE void etime_reg_CFC_ING_DLY_CH10_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_ING_DLY_CH10_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CFC_ING_DLY_CH10_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH10,
                     mask,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH10_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CFC_ING_DLY_CH10_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_ING_DLY_CH10_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CFC_ING_DLY_CH10);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_ING_DLY_CH10_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CFC_ING_DLY_CH11_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_ING_DLY_CH11_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CFC_ING_DLY_CH11_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH11,
                     value);
}

static INLINE void etime_reg_CFC_ING_DLY_CH11_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_ING_DLY_CH11_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CFC_ING_DLY_CH11_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH11,
                     mask,
                     PMC_ETIME120_REG_CFC_ING_DLY_CH11_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CFC_ING_DLY_CH11_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_ING_DLY_CH11_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CFC_ING_DLY_CH11);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_ING_DLY_CH11_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TOD_EGR_DLY_CH0_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_EGR_DLY_CH0_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TOD_EGR_DLY_CH0_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH0,
                     value);
}

static INLINE void etime_reg_TOD_EGR_DLY_CH0_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_EGR_DLY_CH0_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TOD_EGR_DLY_CH0_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH0,
                     mask,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH0_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TOD_EGR_DLY_CH0_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_EGR_DLY_CH0_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TOD_EGR_DLY_CH0);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_EGR_DLY_CH0_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TOD_EGR_DLY_CH1_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_EGR_DLY_CH1_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TOD_EGR_DLY_CH1_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH1,
                     value);
}

static INLINE void etime_reg_TOD_EGR_DLY_CH1_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_EGR_DLY_CH1_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TOD_EGR_DLY_CH1_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH1,
                     mask,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH1_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TOD_EGR_DLY_CH1_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_EGR_DLY_CH1_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TOD_EGR_DLY_CH1);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_EGR_DLY_CH1_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TOD_EGR_DLY_CH2_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_EGR_DLY_CH2_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TOD_EGR_DLY_CH2_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH2,
                     value);
}

static INLINE void etime_reg_TOD_EGR_DLY_CH2_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_EGR_DLY_CH2_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TOD_EGR_DLY_CH2_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH2,
                     mask,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH2_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TOD_EGR_DLY_CH2_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_EGR_DLY_CH2_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TOD_EGR_DLY_CH2);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_EGR_DLY_CH2_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TOD_EGR_DLY_CH3_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_EGR_DLY_CH3_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TOD_EGR_DLY_CH3_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH3,
                     value);
}

static INLINE void etime_reg_TOD_EGR_DLY_CH3_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_EGR_DLY_CH3_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TOD_EGR_DLY_CH3_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH3,
                     mask,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH3_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TOD_EGR_DLY_CH3_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_EGR_DLY_CH3_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TOD_EGR_DLY_CH3);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_EGR_DLY_CH3_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TOD_EGR_DLY_CH4_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_EGR_DLY_CH4_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TOD_EGR_DLY_CH4_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH4,
                     value);
}

static INLINE void etime_reg_TOD_EGR_DLY_CH4_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_EGR_DLY_CH4_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TOD_EGR_DLY_CH4_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH4,
                     mask,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH4_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TOD_EGR_DLY_CH4_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_EGR_DLY_CH4_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TOD_EGR_DLY_CH4);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_EGR_DLY_CH4_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TOD_EGR_DLY_CH5_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_EGR_DLY_CH5_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TOD_EGR_DLY_CH5_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH5,
                     value);
}

static INLINE void etime_reg_TOD_EGR_DLY_CH5_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_EGR_DLY_CH5_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TOD_EGR_DLY_CH5_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH5,
                     mask,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH5_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TOD_EGR_DLY_CH5_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_EGR_DLY_CH5_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TOD_EGR_DLY_CH5);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_EGR_DLY_CH5_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TOD_EGR_DLY_CH6_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_EGR_DLY_CH6_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TOD_EGR_DLY_CH6_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH6,
                     value);
}

static INLINE void etime_reg_TOD_EGR_DLY_CH6_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_EGR_DLY_CH6_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TOD_EGR_DLY_CH6_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH6,
                     mask,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH6_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TOD_EGR_DLY_CH6_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_EGR_DLY_CH6_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TOD_EGR_DLY_CH6);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_EGR_DLY_CH6_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TOD_EGR_DLY_CH7_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_EGR_DLY_CH7_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TOD_EGR_DLY_CH7_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH7,
                     value);
}

static INLINE void etime_reg_TOD_EGR_DLY_CH7_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_EGR_DLY_CH7_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TOD_EGR_DLY_CH7_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH7,
                     mask,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH7_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TOD_EGR_DLY_CH7_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_EGR_DLY_CH7_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TOD_EGR_DLY_CH7);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_EGR_DLY_CH7_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TOD_EGR_DLY_CH8_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_EGR_DLY_CH8_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TOD_EGR_DLY_CH8_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH8,
                     value);
}

static INLINE void etime_reg_TOD_EGR_DLY_CH8_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_EGR_DLY_CH8_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TOD_EGR_DLY_CH8_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH8,
                     mask,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH8_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TOD_EGR_DLY_CH8_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_EGR_DLY_CH8_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TOD_EGR_DLY_CH8);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_EGR_DLY_CH8_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TOD_EGR_DLY_CH9_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_EGR_DLY_CH9_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TOD_EGR_DLY_CH9_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH9,
                     value);
}

static INLINE void etime_reg_TOD_EGR_DLY_CH9_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_EGR_DLY_CH9_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TOD_EGR_DLY_CH9_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH9,
                     mask,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH9_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TOD_EGR_DLY_CH9_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_EGR_DLY_CH9_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TOD_EGR_DLY_CH9);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_EGR_DLY_CH9_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TOD_EGR_DLY_CH10_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_EGR_DLY_CH10_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TOD_EGR_DLY_CH10_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH10,
                     value);
}

static INLINE void etime_reg_TOD_EGR_DLY_CH10_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_EGR_DLY_CH10_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TOD_EGR_DLY_CH10_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH10,
                     mask,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH10_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TOD_EGR_DLY_CH10_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_EGR_DLY_CH10_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TOD_EGR_DLY_CH10);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_EGR_DLY_CH10_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TOD_EGR_DLY_CH11_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_EGR_DLY_CH11_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TOD_EGR_DLY_CH11_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH11,
                     value);
}

static INLINE void etime_reg_TOD_EGR_DLY_CH11_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TOD_EGR_DLY_CH11_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TOD_EGR_DLY_CH11_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH11,
                     mask,
                     PMC_ETIME120_REG_TOD_EGR_DLY_CH11_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TOD_EGR_DLY_CH11_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_EGR_DLY_CH11_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TOD_EGR_DLY_CH11);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_EGR_DLY_CH11_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CFC_EGR_DLY_CH0_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_EGR_DLY_CH0_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CFC_EGR_DLY_CH0_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH0,
                     value);
}

static INLINE void etime_reg_CFC_EGR_DLY_CH0_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_EGR_DLY_CH0_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CFC_EGR_DLY_CH0_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH0,
                     mask,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH0_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CFC_EGR_DLY_CH0_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_EGR_DLY_CH0_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CFC_EGR_DLY_CH0);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_EGR_DLY_CH0_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CFC_EGR_DLY_CH1_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_EGR_DLY_CH1_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CFC_EGR_DLY_CH1_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH1,
                     value);
}

static INLINE void etime_reg_CFC_EGR_DLY_CH1_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_EGR_DLY_CH1_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CFC_EGR_DLY_CH1_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH1,
                     mask,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH1_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CFC_EGR_DLY_CH1_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_EGR_DLY_CH1_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CFC_EGR_DLY_CH1);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_EGR_DLY_CH1_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CFC_EGR_DLY_CH2_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_EGR_DLY_CH2_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CFC_EGR_DLY_CH2_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH2,
                     value);
}

static INLINE void etime_reg_CFC_EGR_DLY_CH2_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_EGR_DLY_CH2_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CFC_EGR_DLY_CH2_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH2,
                     mask,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH2_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CFC_EGR_DLY_CH2_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_EGR_DLY_CH2_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CFC_EGR_DLY_CH2);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_EGR_DLY_CH2_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CFC_EGR_DLY_CH3_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_EGR_DLY_CH3_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CFC_EGR_DLY_CH3_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH3,
                     value);
}

static INLINE void etime_reg_CFC_EGR_DLY_CH3_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_EGR_DLY_CH3_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CFC_EGR_DLY_CH3_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH3,
                     mask,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH3_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CFC_EGR_DLY_CH3_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_EGR_DLY_CH3_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CFC_EGR_DLY_CH3);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_EGR_DLY_CH3_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CFC_EGR_DLY_CH4_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_EGR_DLY_CH4_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CFC_EGR_DLY_CH4_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH4,
                     value);
}

static INLINE void etime_reg_CFC_EGR_DLY_CH4_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_EGR_DLY_CH4_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CFC_EGR_DLY_CH4_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH4,
                     mask,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH4_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CFC_EGR_DLY_CH4_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_EGR_DLY_CH4_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CFC_EGR_DLY_CH4);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_EGR_DLY_CH4_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CFC_EGR_DLY_CH5_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_EGR_DLY_CH5_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CFC_EGR_DLY_CH5_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH5,
                     value);
}

static INLINE void etime_reg_CFC_EGR_DLY_CH5_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_EGR_DLY_CH5_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CFC_EGR_DLY_CH5_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH5,
                     mask,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH5_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CFC_EGR_DLY_CH5_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_EGR_DLY_CH5_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CFC_EGR_DLY_CH5);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_EGR_DLY_CH5_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CFC_EGR_DLY_CH6_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_EGR_DLY_CH6_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CFC_EGR_DLY_CH6_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH6,
                     value);
}

static INLINE void etime_reg_CFC_EGR_DLY_CH6_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_EGR_DLY_CH6_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CFC_EGR_DLY_CH6_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH6,
                     mask,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH6_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CFC_EGR_DLY_CH6_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_EGR_DLY_CH6_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CFC_EGR_DLY_CH6);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_EGR_DLY_CH6_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CFC_EGR_DLY_CH7_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_EGR_DLY_CH7_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CFC_EGR_DLY_CH7_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH7,
                     value);
}

static INLINE void etime_reg_CFC_EGR_DLY_CH7_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_EGR_DLY_CH7_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CFC_EGR_DLY_CH7_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH7,
                     mask,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH7_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CFC_EGR_DLY_CH7_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_EGR_DLY_CH7_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CFC_EGR_DLY_CH7);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_EGR_DLY_CH7_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CFC_EGR_DLY_CH8_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_EGR_DLY_CH8_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CFC_EGR_DLY_CH8_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH8,
                     value);
}

static INLINE void etime_reg_CFC_EGR_DLY_CH8_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_EGR_DLY_CH8_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CFC_EGR_DLY_CH8_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH8,
                     mask,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH8_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CFC_EGR_DLY_CH8_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_EGR_DLY_CH8_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CFC_EGR_DLY_CH8);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_EGR_DLY_CH8_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CFC_EGR_DLY_CH9_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_EGR_DLY_CH9_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CFC_EGR_DLY_CH9_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH9,
                     value);
}

static INLINE void etime_reg_CFC_EGR_DLY_CH9_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_EGR_DLY_CH9_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CFC_EGR_DLY_CH9_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH9,
                     mask,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH9_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CFC_EGR_DLY_CH9_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_EGR_DLY_CH9_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CFC_EGR_DLY_CH9);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_EGR_DLY_CH9_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CFC_EGR_DLY_CH10_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_EGR_DLY_CH10_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CFC_EGR_DLY_CH10_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH10,
                     value);
}

static INLINE void etime_reg_CFC_EGR_DLY_CH10_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_EGR_DLY_CH10_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CFC_EGR_DLY_CH10_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH10,
                     mask,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH10_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CFC_EGR_DLY_CH10_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_EGR_DLY_CH10_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CFC_EGR_DLY_CH10);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_EGR_DLY_CH10_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CFC_EGR_DLY_CH11_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_EGR_DLY_CH11_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CFC_EGR_DLY_CH11_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH11,
                     value);
}

static INLINE void etime_reg_CFC_EGR_DLY_CH11_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CFC_EGR_DLY_CH11_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CFC_EGR_DLY_CH11_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH11,
                     mask,
                     PMC_ETIME120_REG_CFC_EGR_DLY_CH11_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CFC_EGR_DLY_CH11_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_EGR_DLY_CH11_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CFC_EGR_DLY_CH11);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_EGR_DLY_CH11_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TS_CNTR_CFG_write( etime_buffer_t *b_ptr,
                                                etime_handle_t *h_ptr,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TS_CNTR_CFG_write( etime_buffer_t *b_ptr,
                                                etime_handle_t *h_ptr,
                                                UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TS_CNTR_CFG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TS_CNTR_CFG,
                     value);
}

static INLINE void etime_reg_TS_CNTR_CFG_field_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 mask,
                                                    UINT32 ofs,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TS_CNTR_CFG_field_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 mask,
                                                    UINT32 ofs,
                                                    UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TS_CNTR_CFG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TS_CNTR_CFG,
                     mask,
                     PMC_ETIME120_REG_TS_CNTR_CFG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TS_CNTR_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TS_CNTR_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TS_CNTR_CFG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TS_CNTR_CFG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_OFFS_UPD_TIME_SEC_HI_REG_write( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_OFFS_UPD_TIME_SEC_HI_REG_write( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_OFFS_UPD_TIME_SEC_HI_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_OFFS_UPD_TIME_SEC_HI_REG,
                     value);
}

static INLINE void etime_reg_OFFS_UPD_TIME_SEC_HI_REG_field_set( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 mask,
                                                                 UINT32 ofs,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_OFFS_UPD_TIME_SEC_HI_REG_field_set( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 mask,
                                                                 UINT32 ofs,
                                                                 UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_OFFS_UPD_TIME_SEC_HI_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_OFFS_UPD_TIME_SEC_HI_REG,
                     mask,
                     PMC_ETIME120_REG_OFFS_UPD_TIME_SEC_HI_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_OFFS_UPD_TIME_SEC_HI_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_OFFS_UPD_TIME_SEC_HI_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_OFFS_UPD_TIME_SEC_HI_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_OFFS_UPD_TIME_SEC_HI_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_OFFS_UPD_TIME_SEC_LO_REG_write( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_OFFS_UPD_TIME_SEC_LO_REG_write( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_OFFS_UPD_TIME_SEC_LO_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_OFFS_UPD_TIME_SEC_LO_REG,
                     value);
}

static INLINE void etime_reg_OFFS_UPD_TIME_SEC_LO_REG_field_set( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 mask,
                                                                 UINT32 ofs,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_OFFS_UPD_TIME_SEC_LO_REG_field_set( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 mask,
                                                                 UINT32 ofs,
                                                                 UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_OFFS_UPD_TIME_SEC_LO_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_OFFS_UPD_TIME_SEC_LO_REG,
                     mask,
                     PMC_ETIME120_REG_OFFS_UPD_TIME_SEC_LO_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_OFFS_UPD_TIME_SEC_LO_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_OFFS_UPD_TIME_SEC_LO_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_OFFS_UPD_TIME_SEC_LO_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_OFFS_UPD_TIME_SEC_LO_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_OFFS_UPD_TIME_NSEC_REG_write( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_OFFS_UPD_TIME_NSEC_REG_write( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_OFFS_UPD_TIME_NSEC_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_OFFS_UPD_TIME_NSEC_REG,
                     value);
}

static INLINE void etime_reg_OFFS_UPD_TIME_NSEC_REG_field_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 mask,
                                                               UINT32 ofs,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_OFFS_UPD_TIME_NSEC_REG_field_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 mask,
                                                               UINT32 ofs,
                                                               UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_OFFS_UPD_TIME_NSEC_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_OFFS_UPD_TIME_NSEC_REG,
                     mask,
                     PMC_ETIME120_REG_OFFS_UPD_TIME_NSEC_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_OFFS_UPD_TIME_NSEC_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_OFFS_UPD_TIME_NSEC_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_OFFS_UPD_TIME_NSEC_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_OFFS_UPD_TIME_NSEC_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_PTP_CLK_PER_INT_HI_REG_write( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_PTP_CLK_PER_INT_HI_REG_write( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_PTP_CLK_PER_INT_HI_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_PTP_CLK_PER_INT_HI_REG,
                     value);
}

static INLINE void etime_reg_PTP_CLK_PER_INT_HI_REG_field_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 mask,
                                                               UINT32 ofs,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_PTP_CLK_PER_INT_HI_REG_field_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 mask,
                                                               UINT32 ofs,
                                                               UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_PTP_CLK_PER_INT_HI_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_PTP_CLK_PER_INT_HI_REG,
                     mask,
                     PMC_ETIME120_REG_PTP_CLK_PER_INT_HI_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_PTP_CLK_PER_INT_HI_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_PTP_CLK_PER_INT_HI_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_PTP_CLK_PER_INT_HI_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_PTP_CLK_PER_INT_HI_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_PTP_CLK_PER_INT_LO_REG_write( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_PTP_CLK_PER_INT_LO_REG_write( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_PTP_CLK_PER_INT_LO_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_PTP_CLK_PER_INT_LO_REG,
                     value);
}

static INLINE void etime_reg_PTP_CLK_PER_INT_LO_REG_field_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 mask,
                                                               UINT32 ofs,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_PTP_CLK_PER_INT_LO_REG_field_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 mask,
                                                               UINT32 ofs,
                                                               UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_PTP_CLK_PER_INT_LO_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_PTP_CLK_PER_INT_LO_REG,
                     mask,
                     PMC_ETIME120_REG_PTP_CLK_PER_INT_LO_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_PTP_CLK_PER_INT_LO_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_PTP_CLK_PER_INT_LO_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_PTP_CLK_PER_INT_LO_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_PTP_CLK_PER_INT_LO_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_PTP_CLK_PER_NUM_REG_write( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_PTP_CLK_PER_NUM_REG_write( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_PTP_CLK_PER_NUM_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_PTP_CLK_PER_NUM_REG,
                     value);
}

static INLINE void etime_reg_PTP_CLK_PER_NUM_REG_field_set( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 mask,
                                                            UINT32 ofs,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_PTP_CLK_PER_NUM_REG_field_set( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 mask,
                                                            UINT32 ofs,
                                                            UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_PTP_CLK_PER_NUM_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_PTP_CLK_PER_NUM_REG,
                     mask,
                     PMC_ETIME120_REG_PTP_CLK_PER_NUM_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_PTP_CLK_PER_NUM_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_PTP_CLK_PER_NUM_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_PTP_CLK_PER_NUM_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_PTP_CLK_PER_NUM_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_PTP_CLK_PER_DEN_REG_write( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_PTP_CLK_PER_DEN_REG_write( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_PTP_CLK_PER_DEN_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_PTP_CLK_PER_DEN_REG,
                     value);
}

static INLINE void etime_reg_PTP_CLK_PER_DEN_REG_field_set( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 mask,
                                                            UINT32 ofs,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_PTP_CLK_PER_DEN_REG_field_set( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 mask,
                                                            UINT32 ofs,
                                                            UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_PTP_CLK_PER_DEN_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_PTP_CLK_PER_DEN_REG,
                     mask,
                     PMC_ETIME120_REG_PTP_CLK_PER_DEN_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_PTP_CLK_PER_DEN_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_PTP_CLK_PER_DEN_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_PTP_CLK_PER_DEN_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_PTP_CLK_PER_DEN_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_OFFSET_UPD_QUANTA_REG_write( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_OFFSET_UPD_QUANTA_REG_write( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_OFFSET_UPD_QUANTA_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_OFFSET_UPD_QUANTA_REG,
                     value);
}

static INLINE void etime_reg_OFFSET_UPD_QUANTA_REG_field_set( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 mask,
                                                              UINT32 ofs,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_OFFSET_UPD_QUANTA_REG_field_set( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 mask,
                                                              UINT32 ofs,
                                                              UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_OFFSET_UPD_QUANTA_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_OFFSET_UPD_QUANTA_REG,
                     mask,
                     PMC_ETIME120_REG_OFFSET_UPD_QUANTA_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_OFFSET_UPD_QUANTA_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_OFFSET_UPD_QUANTA_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_OFFSET_UPD_QUANTA_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_OFFSET_UPD_QUANTA_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_LINE_CLK_PER_INT_HI_REG_write( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_LINE_CLK_PER_INT_HI_REG_write( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_LINE_CLK_PER_INT_HI_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_LINE_CLK_PER_INT_HI_REG,
                     value);
}

static INLINE void etime_reg_LINE_CLK_PER_INT_HI_REG_field_set( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 mask,
                                                                UINT32 ofs,
                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_LINE_CLK_PER_INT_HI_REG_field_set( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 mask,
                                                                UINT32 ofs,
                                                                UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_LINE_CLK_PER_INT_HI_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_LINE_CLK_PER_INT_HI_REG,
                     mask,
                     PMC_ETIME120_REG_LINE_CLK_PER_INT_HI_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_LINE_CLK_PER_INT_HI_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_LINE_CLK_PER_INT_HI_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_LINE_CLK_PER_INT_HI_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_LINE_CLK_PER_INT_HI_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_LINE_CLK_PER_INT_LO_REG_write( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_LINE_CLK_PER_INT_LO_REG_write( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_LINE_CLK_PER_INT_LO_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_LINE_CLK_PER_INT_LO_REG,
                     value);
}

static INLINE void etime_reg_LINE_CLK_PER_INT_LO_REG_field_set( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 mask,
                                                                UINT32 ofs,
                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_LINE_CLK_PER_INT_LO_REG_field_set( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 mask,
                                                                UINT32 ofs,
                                                                UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_LINE_CLK_PER_INT_LO_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_LINE_CLK_PER_INT_LO_REG,
                     mask,
                     PMC_ETIME120_REG_LINE_CLK_PER_INT_LO_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_LINE_CLK_PER_INT_LO_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_LINE_CLK_PER_INT_LO_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_LINE_CLK_PER_INT_LO_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_LINE_CLK_PER_INT_LO_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_LINE_CLK_PER_NUM_REG_write( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_LINE_CLK_PER_NUM_REG_write( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_LINE_CLK_PER_NUM_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_LINE_CLK_PER_NUM_REG,
                     value);
}

static INLINE void etime_reg_LINE_CLK_PER_NUM_REG_field_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 mask,
                                                             UINT32 ofs,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_LINE_CLK_PER_NUM_REG_field_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 mask,
                                                             UINT32 ofs,
                                                             UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_LINE_CLK_PER_NUM_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_LINE_CLK_PER_NUM_REG,
                     mask,
                     PMC_ETIME120_REG_LINE_CLK_PER_NUM_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_LINE_CLK_PER_NUM_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_LINE_CLK_PER_NUM_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_LINE_CLK_PER_NUM_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_LINE_CLK_PER_NUM_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_LINE_CLK_PER_DEN_REG_write( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_LINE_CLK_PER_DEN_REG_write( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_LINE_CLK_PER_DEN_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_LINE_CLK_PER_DEN_REG,
                     value);
}

static INLINE void etime_reg_LINE_CLK_PER_DEN_REG_field_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 mask,
                                                             UINT32 ofs,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_LINE_CLK_PER_DEN_REG_field_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 mask,
                                                             UINT32 ofs,
                                                             UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_LINE_CLK_PER_DEN_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_LINE_CLK_PER_DEN_REG,
                     mask,
                     PMC_ETIME120_REG_LINE_CLK_PER_DEN_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_LINE_CLK_PER_DEN_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_LINE_CLK_PER_DEN_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_LINE_CLK_PER_DEN_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_LINE_CLK_PER_DEN_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TX_VEC_IRIGO_4_REG_write( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TX_VEC_IRIGO_4_REG_write( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TX_VEC_IRIGO_4_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TX_VEC_IRIGO_4_REG,
                     value);
}

static INLINE void etime_reg_TX_VEC_IRIGO_4_REG_field_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TX_VEC_IRIGO_4_REG_field_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TX_VEC_IRIGO_4_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TX_VEC_IRIGO_4_REG,
                     mask,
                     PMC_ETIME120_REG_TX_VEC_IRIGO_4_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TX_VEC_IRIGO_4_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TX_VEC_IRIGO_4_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TX_VEC_IRIGO_4_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TX_VEC_IRIGO_4_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TX_VEC_IRIGO_3_REG_write( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TX_VEC_IRIGO_3_REG_write( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TX_VEC_IRIGO_3_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TX_VEC_IRIGO_3_REG,
                     value);
}

static INLINE void etime_reg_TX_VEC_IRIGO_3_REG_field_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TX_VEC_IRIGO_3_REG_field_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TX_VEC_IRIGO_3_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TX_VEC_IRIGO_3_REG,
                     mask,
                     PMC_ETIME120_REG_TX_VEC_IRIGO_3_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TX_VEC_IRIGO_3_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TX_VEC_IRIGO_3_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TX_VEC_IRIGO_3_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TX_VEC_IRIGO_3_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TX_VEC_IRIGO_2_REG_write( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TX_VEC_IRIGO_2_REG_write( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TX_VEC_IRIGO_2_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TX_VEC_IRIGO_2_REG,
                     value);
}

static INLINE void etime_reg_TX_VEC_IRIGO_2_REG_field_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TX_VEC_IRIGO_2_REG_field_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TX_VEC_IRIGO_2_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TX_VEC_IRIGO_2_REG,
                     mask,
                     PMC_ETIME120_REG_TX_VEC_IRIGO_2_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TX_VEC_IRIGO_2_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TX_VEC_IRIGO_2_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TX_VEC_IRIGO_2_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TX_VEC_IRIGO_2_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TX_VEC_IRIGO_1_REG_write( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TX_VEC_IRIGO_1_REG_write( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TX_VEC_IRIGO_1_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TX_VEC_IRIGO_1_REG,
                     value);
}

static INLINE void etime_reg_TX_VEC_IRIGO_1_REG_field_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TX_VEC_IRIGO_1_REG_field_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TX_VEC_IRIGO_1_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_TX_VEC_IRIGO_1_REG,
                     mask,
                     PMC_ETIME120_REG_TX_VEC_IRIGO_1_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TX_VEC_IRIGO_1_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TX_VEC_IRIGO_1_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_TX_VEC_IRIGO_1_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TX_VEC_IRIGO_1_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_IRIGI_CFG_write( etime_buffer_t *b_ptr,
                                              etime_handle_t *h_ptr,
                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGI_CFG_write( etime_buffer_t *b_ptr,
                                              etime_handle_t *h_ptr,
                                              UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_IRIGI_CFG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGI_CFG,
                     value);
}

static INLINE void etime_reg_IRIGI_CFG_field_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 mask,
                                                  UINT32 ofs,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGI_CFG_field_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 mask,
                                                  UINT32 ofs,
                                                  UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_IRIGI_CFG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGI_CFG,
                     mask,
                     PMC_ETIME120_REG_IRIGI_CFG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_IRIGI_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_IRIGI_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_IRIGI_CFG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_IRIGI_CFG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_IRIGI_PWM_ZERO_REG_write( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGI_PWM_ZERO_REG_write( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_IRIGI_PWM_ZERO_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGI_PWM_ZERO_REG,
                     value);
}

static INLINE void etime_reg_IRIGI_PWM_ZERO_REG_field_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGI_PWM_ZERO_REG_field_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_IRIGI_PWM_ZERO_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGI_PWM_ZERO_REG,
                     mask,
                     PMC_ETIME120_REG_IRIGI_PWM_ZERO_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_IRIGI_PWM_ZERO_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_IRIGI_PWM_ZERO_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_IRIGI_PWM_ZERO_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_IRIGI_PWM_ZERO_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_IRIGI_PWM_ONE_REG_write( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGI_PWM_ONE_REG_write( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_IRIGI_PWM_ONE_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGI_PWM_ONE_REG,
                     value);
}

static INLINE void etime_reg_IRIGI_PWM_ONE_REG_field_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 mask,
                                                          UINT32 ofs,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGI_PWM_ONE_REG_field_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 mask,
                                                          UINT32 ofs,
                                                          UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_IRIGI_PWM_ONE_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGI_PWM_ONE_REG,
                     mask,
                     PMC_ETIME120_REG_IRIGI_PWM_ONE_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_IRIGI_PWM_ONE_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_IRIGI_PWM_ONE_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_IRIGI_PWM_ONE_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_IRIGI_PWM_ONE_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_IRIGI_PWM_WIDTH_PX_REG_write( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGI_PWM_WIDTH_PX_REG_write( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_IRIGI_PWM_WIDTH_PX_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGI_PWM_WIDTH_PX_REG,
                     value);
}

static INLINE void etime_reg_IRIGI_PWM_WIDTH_PX_REG_field_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 mask,
                                                               UINT32 ofs,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGI_PWM_WIDTH_PX_REG_field_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 mask,
                                                               UINT32 ofs,
                                                               UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_IRIGI_PWM_WIDTH_PX_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGI_PWM_WIDTH_PX_REG,
                     mask,
                     PMC_ETIME120_REG_IRIGI_PWM_WIDTH_PX_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_IRIGI_PWM_WIDTH_PX_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_IRIGI_PWM_WIDTH_PX_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_IRIGI_PWM_WIDTH_PX_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_IRIGI_PWM_WIDTH_PX_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_IRIGI_PWM_MIN_DIFF_CFG_REG_write( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGI_PWM_MIN_DIFF_CFG_REG_write( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_IRIGI_PWM_MIN_DIFF_CFG_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGI_PWM_MIN_DIFF_CFG_REG,
                     value);
}

static INLINE void etime_reg_IRIGI_PWM_MIN_DIFF_CFG_REG_field_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 mask,
                                                                   UINT32 ofs,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGI_PWM_MIN_DIFF_CFG_REG_field_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 mask,
                                                                   UINT32 ofs,
                                                                   UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_IRIGI_PWM_MIN_DIFF_CFG_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGI_PWM_MIN_DIFF_CFG_REG,
                     mask,
                     PMC_ETIME120_REG_IRIGI_PWM_MIN_DIFF_CFG_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_IRIGI_PWM_MIN_DIFF_CFG_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_IRIGI_PWM_MIN_DIFF_CFG_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_IRIGI_PWM_MIN_DIFF_CFG_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_IRIGI_PWM_MIN_DIFF_CFG_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_IRIGI_PWM_MAX_DIFF_CFG_REG_write( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGI_PWM_MAX_DIFF_CFG_REG_write( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_IRIGI_PWM_MAX_DIFF_CFG_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGI_PWM_MAX_DIFF_CFG_REG,
                     value);
}

static INLINE void etime_reg_IRIGI_PWM_MAX_DIFF_CFG_REG_field_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 mask,
                                                                   UINT32 ofs,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGI_PWM_MAX_DIFF_CFG_REG_field_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 mask,
                                                                   UINT32 ofs,
                                                                   UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_IRIGI_PWM_MAX_DIFF_CFG_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGI_PWM_MAX_DIFF_CFG_REG,
                     mask,
                     PMC_ETIME120_REG_IRIGI_PWM_MAX_DIFF_CFG_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_IRIGI_PWM_MAX_DIFF_CFG_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_IRIGI_PWM_MAX_DIFF_CFG_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_IRIGI_PWM_MAX_DIFF_CFG_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_IRIGI_PWM_MAX_DIFF_CFG_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_IRIGI_DATI_IDLE_DURATION_write( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGI_DATI_IDLE_DURATION_write( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_IRIGI_DATI_IDLE_DURATION_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGI_DATI_IDLE_DURATION,
                     value);
}

static INLINE void etime_reg_IRIGI_DATI_IDLE_DURATION_field_set( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 mask,
                                                                 UINT32 ofs,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGI_DATI_IDLE_DURATION_field_set( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 mask,
                                                                 UINT32 ofs,
                                                                 UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_IRIGI_DATI_IDLE_DURATION_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGI_DATI_IDLE_DURATION,
                     mask,
                     PMC_ETIME120_REG_IRIGI_DATI_IDLE_DURATION_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_IRIGI_DATI_IDLE_DURATION_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_IRIGI_DATI_IDLE_DURATION_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_IRIGI_DATI_IDLE_DURATION);

    IOLOG( "%s -> 0x%08x;", "etime_reg_IRIGI_DATI_IDLE_DURATION_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_IRIGO_CFG_write( etime_buffer_t *b_ptr,
                                              etime_handle_t *h_ptr,
                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGO_CFG_write( etime_buffer_t *b_ptr,
                                              etime_handle_t *h_ptr,
                                              UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_IRIGO_CFG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGO_CFG,
                     value);
}

static INLINE void etime_reg_IRIGO_CFG_field_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 mask,
                                                  UINT32 ofs,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGO_CFG_field_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 mask,
                                                  UINT32 ofs,
                                                  UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_IRIGO_CFG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGO_CFG,
                     mask,
                     PMC_ETIME120_REG_IRIGO_CFG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_IRIGO_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_IRIGO_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_IRIGO_CFG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_IRIGO_CFG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_IRIGO_PWM_NOM_PER_CFG_REG_write( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGO_PWM_NOM_PER_CFG_REG_write( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_IRIGO_PWM_NOM_PER_CFG_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGO_PWM_NOM_PER_CFG_REG,
                     value);
}

static INLINE void etime_reg_IRIGO_PWM_NOM_PER_CFG_REG_field_set( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 mask,
                                                                  UINT32 ofs,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGO_PWM_NOM_PER_CFG_REG_field_set( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 mask,
                                                                  UINT32 ofs,
                                                                  UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_IRIGO_PWM_NOM_PER_CFG_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGO_PWM_NOM_PER_CFG_REG,
                     mask,
                     PMC_ETIME120_REG_IRIGO_PWM_NOM_PER_CFG_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_IRIGO_PWM_NOM_PER_CFG_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_IRIGO_PWM_NOM_PER_CFG_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_IRIGO_PWM_NOM_PER_CFG_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_IRIGO_PWM_NOM_PER_CFG_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_IRIGO_PWM_ONE_REG_write( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGO_PWM_ONE_REG_write( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_IRIGO_PWM_ONE_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGO_PWM_ONE_REG,
                     value);
}

static INLINE void etime_reg_IRIGO_PWM_ONE_REG_field_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 mask,
                                                          UINT32 ofs,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGO_PWM_ONE_REG_field_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 mask,
                                                          UINT32 ofs,
                                                          UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_IRIGO_PWM_ONE_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGO_PWM_ONE_REG,
                     mask,
                     PMC_ETIME120_REG_IRIGO_PWM_ONE_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_IRIGO_PWM_ONE_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_IRIGO_PWM_ONE_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_IRIGO_PWM_ONE_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_IRIGO_PWM_ONE_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_IRIGO_PWM_ZERO_REG_write( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGO_PWM_ZERO_REG_write( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_IRIGO_PWM_ZERO_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGO_PWM_ZERO_REG,
                     value);
}

static INLINE void etime_reg_IRIGO_PWM_ZERO_REG_field_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGO_PWM_ZERO_REG_field_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 mask,
                                                           UINT32 ofs,
                                                           UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_IRIGO_PWM_ZERO_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGO_PWM_ZERO_REG,
                     mask,
                     PMC_ETIME120_REG_IRIGO_PWM_ZERO_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_IRIGO_PWM_ZERO_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_IRIGO_PWM_ZERO_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_IRIGO_PWM_ZERO_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_IRIGO_PWM_ZERO_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_IRIGO_PWM_WIDTH_PX_REG_write( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGO_PWM_WIDTH_PX_REG_write( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_IRIGO_PWM_WIDTH_PX_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGO_PWM_WIDTH_PX_REG,
                     value);
}

static INLINE void etime_reg_IRIGO_PWM_WIDTH_PX_REG_field_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 mask,
                                                               UINT32 ofs,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGO_PWM_WIDTH_PX_REG_field_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 mask,
                                                               UINT32 ofs,
                                                               UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_IRIGO_PWM_WIDTH_PX_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGO_PWM_WIDTH_PX_REG,
                     mask,
                     PMC_ETIME120_REG_IRIGO_PWM_WIDTH_PX_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_IRIGO_PWM_WIDTH_PX_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_IRIGO_PWM_WIDTH_PX_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_IRIGO_PWM_WIDTH_PX_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_IRIGO_PWM_WIDTH_PX_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_IRIGO_PWM_1PPS_WIDTH_REG_write( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGO_PWM_1PPS_WIDTH_REG_write( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_IRIGO_PWM_1PPS_WIDTH_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGO_PWM_1PPS_WIDTH_REG,
                     value);
}

static INLINE void etime_reg_IRIGO_PWM_1PPS_WIDTH_REG_field_set( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 mask,
                                                                 UINT32 ofs,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGO_PWM_1PPS_WIDTH_REG_field_set( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 mask,
                                                                 UINT32 ofs,
                                                                 UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_IRIGO_PWM_1PPS_WIDTH_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGO_PWM_1PPS_WIDTH_REG,
                     mask,
                     PMC_ETIME120_REG_IRIGO_PWM_1PPS_WIDTH_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_IRIGO_PWM_1PPS_WIDTH_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_IRIGO_PWM_1PPS_WIDTH_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_IRIGO_PWM_1PPS_WIDTH_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_IRIGO_PWM_1PPS_WIDTH_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_INT_GEN_CFG_write( etime_buffer_t *b_ptr,
                                                etime_handle_t *h_ptr,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_INT_GEN_CFG_write( etime_buffer_t *b_ptr,
                                                etime_handle_t *h_ptr,
                                                UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_INT_GEN_CFG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_INT_GEN_CFG,
                     value);
}

static INLINE void etime_reg_INT_GEN_CFG_field_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 mask,
                                                    UINT32 ofs,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_INT_GEN_CFG_field_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 mask,
                                                    UINT32 ofs,
                                                    UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_INT_GEN_CFG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_INT_GEN_CFG,
                     mask,
                     PMC_ETIME120_REG_INT_GEN_CFG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_INT_GEN_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_INT_GEN_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_INT_GEN_CFG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_INT_GEN_CFG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_INT_PER_CFG_write( etime_buffer_t *b_ptr,
                                                etime_handle_t *h_ptr,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_INT_PER_CFG_write( etime_buffer_t *b_ptr,
                                                etime_handle_t *h_ptr,
                                                UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_INT_PER_CFG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_INT_PER_CFG,
                     value);
}

static INLINE void etime_reg_INT_PER_CFG_field_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 mask,
                                                    UINT32 ofs,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_INT_PER_CFG_field_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 mask,
                                                    UINT32 ofs,
                                                    UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_INT_PER_CFG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_INT_PER_CFG,
                     mask,
                     PMC_ETIME120_REG_INT_PER_CFG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_INT_PER_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_INT_PER_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_INT_PER_CFG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_INT_PER_CFG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CC_INT_PER_HI_4_CFG_write( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CC_INT_PER_HI_4_CFG_write( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CC_INT_PER_HI_4_CFG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CC_INT_PER_HI_4_CFG,
                     value);
}

static INLINE void etime_reg_CC_INT_PER_HI_4_CFG_field_set( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 mask,
                                                            UINT32 ofs,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CC_INT_PER_HI_4_CFG_field_set( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 mask,
                                                            UINT32 ofs,
                                                            UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CC_INT_PER_HI_4_CFG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CC_INT_PER_HI_4_CFG,
                     mask,
                     PMC_ETIME120_REG_CC_INT_PER_HI_4_CFG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CC_INT_PER_HI_4_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CC_INT_PER_HI_4_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CC_INT_PER_HI_4_CFG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CC_INT_PER_HI_4_CFG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CC_INT_PER_HI_3_CFG_write( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CC_INT_PER_HI_3_CFG_write( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CC_INT_PER_HI_3_CFG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CC_INT_PER_HI_3_CFG,
                     value);
}

static INLINE void etime_reg_CC_INT_PER_HI_3_CFG_field_set( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 mask,
                                                            UINT32 ofs,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CC_INT_PER_HI_3_CFG_field_set( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 mask,
                                                            UINT32 ofs,
                                                            UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CC_INT_PER_HI_3_CFG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CC_INT_PER_HI_3_CFG,
                     mask,
                     PMC_ETIME120_REG_CC_INT_PER_HI_3_CFG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CC_INT_PER_HI_3_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CC_INT_PER_HI_3_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CC_INT_PER_HI_3_CFG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CC_INT_PER_HI_3_CFG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CC_INT_PER_HI_2_CFG_write( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CC_INT_PER_HI_2_CFG_write( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CC_INT_PER_HI_2_CFG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CC_INT_PER_HI_2_CFG,
                     value);
}

static INLINE void etime_reg_CC_INT_PER_HI_2_CFG_field_set( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 mask,
                                                            UINT32 ofs,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CC_INT_PER_HI_2_CFG_field_set( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 mask,
                                                            UINT32 ofs,
                                                            UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CC_INT_PER_HI_2_CFG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CC_INT_PER_HI_2_CFG,
                     mask,
                     PMC_ETIME120_REG_CC_INT_PER_HI_2_CFG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CC_INT_PER_HI_2_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CC_INT_PER_HI_2_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CC_INT_PER_HI_2_CFG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CC_INT_PER_HI_2_CFG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CC_INT_PER_HI_1_CFG_write( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CC_INT_PER_HI_1_CFG_write( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CC_INT_PER_HI_1_CFG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CC_INT_PER_HI_1_CFG,
                     value);
}

static INLINE void etime_reg_CC_INT_PER_HI_1_CFG_field_set( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 mask,
                                                            UINT32 ofs,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CC_INT_PER_HI_1_CFG_field_set( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 mask,
                                                            UINT32 ofs,
                                                            UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CC_INT_PER_HI_1_CFG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CC_INT_PER_HI_1_CFG,
                     mask,
                     PMC_ETIME120_REG_CC_INT_PER_HI_1_CFG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CC_INT_PER_HI_1_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CC_INT_PER_HI_1_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CC_INT_PER_HI_1_CFG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CC_INT_PER_HI_1_CFG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CC_INT_PER_4_CFG_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CC_INT_PER_4_CFG_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CC_INT_PER_4_CFG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CC_INT_PER_4_CFG,
                     value);
}

static INLINE void etime_reg_CC_INT_PER_4_CFG_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CC_INT_PER_4_CFG_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CC_INT_PER_4_CFG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CC_INT_PER_4_CFG,
                     mask,
                     PMC_ETIME120_REG_CC_INT_PER_4_CFG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CC_INT_PER_4_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CC_INT_PER_4_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CC_INT_PER_4_CFG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CC_INT_PER_4_CFG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CC_INT_PER_3_CFG_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CC_INT_PER_3_CFG_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CC_INT_PER_3_CFG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CC_INT_PER_3_CFG,
                     value);
}

static INLINE void etime_reg_CC_INT_PER_3_CFG_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CC_INT_PER_3_CFG_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CC_INT_PER_3_CFG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CC_INT_PER_3_CFG,
                     mask,
                     PMC_ETIME120_REG_CC_INT_PER_3_CFG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CC_INT_PER_3_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CC_INT_PER_3_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CC_INT_PER_3_CFG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CC_INT_PER_3_CFG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CC_INT_PER_2_CFG_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CC_INT_PER_2_CFG_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CC_INT_PER_2_CFG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CC_INT_PER_2_CFG,
                     value);
}

static INLINE void etime_reg_CC_INT_PER_2_CFG_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CC_INT_PER_2_CFG_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CC_INT_PER_2_CFG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CC_INT_PER_2_CFG,
                     mask,
                     PMC_ETIME120_REG_CC_INT_PER_2_CFG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CC_INT_PER_2_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CC_INT_PER_2_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CC_INT_PER_2_CFG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CC_INT_PER_2_CFG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CC_INT_PER_1_CFG_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CC_INT_PER_1_CFG_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CC_INT_PER_1_CFG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CC_INT_PER_1_CFG,
                     value);
}

static INLINE void etime_reg_CC_INT_PER_1_CFG_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CC_INT_PER_1_CFG_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CC_INT_PER_1_CFG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CC_INT_PER_1_CFG,
                     mask,
                     PMC_ETIME120_REG_CC_INT_PER_1_CFG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CC_INT_PER_1_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CC_INT_PER_1_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CC_INT_PER_1_CFG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CC_INT_PER_1_CFG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_REFL_DLY_CFG_write( etime_buffer_t *b_ptr,
                                                 etime_handle_t *h_ptr,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_REFL_DLY_CFG_write( etime_buffer_t *b_ptr,
                                                 etime_handle_t *h_ptr,
                                                 UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_REFL_DLY_CFG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_REFL_DLY_CFG,
                     value);
}

static INLINE void etime_reg_REFL_DLY_CFG_field_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 mask,
                                                     UINT32 ofs,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_REFL_DLY_CFG_field_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 mask,
                                                     UINT32 ofs,
                                                     UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_REFL_DLY_CFG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_REFL_DLY_CFG,
                     mask,
                     PMC_ETIME120_REG_REFL_DLY_CFG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_REFL_DLY_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_REFL_DLY_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_REFL_DLY_CFG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_REFL_DLY_CFG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_INTERPOL_CFG_write( etime_buffer_t *b_ptr,
                                                 etime_handle_t *h_ptr,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_INTERPOL_CFG_write( etime_buffer_t *b_ptr,
                                                 etime_handle_t *h_ptr,
                                                 UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_INTERPOL_CFG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_INTERPOL_CFG,
                     value);
}

static INLINE void etime_reg_INTERPOL_CFG_field_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 mask,
                                                     UINT32 ofs,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_INTERPOL_CFG_field_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 mask,
                                                     UINT32 ofs,
                                                     UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_INTERPOL_CFG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_INTERPOL_CFG,
                     mask,
                     PMC_ETIME120_REG_INTERPOL_CFG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_INTERPOL_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_INTERPOL_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_INTERPOL_CFG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_INTERPOL_CFG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_CAPT_OFFS_write( etime_buffer_t *b_ptr,
                                              etime_handle_t *h_ptr,
                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CAPT_OFFS_write( etime_buffer_t *b_ptr,
                                              etime_handle_t *h_ptr,
                                              UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_CAPT_OFFS_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CAPT_OFFS,
                     value);
}

static INLINE void etime_reg_CAPT_OFFS_field_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 mask,
                                                  UINT32 ofs,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_CAPT_OFFS_field_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 mask,
                                                  UINT32 ofs,
                                                  UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_CAPT_OFFS_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_CAPT_OFFS,
                     mask,
                     PMC_ETIME120_REG_CAPT_OFFS_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_CAPT_OFFS_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CAPT_OFFS_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_CAPT_OFFS);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CAPT_OFFS_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_EXT_CPB_LSC_LOW_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_EXT_CPB_LSC_LOW_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_EXT_CPB_LSC_LOW_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_EXT_CPB_LSC_LOW,
                     value);
}

static INLINE void etime_reg_EXT_CPB_LSC_LOW_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_EXT_CPB_LSC_LOW_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_EXT_CPB_LSC_LOW_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_EXT_CPB_LSC_LOW,
                     mask,
                     PMC_ETIME120_REG_EXT_CPB_LSC_LOW_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_EXT_CPB_LSC_LOW_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_EXT_CPB_LSC_LOW_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_EXT_CPB_LSC_LOW);

    IOLOG( "%s -> 0x%08x;", "etime_reg_EXT_CPB_LSC_LOW_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_EXT_CPB_LSC_HIGH_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_EXT_CPB_LSC_HIGH_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_EXT_CPB_LSC_HIGH_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_EXT_CPB_LSC_HIGH,
                     value);
}

static INLINE void etime_reg_EXT_CPB_LSC_HIGH_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_EXT_CPB_LSC_HIGH_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_EXT_CPB_LSC_HIGH_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_EXT_CPB_LSC_HIGH,
                     mask,
                     PMC_ETIME120_REG_EXT_CPB_LSC_HIGH_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_EXT_CPB_LSC_HIGH_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_EXT_CPB_LSC_HIGH_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_EXT_CPB_LSC_HIGH);

    IOLOG( "%s -> 0x%08x;", "etime_reg_EXT_CPB_LSC_HIGH_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_EXT_CPB_CFG_write( etime_buffer_t *b_ptr,
                                                etime_handle_t *h_ptr,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_EXT_CPB_CFG_write( etime_buffer_t *b_ptr,
                                                etime_handle_t *h_ptr,
                                                UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_EXT_CPB_CFG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_EXT_CPB_CFG,
                     value);
}

static INLINE void etime_reg_EXT_CPB_CFG_field_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 mask,
                                                    UINT32 ofs,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_EXT_CPB_CFG_field_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 mask,
                                                    UINT32 ofs,
                                                    UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_EXT_CPB_CFG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_EXT_CPB_CFG,
                     mask,
                     PMC_ETIME120_REG_EXT_CPB_CFG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_EXT_CPB_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_EXT_CPB_CFG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_EXT_CPB_CFG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_EXT_CPB_CFG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_EXT_NUM_SLOTS_OCCUPIED_write( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_EXT_NUM_SLOTS_OCCUPIED_write( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_EXT_NUM_SLOTS_OCCUPIED_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED,
                     value);
}

static INLINE void etime_reg_EXT_NUM_SLOTS_OCCUPIED_field_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 mask,
                                                               UINT32 ofs,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_EXT_NUM_SLOTS_OCCUPIED_field_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 mask,
                                                               UINT32 ofs,
                                                               UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_EXT_NUM_SLOTS_OCCUPIED_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED,
                     mask,
                     PMC_ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_EXT_NUM_SLOTS_OCCUPIED_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_EXT_NUM_SLOTS_OCCUPIED_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED);

    IOLOG( "%s -> 0x%08x;", "etime_reg_EXT_NUM_SLOTS_OCCUPIED_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_ENA_REG_write( etime_buffer_t *b_ptr,
                                            etime_handle_t *h_ptr,
                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_ENA_REG_write( etime_buffer_t *b_ptr,
                                            etime_handle_t *h_ptr,
                                            UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_ENA_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_ENA_REG,
                     value);
}

static INLINE void etime_reg_ENA_REG_field_set( etime_buffer_t *b_ptr,
                                                etime_handle_t *h_ptr,
                                                UINT32 mask,
                                                UINT32 ofs,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_ENA_REG_field_set( etime_buffer_t *b_ptr,
                                                etime_handle_t *h_ptr,
                                                UINT32 mask,
                                                UINT32 ofs,
                                                UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_ENA_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_ENA_REG,
                     mask,
                     PMC_ETIME120_REG_ENA_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_ENA_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_ENA_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_ENA_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_ENA_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_REFL_DROP_ENA_CFG_REG_write( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_REFL_DROP_ENA_CFG_REG_write( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_REFL_DROP_ENA_CFG_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_REFL_DROP_ENA_CFG_REG,
                     value);
}

static INLINE void etime_reg_REFL_DROP_ENA_CFG_REG_field_set( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 mask,
                                                              UINT32 ofs,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_REFL_DROP_ENA_CFG_REG_field_set( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 mask,
                                                              UINT32 ofs,
                                                              UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_REFL_DROP_ENA_CFG_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_REFL_DROP_ENA_CFG_REG,
                     mask,
                     PMC_ETIME120_REG_REFL_DROP_ENA_CFG_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_REFL_DROP_ENA_CFG_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_REFL_DROP_ENA_CFG_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_REFL_DROP_ENA_CFG_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_REFL_DROP_ENA_CFG_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_LINE_REF_CNT_DLY_REG_write( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_LINE_REF_CNT_DLY_REG_write( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_LINE_REF_CNT_DLY_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_LINE_REF_CNT_DLY_REG,
                     value);
}

static INLINE void etime_reg_LINE_REF_CNT_DLY_REG_field_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 mask,
                                                             UINT32 ofs,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_LINE_REF_CNT_DLY_REG_field_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 mask,
                                                             UINT32 ofs,
                                                             UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_LINE_REF_CNT_DLY_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_LINE_REF_CNT_DLY_REG,
                     mask,
                     PMC_ETIME120_REG_LINE_REF_CNT_DLY_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_LINE_REF_CNT_DLY_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_LINE_REF_CNT_DLY_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_LINE_REF_CNT_DLY_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_LINE_REF_CNT_DLY_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_IRIGO_OFFS_S_REG_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGO_OFFS_S_REG_write( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_IRIGO_OFFS_S_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGO_OFFS_S_REG,
                     value);
}

static INLINE void etime_reg_IRIGO_OFFS_S_REG_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGO_OFFS_S_REG_field_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 mask,
                                                         UINT32 ofs,
                                                         UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_IRIGO_OFFS_S_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGO_OFFS_S_REG,
                     mask,
                     PMC_ETIME120_REG_IRIGO_OFFS_S_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_IRIGO_OFFS_S_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_IRIGO_OFFS_S_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_IRIGO_OFFS_S_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_IRIGO_OFFS_S_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_IRIGO_OFFS_NS_REG_write( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGO_OFFS_NS_REG_write( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_IRIGO_OFFS_NS_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGO_OFFS_NS_REG,
                     value);
}

static INLINE void etime_reg_IRIGO_OFFS_NS_REG_field_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 mask,
                                                          UINT32 ofs,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_IRIGO_OFFS_NS_REG_field_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 mask,
                                                          UINT32 ofs,
                                                          UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_IRIGO_OFFS_NS_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_CONFIG,
                     PMC_ETIME120_REG_IRIGO_OFFS_NS_REG,
                     mask,
                     PMC_ETIME120_REG_IRIGO_OFFS_NS_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_IRIGO_OFFS_NS_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_IRIGO_OFFS_NS_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_CONFIG,
                                PMC_ETIME120_REG_IRIGO_OFFS_NS_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_IRIGO_OFFS_NS_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_REFLLRR_write( etime_buffer_t *b_ptr,
                                            etime_handle_t *h_ptr,
                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_REFLLRR_write( etime_buffer_t *b_ptr,
                                            etime_handle_t *h_ptr,
                                            UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_REFLLRR_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_STATUS,
                     PMC_ETIME120_REG_REFLLRR,
                     value);
}

static INLINE void etime_reg_REFLLRR_field_set( etime_buffer_t *b_ptr,
                                                etime_handle_t *h_ptr,
                                                UINT32 mask,
                                                UINT32 ofs,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_REFLLRR_field_set( etime_buffer_t *b_ptr,
                                                etime_handle_t *h_ptr,
                                                UINT32 mask,
                                                UINT32 ofs,
                                                UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_REFLLRR_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_STATUS,
                     PMC_ETIME120_REG_REFLLRR,
                     mask,
                     PMC_ETIME120_REG_REFLLRR_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_REFLLRR_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_REFLLRR_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_REFLLRR);

    IOLOG( "%s -> 0x%08x;", "etime_reg_REFLLRR_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_EXT_LNK_SCH_UPD_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_EXT_LNK_SCH_UPD_write( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_EXT_LNK_SCH_UPD_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_STATUS,
                     PMC_ETIME120_REG_EXT_LNK_SCH_UPD,
                     value);
}

static INLINE void etime_reg_EXT_LNK_SCH_UPD_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_EXT_LNK_SCH_UPD_field_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 mask,
                                                        UINT32 ofs,
                                                        UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_EXT_LNK_SCH_UPD_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_STATUS,
                     PMC_ETIME120_REG_EXT_LNK_SCH_UPD,
                     mask,
                     PMC_ETIME120_REG_EXT_LNK_SCH_UPD_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_EXT_LNK_SCH_UPD_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_EXT_LNK_SCH_UPD_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_EXT_LNK_SCH_UPD);

    IOLOG( "%s -> 0x%08x;", "etime_reg_EXT_LNK_SCH_UPD_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_SB_ECC_ERR_INT_EN_REG_write( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_SB_ECC_ERR_INT_EN_REG_write( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_SB_ECC_ERR_INT_EN_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_STATUS,
                     PMC_ETIME120_REG_SB_ECC_ERR_INT_EN_REG,
                     value);
}

static INLINE void etime_reg_SB_ECC_ERR_INT_EN_REG_field_set( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 mask,
                                                              UINT32 ofs,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_SB_ECC_ERR_INT_EN_REG_field_set( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 mask,
                                                              UINT32 ofs,
                                                              UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_SB_ECC_ERR_INT_EN_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_STATUS,
                     PMC_ETIME120_REG_SB_ECC_ERR_INT_EN_REG,
                     mask,
                     PMC_ETIME120_REG_SB_ECC_ERR_INT_EN_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_SB_ECC_ERR_INT_EN_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_SB_ECC_ERR_INT_EN_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_SB_ECC_ERR_INT_EN_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_SB_ECC_ERR_INT_EN_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_MB_ECC_ERR_INT_EN_REG_write( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_MB_ECC_ERR_INT_EN_REG_write( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_MB_ECC_ERR_INT_EN_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_STATUS,
                     PMC_ETIME120_REG_MB_ECC_ERR_INT_EN_REG,
                     value);
}

static INLINE void etime_reg_MB_ECC_ERR_INT_EN_REG_field_set( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 mask,
                                                              UINT32 ofs,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_MB_ECC_ERR_INT_EN_REG_field_set( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 mask,
                                                              UINT32 ofs,
                                                              UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_MB_ECC_ERR_INT_EN_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_STATUS,
                     PMC_ETIME120_REG_MB_ECC_ERR_INT_EN_REG,
                     mask,
                     PMC_ETIME120_REG_MB_ECC_ERR_INT_EN_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_MB_ECC_ERR_INT_EN_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_MB_ECC_ERR_INT_EN_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_MB_ECC_ERR_INT_EN_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_MB_ECC_ERR_INT_EN_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_REFL_OFLOW_ERR_INT_EN_REG_write( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_REFL_OFLOW_ERR_INT_EN_REG_write( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_REFL_OFLOW_ERR_INT_EN_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_STATUS,
                     PMC_ETIME120_REG_REFL_OFLOW_ERR_INT_EN_REG,
                     value);
}

static INLINE void etime_reg_REFL_OFLOW_ERR_INT_EN_REG_field_set( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 mask,
                                                                  UINT32 ofs,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_REFL_OFLOW_ERR_INT_EN_REG_field_set( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 mask,
                                                                  UINT32 ofs,
                                                                  UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_REFL_OFLOW_ERR_INT_EN_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_STATUS,
                     PMC_ETIME120_REG_REFL_OFLOW_ERR_INT_EN_REG,
                     mask,
                     PMC_ETIME120_REG_REFL_OFLOW_ERR_INT_EN_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_REFL_OFLOW_ERR_INT_EN_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_REFL_OFLOW_ERR_INT_EN_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_REFL_OFLOW_ERR_INT_EN_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_REFL_OFLOW_ERR_INT_EN_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_TS_DIS_INT_EN_REG_write( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TS_DIS_INT_EN_REG_write( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TS_DIS_INT_EN_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_STATUS,
                     PMC_ETIME120_REG_TS_DIS_INT_EN_REG,
                     value);
}

static INLINE void etime_reg_TS_DIS_INT_EN_REG_field_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 mask,
                                                          UINT32 ofs,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TS_DIS_INT_EN_REG_field_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 mask,
                                                          UINT32 ofs,
                                                          UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TS_DIS_INT_EN_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_STATUS,
                     PMC_ETIME120_REG_TS_DIS_INT_EN_REG,
                     mask,
                     PMC_ETIME120_REG_TS_DIS_INT_EN_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_TS_DIS_INT_EN_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TS_DIS_INT_EN_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_TS_DIS_INT_EN_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TS_DIS_INT_EN_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_PACKET_DIS_INT_EN_REG_write( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_PACKET_DIS_INT_EN_REG_write( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_PACKET_DIS_INT_EN_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_STATUS,
                     PMC_ETIME120_REG_PACKET_DIS_INT_EN_REG,
                     value);
}

static INLINE void etime_reg_PACKET_DIS_INT_EN_REG_field_set( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 mask,
                                                              UINT32 ofs,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_PACKET_DIS_INT_EN_REG_field_set( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 mask,
                                                              UINT32 ofs,
                                                              UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_PACKET_DIS_INT_EN_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_STATUS,
                     PMC_ETIME120_REG_PACKET_DIS_INT_EN_REG,
                     mask,
                     PMC_ETIME120_REG_PACKET_DIS_INT_EN_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_PACKET_DIS_INT_EN_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_PACKET_DIS_INT_EN_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_PACKET_DIS_INT_EN_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_PACKET_DIS_INT_EN_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_PACKET_RAM_ERR_INT_EN_REG_write( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_PACKET_RAM_ERR_INT_EN_REG_write( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_PACKET_RAM_ERR_INT_EN_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_STATUS,
                     PMC_ETIME120_REG_PACKET_RAM_ERR_INT_EN_REG,
                     value);
}

static INLINE void etime_reg_PACKET_RAM_ERR_INT_EN_REG_field_set( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 mask,
                                                                  UINT32 ofs,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_PACKET_RAM_ERR_INT_EN_REG_field_set( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 mask,
                                                                  UINT32 ofs,
                                                                  UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_PACKET_RAM_ERR_INT_EN_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_STATUS,
                     PMC_ETIME120_REG_PACKET_RAM_ERR_INT_EN_REG,
                     mask,
                     PMC_ETIME120_REG_PACKET_RAM_ERR_INT_EN_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_PACKET_RAM_ERR_INT_EN_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_PACKET_RAM_ERR_INT_EN_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_PACKET_RAM_ERR_INT_EN_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_PACKET_RAM_ERR_INT_EN_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_EXT_DESYNC_ERR_INT_EN_REG_write( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_EXT_DESYNC_ERR_INT_EN_REG_write( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_EXT_DESYNC_ERR_INT_EN_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_STATUS,
                     PMC_ETIME120_REG_EXT_DESYNC_ERR_INT_EN_REG,
                     value);
}

static INLINE void etime_reg_EXT_DESYNC_ERR_INT_EN_REG_field_set( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 mask,
                                                                  UINT32 ofs,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_EXT_DESYNC_ERR_INT_EN_REG_field_set( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 mask,
                                                                  UINT32 ofs,
                                                                  UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_EXT_DESYNC_ERR_INT_EN_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_STATUS,
                     PMC_ETIME120_REG_EXT_DESYNC_ERR_INT_EN_REG,
                     mask,
                     PMC_ETIME120_REG_EXT_DESYNC_ERR_INT_EN_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_EXT_DESYNC_ERR_INT_EN_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_EXT_DESYNC_ERR_INT_EN_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_EXT_DESYNC_ERR_INT_EN_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_EXT_DESYNC_ERR_INT_EN_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_GP_INT_EN_REG_write( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_GP_INT_EN_REG_write( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_GP_INT_EN_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_STATUS,
                     PMC_ETIME120_REG_GP_INT_EN_REG,
                     value);
}

static INLINE void etime_reg_GP_INT_EN_REG_field_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 mask,
                                                      UINT32 ofs,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_GP_INT_EN_REG_field_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 mask,
                                                      UINT32 ofs,
                                                      UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_GP_INT_EN_REG_field_set", mask, ofs, value );
    etime_field_set( b_ptr,
                     h_ptr,
                     MEM_TYPE_STATUS,
                     PMC_ETIME120_REG_GP_INT_EN_REG,
                     mask,
                     PMC_ETIME120_REG_GP_INT_EN_REG_UNUSED_MASK,
                     ofs,
                     value);

}

static INLINE UINT32 etime_reg_GP_INT_EN_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_GP_INT_EN_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_GP_INT_EN_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_GP_INT_EN_REG_read", reg_value);
    return reg_value;
}

static INLINE void etime_reg_SB_ECC_ERR_INT_REG_write( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_SB_ECC_ERR_INT_REG_write( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_SB_ECC_ERR_INT_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_STATUS,
                     PMC_ETIME120_REG_SB_ECC_ERR_INT_REG,
                     value);
}

static INLINE void etime_reg_SB_ECC_ERR_INT_REG_action_on_write_field_set( etime_buffer_t *b_ptr,
                                                                           etime_handle_t *h_ptr,
                                                                           UINT32 mask,
                                                                           UINT32 ofs,
                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_SB_ECC_ERR_INT_REG_action_on_write_field_set( etime_buffer_t *b_ptr,
                                                                           etime_handle_t *h_ptr,
                                                                           UINT32 mask,
                                                                           UINT32 ofs,
                                                                           UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_SB_ECC_ERR_INT_REG_action_on_write_field_set", mask, ofs, value );
    etime_action_on_write_field_set( b_ptr,
                                     h_ptr,
                                     MEM_TYPE_STATUS,
                                     PMC_ETIME120_REG_SB_ECC_ERR_INT_REG,
                                     mask,
                                     ofs,
                                     value);

}

static INLINE UINT32 etime_reg_SB_ECC_ERR_INT_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_SB_ECC_ERR_INT_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_SB_ECC_ERR_INT_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_SB_ECC_ERR_INT_REG_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_reg_SB_ECC_ERR_INT_REG_poll( etime_buffer_t *b_ptr,
                                                                      etime_handle_t *h_ptr,
                                                                      UINT32 mask,
                                                                      UINT32 value,
                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                      UINT32 max_count,
                                                                      UINT32 *num_failed_polls,
                                                                      UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_reg_SB_ECC_ERR_INT_REG_poll( etime_buffer_t *b_ptr,
                                                                      etime_handle_t *h_ptr,
                                                                      UINT32 mask,
                                                                      UINT32 value,
                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                      UINT32 max_count,
                                                                      UINT32 *num_failed_polls,
                                                                      UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "etime_reg_SB_ECC_ERR_INT_REG_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return etime_poll( b_ptr,
                       h_ptr,
                       MEM_TYPE_STATUS,
                       PMC_ETIME120_REG_SB_ECC_ERR_INT_REG,
                       mask,
                       value,
                       cmp,
                       max_count,
                       num_failed_polls,
                       delay_between_polls_in_microseconds);

}


static INLINE void etime_reg_MB_ECC_ERR_INT_REG_write( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_MB_ECC_ERR_INT_REG_write( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_MB_ECC_ERR_INT_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_STATUS,
                     PMC_ETIME120_REG_MB_ECC_ERR_INT_REG,
                     value);
}

static INLINE void etime_reg_MB_ECC_ERR_INT_REG_action_on_write_field_set( etime_buffer_t *b_ptr,
                                                                           etime_handle_t *h_ptr,
                                                                           UINT32 mask,
                                                                           UINT32 ofs,
                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_MB_ECC_ERR_INT_REG_action_on_write_field_set( etime_buffer_t *b_ptr,
                                                                           etime_handle_t *h_ptr,
                                                                           UINT32 mask,
                                                                           UINT32 ofs,
                                                                           UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_MB_ECC_ERR_INT_REG_action_on_write_field_set", mask, ofs, value );
    etime_action_on_write_field_set( b_ptr,
                                     h_ptr,
                                     MEM_TYPE_STATUS,
                                     PMC_ETIME120_REG_MB_ECC_ERR_INT_REG,
                                     mask,
                                     ofs,
                                     value);

}

static INLINE UINT32 etime_reg_MB_ECC_ERR_INT_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_MB_ECC_ERR_INT_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_MB_ECC_ERR_INT_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_MB_ECC_ERR_INT_REG_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_reg_MB_ECC_ERR_INT_REG_poll( etime_buffer_t *b_ptr,
                                                                      etime_handle_t *h_ptr,
                                                                      UINT32 mask,
                                                                      UINT32 value,
                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                      UINT32 max_count,
                                                                      UINT32 *num_failed_polls,
                                                                      UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_reg_MB_ECC_ERR_INT_REG_poll( etime_buffer_t *b_ptr,
                                                                      etime_handle_t *h_ptr,
                                                                      UINT32 mask,
                                                                      UINT32 value,
                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                      UINT32 max_count,
                                                                      UINT32 *num_failed_polls,
                                                                      UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "etime_reg_MB_ECC_ERR_INT_REG_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return etime_poll( b_ptr,
                       h_ptr,
                       MEM_TYPE_STATUS,
                       PMC_ETIME120_REG_MB_ECC_ERR_INT_REG,
                       mask,
                       value,
                       cmp,
                       max_count,
                       num_failed_polls,
                       delay_between_polls_in_microseconds);

}


static INLINE void etime_reg_REFL_OFLOW_ERR_INT_REG_write( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_REFL_OFLOW_ERR_INT_REG_write( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_REFL_OFLOW_ERR_INT_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_STATUS,
                     PMC_ETIME120_REG_REFL_OFLOW_ERR_INT_REG,
                     value);
}

static INLINE void etime_reg_REFL_OFLOW_ERR_INT_REG_action_on_write_field_set( etime_buffer_t *b_ptr,
                                                                               etime_handle_t *h_ptr,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_REFL_OFLOW_ERR_INT_REG_action_on_write_field_set( etime_buffer_t *b_ptr,
                                                                               etime_handle_t *h_ptr,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_REFL_OFLOW_ERR_INT_REG_action_on_write_field_set", mask, ofs, value );
    etime_action_on_write_field_set( b_ptr,
                                     h_ptr,
                                     MEM_TYPE_STATUS,
                                     PMC_ETIME120_REG_REFL_OFLOW_ERR_INT_REG,
                                     mask,
                                     ofs,
                                     value);

}

static INLINE UINT32 etime_reg_REFL_OFLOW_ERR_INT_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_REFL_OFLOW_ERR_INT_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_REFL_OFLOW_ERR_INT_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_REFL_OFLOW_ERR_INT_REG_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_reg_REFL_OFLOW_ERR_INT_REG_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 mask,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_reg_REFL_OFLOW_ERR_INT_REG_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 mask,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "etime_reg_REFL_OFLOW_ERR_INT_REG_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return etime_poll( b_ptr,
                       h_ptr,
                       MEM_TYPE_STATUS,
                       PMC_ETIME120_REG_REFL_OFLOW_ERR_INT_REG,
                       mask,
                       value,
                       cmp,
                       max_count,
                       num_failed_polls,
                       delay_between_polls_in_microseconds);

}


static INLINE void etime_reg_TS_DIS_INT_REG_write( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TS_DIS_INT_REG_write( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_TS_DIS_INT_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_STATUS,
                     PMC_ETIME120_REG_TS_DIS_INT_REG,
                     value);
}

static INLINE void etime_reg_TS_DIS_INT_REG_action_on_write_field_set( etime_buffer_t *b_ptr,
                                                                       etime_handle_t *h_ptr,
                                                                       UINT32 mask,
                                                                       UINT32 ofs,
                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_TS_DIS_INT_REG_action_on_write_field_set( etime_buffer_t *b_ptr,
                                                                       etime_handle_t *h_ptr,
                                                                       UINT32 mask,
                                                                       UINT32 ofs,
                                                                       UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_TS_DIS_INT_REG_action_on_write_field_set", mask, ofs, value );
    etime_action_on_write_field_set( b_ptr,
                                     h_ptr,
                                     MEM_TYPE_STATUS,
                                     PMC_ETIME120_REG_TS_DIS_INT_REG,
                                     mask,
                                     ofs,
                                     value);

}

static INLINE UINT32 etime_reg_TS_DIS_INT_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TS_DIS_INT_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_TS_DIS_INT_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TS_DIS_INT_REG_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_reg_TS_DIS_INT_REG_poll( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 mask,
                                                                  UINT32 value,
                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                  UINT32 max_count,
                                                                  UINT32 *num_failed_polls,
                                                                  UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_reg_TS_DIS_INT_REG_poll( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 mask,
                                                                  UINT32 value,
                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                  UINT32 max_count,
                                                                  UINT32 *num_failed_polls,
                                                                  UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "etime_reg_TS_DIS_INT_REG_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return etime_poll( b_ptr,
                       h_ptr,
                       MEM_TYPE_STATUS,
                       PMC_ETIME120_REG_TS_DIS_INT_REG,
                       mask,
                       value,
                       cmp,
                       max_count,
                       num_failed_polls,
                       delay_between_polls_in_microseconds);

}


static INLINE void etime_reg_PACKET_DIS_INT_REG_write( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_PACKET_DIS_INT_REG_write( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_PACKET_DIS_INT_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_STATUS,
                     PMC_ETIME120_REG_PACKET_DIS_INT_REG,
                     value);
}

static INLINE void etime_reg_PACKET_DIS_INT_REG_action_on_write_field_set( etime_buffer_t *b_ptr,
                                                                           etime_handle_t *h_ptr,
                                                                           UINT32 mask,
                                                                           UINT32 ofs,
                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_PACKET_DIS_INT_REG_action_on_write_field_set( etime_buffer_t *b_ptr,
                                                                           etime_handle_t *h_ptr,
                                                                           UINT32 mask,
                                                                           UINT32 ofs,
                                                                           UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_PACKET_DIS_INT_REG_action_on_write_field_set", mask, ofs, value );
    etime_action_on_write_field_set( b_ptr,
                                     h_ptr,
                                     MEM_TYPE_STATUS,
                                     PMC_ETIME120_REG_PACKET_DIS_INT_REG,
                                     mask,
                                     ofs,
                                     value);

}

static INLINE UINT32 etime_reg_PACKET_DIS_INT_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_PACKET_DIS_INT_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_PACKET_DIS_INT_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_PACKET_DIS_INT_REG_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_reg_PACKET_DIS_INT_REG_poll( etime_buffer_t *b_ptr,
                                                                      etime_handle_t *h_ptr,
                                                                      UINT32 mask,
                                                                      UINT32 value,
                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                      UINT32 max_count,
                                                                      UINT32 *num_failed_polls,
                                                                      UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_reg_PACKET_DIS_INT_REG_poll( etime_buffer_t *b_ptr,
                                                                      etime_handle_t *h_ptr,
                                                                      UINT32 mask,
                                                                      UINT32 value,
                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                      UINT32 max_count,
                                                                      UINT32 *num_failed_polls,
                                                                      UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "etime_reg_PACKET_DIS_INT_REG_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return etime_poll( b_ptr,
                       h_ptr,
                       MEM_TYPE_STATUS,
                       PMC_ETIME120_REG_PACKET_DIS_INT_REG,
                       mask,
                       value,
                       cmp,
                       max_count,
                       num_failed_polls,
                       delay_between_polls_in_microseconds);

}


static INLINE void etime_reg_PACKET_RAM_ERR_INT_REG_write( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_PACKET_RAM_ERR_INT_REG_write( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_PACKET_RAM_ERR_INT_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_STATUS,
                     PMC_ETIME120_REG_PACKET_RAM_ERR_INT_REG,
                     value);
}

static INLINE void etime_reg_PACKET_RAM_ERR_INT_REG_action_on_write_field_set( etime_buffer_t *b_ptr,
                                                                               etime_handle_t *h_ptr,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_PACKET_RAM_ERR_INT_REG_action_on_write_field_set( etime_buffer_t *b_ptr,
                                                                               etime_handle_t *h_ptr,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_PACKET_RAM_ERR_INT_REG_action_on_write_field_set", mask, ofs, value );
    etime_action_on_write_field_set( b_ptr,
                                     h_ptr,
                                     MEM_TYPE_STATUS,
                                     PMC_ETIME120_REG_PACKET_RAM_ERR_INT_REG,
                                     mask,
                                     ofs,
                                     value);

}

static INLINE UINT32 etime_reg_PACKET_RAM_ERR_INT_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_PACKET_RAM_ERR_INT_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_PACKET_RAM_ERR_INT_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_PACKET_RAM_ERR_INT_REG_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_reg_PACKET_RAM_ERR_INT_REG_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 mask,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_reg_PACKET_RAM_ERR_INT_REG_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 mask,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "etime_reg_PACKET_RAM_ERR_INT_REG_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return etime_poll( b_ptr,
                       h_ptr,
                       MEM_TYPE_STATUS,
                       PMC_ETIME120_REG_PACKET_RAM_ERR_INT_REG,
                       mask,
                       value,
                       cmp,
                       max_count,
                       num_failed_polls,
                       delay_between_polls_in_microseconds);

}


static INLINE void etime_reg_EXT_DESYNC_ERR_INT_REG_write( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_EXT_DESYNC_ERR_INT_REG_write( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_EXT_DESYNC_ERR_INT_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_STATUS,
                     PMC_ETIME120_REG_EXT_DESYNC_ERR_INT_REG,
                     value);
}

static INLINE void etime_reg_EXT_DESYNC_ERR_INT_REG_action_on_write_field_set( etime_buffer_t *b_ptr,
                                                                               etime_handle_t *h_ptr,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_EXT_DESYNC_ERR_INT_REG_action_on_write_field_set( etime_buffer_t *b_ptr,
                                                                               etime_handle_t *h_ptr,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_EXT_DESYNC_ERR_INT_REG_action_on_write_field_set", mask, ofs, value );
    etime_action_on_write_field_set( b_ptr,
                                     h_ptr,
                                     MEM_TYPE_STATUS,
                                     PMC_ETIME120_REG_EXT_DESYNC_ERR_INT_REG,
                                     mask,
                                     ofs,
                                     value);

}

static INLINE UINT32 etime_reg_EXT_DESYNC_ERR_INT_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_EXT_DESYNC_ERR_INT_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_EXT_DESYNC_ERR_INT_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_EXT_DESYNC_ERR_INT_REG_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_reg_EXT_DESYNC_ERR_INT_REG_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 mask,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_reg_EXT_DESYNC_ERR_INT_REG_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 mask,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "etime_reg_EXT_DESYNC_ERR_INT_REG_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return etime_poll( b_ptr,
                       h_ptr,
                       MEM_TYPE_STATUS,
                       PMC_ETIME120_REG_EXT_DESYNC_ERR_INT_REG,
                       mask,
                       value,
                       cmp,
                       max_count,
                       num_failed_polls,
                       delay_between_polls_in_microseconds);

}


static INLINE void etime_reg_GP_INT_REG_write( etime_buffer_t *b_ptr,
                                               etime_handle_t *h_ptr,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_GP_INT_REG_write( etime_buffer_t *b_ptr,
                                               etime_handle_t *h_ptr,
                                               UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "etime_reg_GP_INT_REG_write", value );
    etime_reg_write( b_ptr,
                     h_ptr,
                     MEM_TYPE_STATUS,
                     PMC_ETIME120_REG_GP_INT_REG,
                     value);
}

static INLINE void etime_reg_GP_INT_REG_action_on_write_field_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 mask,
                                                                   UINT32 ofs,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_reg_GP_INT_REG_action_on_write_field_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 mask,
                                                                   UINT32 ofs,
                                                                   UINT32 value )
{
    IOLOG( "%s <- mask=0x%08x ofs=%d value=0x%08x", "etime_reg_GP_INT_REG_action_on_write_field_set", mask, ofs, value );
    etime_action_on_write_field_set( b_ptr,
                                     h_ptr,
                                     MEM_TYPE_STATUS,
                                     PMC_ETIME120_REG_GP_INT_REG,
                                     mask,
                                     ofs,
                                     value);

}

static INLINE UINT32 etime_reg_GP_INT_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_GP_INT_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_GP_INT_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_GP_INT_REG_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_reg_GP_INT_REG_poll( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 mask,
                                                              UINT32 value,
                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                              UINT32 max_count,
                                                              UINT32 *num_failed_polls,
                                                              UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_reg_GP_INT_REG_poll( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 mask,
                                                              UINT32 value,
                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                              UINT32 max_count,
                                                              UINT32 *num_failed_polls,
                                                              UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "etime_reg_GP_INT_REG_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return etime_poll( b_ptr,
                       h_ptr,
                       MEM_TYPE_STATUS,
                       PMC_ETIME120_REG_GP_INT_REG,
                       mask,
                       value,
                       cmp,
                       max_count,
                       num_failed_polls,
                       delay_between_polls_in_microseconds);

}


static INLINE UINT32 etime_reg_SB_ECC_ERR_INT_VAL_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_SB_ECC_ERR_INT_VAL_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_SB_ECC_ERR_INT_VAL_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_SB_ECC_ERR_INT_VAL_REG_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_reg_SB_ECC_ERR_INT_VAL_REG_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 mask,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_reg_SB_ECC_ERR_INT_VAL_REG_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 mask,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "etime_reg_SB_ECC_ERR_INT_VAL_REG_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return etime_poll( b_ptr,
                       h_ptr,
                       MEM_TYPE_STATUS,
                       PMC_ETIME120_REG_SB_ECC_ERR_INT_VAL_REG,
                       mask,
                       value,
                       cmp,
                       max_count,
                       num_failed_polls,
                       delay_between_polls_in_microseconds);

}


static INLINE UINT32 etime_reg_MB_ECC_ERR_INT_VAL_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_MB_ECC_ERR_INT_VAL_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_MB_ECC_ERR_INT_VAL_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_MB_ECC_ERR_INT_VAL_REG_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_reg_MB_ECC_ERR_INT_VAL_REG_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 mask,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_reg_MB_ECC_ERR_INT_VAL_REG_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 mask,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "etime_reg_MB_ECC_ERR_INT_VAL_REG_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return etime_poll( b_ptr,
                       h_ptr,
                       MEM_TYPE_STATUS,
                       PMC_ETIME120_REG_MB_ECC_ERR_INT_VAL_REG,
                       mask,
                       value,
                       cmp,
                       max_count,
                       num_failed_polls,
                       delay_between_polls_in_microseconds);

}


static INLINE UINT32 etime_reg_REFL_OFLOW_ERR_INT_VAL_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_REFL_OFLOW_ERR_INT_VAL_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_REFL_OFLOW_ERR_INT_VAL_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_REFL_OFLOW_ERR_INT_VAL_REG_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_reg_REFL_OFLOW_ERR_INT_VAL_REG_poll( etime_buffer_t *b_ptr,
                                                                              etime_handle_t *h_ptr,
                                                                              UINT32 mask,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_reg_REFL_OFLOW_ERR_INT_VAL_REG_poll( etime_buffer_t *b_ptr,
                                                                              etime_handle_t *h_ptr,
                                                                              UINT32 mask,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "etime_reg_REFL_OFLOW_ERR_INT_VAL_REG_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return etime_poll( b_ptr,
                       h_ptr,
                       MEM_TYPE_STATUS,
                       PMC_ETIME120_REG_REFL_OFLOW_ERR_INT_VAL_REG,
                       mask,
                       value,
                       cmp,
                       max_count,
                       num_failed_polls,
                       delay_between_polls_in_microseconds);

}


static INLINE UINT32 etime_reg_TS_DIS_INT_VAL_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TS_DIS_INT_VAL_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_TS_DIS_INT_VAL_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TS_DIS_INT_VAL_REG_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_reg_TS_DIS_INT_VAL_REG_poll( etime_buffer_t *b_ptr,
                                                                      etime_handle_t *h_ptr,
                                                                      UINT32 mask,
                                                                      UINT32 value,
                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                      UINT32 max_count,
                                                                      UINT32 *num_failed_polls,
                                                                      UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_reg_TS_DIS_INT_VAL_REG_poll( etime_buffer_t *b_ptr,
                                                                      etime_handle_t *h_ptr,
                                                                      UINT32 mask,
                                                                      UINT32 value,
                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                      UINT32 max_count,
                                                                      UINT32 *num_failed_polls,
                                                                      UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "etime_reg_TS_DIS_INT_VAL_REG_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return etime_poll( b_ptr,
                       h_ptr,
                       MEM_TYPE_STATUS,
                       PMC_ETIME120_REG_TS_DIS_INT_VAL_REG,
                       mask,
                       value,
                       cmp,
                       max_count,
                       num_failed_polls,
                       delay_between_polls_in_microseconds);

}


static INLINE UINT32 etime_reg_PACKET_DIS_INT_VAL_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_PACKET_DIS_INT_VAL_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_PACKET_DIS_INT_VAL_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_PACKET_DIS_INT_VAL_REG_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_reg_PACKET_DIS_INT_VAL_REG_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 mask,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_reg_PACKET_DIS_INT_VAL_REG_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 mask,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "etime_reg_PACKET_DIS_INT_VAL_REG_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return etime_poll( b_ptr,
                       h_ptr,
                       MEM_TYPE_STATUS,
                       PMC_ETIME120_REG_PACKET_DIS_INT_VAL_REG,
                       mask,
                       value,
                       cmp,
                       max_count,
                       num_failed_polls,
                       delay_between_polls_in_microseconds);

}


static INLINE UINT32 etime_reg_PACKET_RAM_ERR_INT_VAL_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_PACKET_RAM_ERR_INT_VAL_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_PACKET_RAM_ERR_INT_VAL_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_PACKET_RAM_ERR_INT_VAL_REG_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_reg_PACKET_RAM_ERR_INT_VAL_REG_poll( etime_buffer_t *b_ptr,
                                                                              etime_handle_t *h_ptr,
                                                                              UINT32 mask,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_reg_PACKET_RAM_ERR_INT_VAL_REG_poll( etime_buffer_t *b_ptr,
                                                                              etime_handle_t *h_ptr,
                                                                              UINT32 mask,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "etime_reg_PACKET_RAM_ERR_INT_VAL_REG_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return etime_poll( b_ptr,
                       h_ptr,
                       MEM_TYPE_STATUS,
                       PMC_ETIME120_REG_PACKET_RAM_ERR_INT_VAL_REG,
                       mask,
                       value,
                       cmp,
                       max_count,
                       num_failed_polls,
                       delay_between_polls_in_microseconds);

}


static INLINE UINT32 etime_reg_EXT_DESYNC_ERR_INT_VAL_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_EXT_DESYNC_ERR_INT_VAL_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_EXT_DESYNC_ERR_INT_VAL_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_EXT_DESYNC_ERR_INT_VAL_REG_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_reg_EXT_DESYNC_ERR_INT_VAL_REG_poll( etime_buffer_t *b_ptr,
                                                                              etime_handle_t *h_ptr,
                                                                              UINT32 mask,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_reg_EXT_DESYNC_ERR_INT_VAL_REG_poll( etime_buffer_t *b_ptr,
                                                                              etime_handle_t *h_ptr,
                                                                              UINT32 mask,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "etime_reg_EXT_DESYNC_ERR_INT_VAL_REG_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return etime_poll( b_ptr,
                       h_ptr,
                       MEM_TYPE_STATUS,
                       PMC_ETIME120_REG_EXT_DESYNC_ERR_INT_VAL_REG,
                       mask,
                       value,
                       cmp,
                       max_count,
                       num_failed_polls,
                       delay_between_polls_in_microseconds);

}


static INLINE UINT32 etime_reg_GP_INT_VAL_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_GP_INT_VAL_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_GP_INT_VAL_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_GP_INT_VAL_REG_read", reg_value);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_reg_GP_INT_VAL_REG_poll( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 mask,
                                                                  UINT32 value,
                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                  UINT32 max_count,
                                                                  UINT32 *num_failed_polls,
                                                                  UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_reg_GP_INT_VAL_REG_poll( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 mask,
                                                                  UINT32 value,
                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                  UINT32 max_count,
                                                                  UINT32 *num_failed_polls,
                                                                  UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "etime_reg_GP_INT_VAL_REG_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return etime_poll( b_ptr,
                       h_ptr,
                       MEM_TYPE_STATUS,
                       PMC_ETIME120_REG_GP_INT_VAL_REG,
                       mask,
                       value,
                       cmp,
                       max_count,
                       num_failed_polls,
                       delay_between_polls_in_microseconds);

}


static INLINE UINT32 etime_reg_PTP_CNT_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_PTP_CNT_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_PTP_CNT);

    IOLOG( "%s -> 0x%08x;", "etime_reg_PTP_CNT_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_LINE_REF_CNT_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_LINE_REF_CNT_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_LINE_REF_CNT);

    IOLOG( "%s -> 0x%08x;", "etime_reg_LINE_REF_CNT_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_TOD_TS_OUT_EXT_SEC_HI_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_TS_OUT_EXT_SEC_HI_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_TOD_TS_OUT_EXT_SEC_HI_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_TS_OUT_EXT_SEC_HI_REG_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_TOD_TS_OUT_EXT_SEC_LO_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_TS_OUT_EXT_SEC_LO_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_TOD_TS_OUT_EXT_SEC_LO_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_TS_OUT_EXT_SEC_LO_REG_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_TOD_TS_OUT_EXT_NSEC_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_TS_OUT_EXT_NSEC_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_TOD_TS_OUT_EXT_NSEC_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_TS_OUT_EXT_NSEC_REG_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_CFC_TS_OUT_EXT_HI_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_TS_OUT_EXT_HI_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_CFC_TS_OUT_EXT_HI_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_TS_OUT_EXT_HI_REG_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_CFC_TS_OUT_EXT_LO_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_TS_OUT_EXT_LO_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_CFC_TS_OUT_EXT_LO_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_TS_OUT_EXT_LO_REG_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_TOD_TS_OUT_IRIGI_SEC_HI_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_TS_OUT_IRIGI_SEC_HI_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_TOD_TS_OUT_IRIGI_SEC_HI_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_TS_OUT_IRIGI_SEC_HI_REG_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_TOD_TS_OUT_IRIGI_SEC_LO_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_TS_OUT_IRIGI_SEC_LO_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_TOD_TS_OUT_IRIGI_SEC_LO_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_TS_OUT_IRIGI_SEC_LO_REG_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_TOD_TS_OUT_IRIGI_NSEC_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_TS_OUT_IRIGI_NSEC_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_TOD_TS_OUT_IRIGI_NSEC_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_TS_OUT_IRIGI_NSEC_REG_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_CFC_TS_OUT_IRIGI_HI_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_TS_OUT_IRIGI_HI_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_CFC_TS_OUT_IRIGI_HI_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_TS_OUT_IRIGI_HI_REG_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_CFC_TS_OUT_IRIGI_LO_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_TS_OUT_IRIGI_LO_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_CFC_TS_OUT_IRIGI_LO_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_TS_OUT_IRIGI_LO_REG_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_TOD_TS_OUT_IRIGO_SEC_HI_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_TS_OUT_IRIGO_SEC_HI_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_TOD_TS_OUT_IRIGO_SEC_HI_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_TS_OUT_IRIGO_SEC_HI_REG_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_TOD_TS_OUT_IRIGO_SEC_LO_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_TS_OUT_IRIGO_SEC_LO_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_TOD_TS_OUT_IRIGO_SEC_LO_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_TS_OUT_IRIGO_SEC_LO_REG_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_TOD_TS_OUT_IRIGO_NSEC_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_TOD_TS_OUT_IRIGO_NSEC_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_TOD_TS_OUT_IRIGO_NSEC_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_TOD_TS_OUT_IRIGO_NSEC_REG_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_CFC_TS_OUT_IRIGO_HI_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_TS_OUT_IRIGO_HI_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_CFC_TS_OUT_IRIGO_HI_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_TS_OUT_IRIGO_HI_REG_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_CFC_TS_OUT_IRIGO_LO_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_CFC_TS_OUT_IRIGO_LO_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_CFC_TS_OUT_IRIGO_LO_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_CFC_TS_OUT_IRIGO_LO_REG_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_RX_VEC_IRIGI_4_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_RX_VEC_IRIGI_4_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_RX_VEC_IRIGI_4_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_RX_VEC_IRIGI_4_REG_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_RX_VEC_IRIGI_3_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_RX_VEC_IRIGI_3_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_RX_VEC_IRIGI_3_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_RX_VEC_IRIGI_3_REG_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_RX_VEC_IRIGI_2_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_RX_VEC_IRIGI_2_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_RX_VEC_IRIGI_2_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_RX_VEC_IRIGI_2_REG_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_RX_VEC_IRIGI_1_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_RX_VEC_IRIGI_1_REG_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_RX_VEC_IRIGI_1_REG);

    IOLOG( "%s -> 0x%08x;", "etime_reg_RX_VEC_IRIGI_1_REG_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_EXT_PMON_LINK0_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_EXT_PMON_LINK0_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_EXT_PMON_LINK0);

    IOLOG( "%s -> 0x%08x;", "etime_reg_EXT_PMON_LINK0_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_EXT_PMON_LINK1_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_EXT_PMON_LINK1_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_EXT_PMON_LINK1);

    IOLOG( "%s -> 0x%08x;", "etime_reg_EXT_PMON_LINK1_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_EXT_PMON_LINK2_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_EXT_PMON_LINK2_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_EXT_PMON_LINK2);

    IOLOG( "%s -> 0x%08x;", "etime_reg_EXT_PMON_LINK2_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_EXT_PMON_LINK3_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_EXT_PMON_LINK3_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_EXT_PMON_LINK3);

    IOLOG( "%s -> 0x%08x;", "etime_reg_EXT_PMON_LINK3_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_EXT_PMON_LINK4_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_EXT_PMON_LINK4_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_EXT_PMON_LINK4);

    IOLOG( "%s -> 0x%08x;", "etime_reg_EXT_PMON_LINK4_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_EXT_PMON_LINK5_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_EXT_PMON_LINK5_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_EXT_PMON_LINK5);

    IOLOG( "%s -> 0x%08x;", "etime_reg_EXT_PMON_LINK5_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_EXT_PMON_LINK6_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_EXT_PMON_LINK6_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_EXT_PMON_LINK6);

    IOLOG( "%s -> 0x%08x;", "etime_reg_EXT_PMON_LINK6_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_EXT_PMON_LINK7_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_EXT_PMON_LINK7_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_EXT_PMON_LINK7);

    IOLOG( "%s -> 0x%08x;", "etime_reg_EXT_PMON_LINK7_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_EXT_PMON_LINK8_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_EXT_PMON_LINK8_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_EXT_PMON_LINK8);

    IOLOG( "%s -> 0x%08x;", "etime_reg_EXT_PMON_LINK8_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_EXT_PMON_LINK9_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_EXT_PMON_LINK9_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_EXT_PMON_LINK9);

    IOLOG( "%s -> 0x%08x;", "etime_reg_EXT_PMON_LINK9_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_EXT_PMON_LINK10_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_EXT_PMON_LINK10_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_EXT_PMON_LINK10);

    IOLOG( "%s -> 0x%08x;", "etime_reg_EXT_PMON_LINK10_read", reg_value);
    return reg_value;
}

static INLINE UINT32 etime_reg_EXT_PMON_LINK11_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_reg_EXT_PMON_LINK11_read( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 reg_value;

    reg_value = etime_reg_read( b_ptr,
                                h_ptr,
                                MEM_TYPE_STATUS,
                                PMC_ETIME120_REG_EXT_PMON_LINK11);

    IOLOG( "%s -> 0x%08x;", "etime_reg_EXT_PMON_LINK11_read", reg_value);
    return reg_value;
}

/*
 * ==================================================================================
 * Parameter Access Functions for Paramset config
 * ==================================================================================
 */
static INLINE void etime_field_WCI_MODE_CONTROL_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_WCI_MODE_CONTROL_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_WCI_MODE_CONTROL_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_WCI_MODE_CONTROL_set", value );

    /* (0x00000004 bits 1) field WCI_MODE_CONTROL of register PMC_ETIME120_REG_INT_BEHAV_CTRL */
    etime_reg_INT_BEHAV_CTRL_field_set( b_ptr,
                                        h_ptr,
                                        ETIME120_REG_INT_BEHAV_CTRL_BIT_WCI_MODE_CONTROL_MSK,
                                        ETIME120_REG_INT_BEHAV_CTRL_BIT_WCI_MODE_CONTROL_OFF,
                                        value);
}

static INLINE UINT32 etime_field_WCI_MODE_CONTROL_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_WCI_MODE_CONTROL_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000004 bits 1) field WCI_MODE_CONTROL of register PMC_ETIME120_REG_INT_BEHAV_CTRL */
    reg_value = etime_reg_INT_BEHAV_CTRL_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_INT_BEHAV_CTRL_BIT_WCI_MODE_CONTROL_MSK) >> ETIME120_REG_INT_BEHAV_CTRL_BIT_WCI_MODE_CONTROL_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_WCI_MODE_CONTROL_get", value );

    return value;
}
static INLINE void etime_field_CLR_INT_CONTROL_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CLR_INT_CONTROL_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CLR_INT_CONTROL_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_CLR_INT_CONTROL_set", value );

    /* (0x00000004 bits 0) field CLR_INT_CONTROL of register PMC_ETIME120_REG_INT_BEHAV_CTRL */
    etime_reg_INT_BEHAV_CTRL_field_set( b_ptr,
                                        h_ptr,
                                        ETIME120_REG_INT_BEHAV_CTRL_BIT_CLR_INT_CONTROL_MSK,
                                        ETIME120_REG_INT_BEHAV_CTRL_BIT_CLR_INT_CONTROL_OFF,
                                        value);
}

static INLINE UINT32 etime_field_CLR_INT_CONTROL_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CLR_INT_CONTROL_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000004 bits 0) field CLR_INT_CONTROL of register PMC_ETIME120_REG_INT_BEHAV_CTRL */
    reg_value = etime_reg_INT_BEHAV_CTRL_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_INT_BEHAV_CTRL_BIT_CLR_INT_CONTROL_MSK) >> ETIME120_REG_INT_BEHAV_CTRL_BIT_CLR_INT_CONTROL_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CLR_INT_CONTROL_get", value );

    return value;
}
static INLINE void etime_field_RAM_LOWPOWER_REG_BIT_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_RAM_LOWPOWER_REG_BIT_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_RAM_LOWPOWER_REG_BIT_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_RAM_LOWPOWER_REG_BIT_set", value );

    /* (0x00000008 bits 4) field RAM_LOWPOWER_REG_BIT of register PMC_ETIME120_REG_RAM_BIST_CTRL */
    etime_reg_RAM_BIST_CTRL_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_RAM_BIST_CTRL_BIT_RAM_LOWPOWER_REG_BIT_MSK,
                                       ETIME120_REG_RAM_BIST_CTRL_BIT_RAM_LOWPOWER_REG_BIT_OFF,
                                       value);
}

static INLINE UINT32 etime_field_RAM_LOWPOWER_REG_BIT_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_RAM_LOWPOWER_REG_BIT_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000008 bits 4) field RAM_LOWPOWER_REG_BIT of register PMC_ETIME120_REG_RAM_BIST_CTRL */
    reg_value = etime_reg_RAM_BIST_CTRL_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_RAM_BIST_CTRL_BIT_RAM_LOWPOWER_REG_BIT_MSK) >> ETIME120_REG_RAM_BIST_CTRL_BIT_RAM_LOWPOWER_REG_BIT_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_RAM_LOWPOWER_REG_BIT_get", value );

    return value;
}
static INLINE void etime_field_PG_OVERRIDE_set( etime_buffer_t *b_ptr,
                                                etime_handle_t *h_ptr,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_PG_OVERRIDE_set( etime_buffer_t *b_ptr,
                                                etime_handle_t *h_ptr,
                                                UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_PG_OVERRIDE_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_PG_OVERRIDE_set", value );

    /* (0x00000008 bits 3) field PG_OVERRIDE of register PMC_ETIME120_REG_RAM_BIST_CTRL */
    etime_reg_RAM_BIST_CTRL_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_RAM_BIST_CTRL_BIT_PG_OVERRIDE_MSK,
                                       ETIME120_REG_RAM_BIST_CTRL_BIT_PG_OVERRIDE_OFF,
                                       value);
}

static INLINE UINT32 etime_field_PG_OVERRIDE_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_PG_OVERRIDE_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000008 bits 3) field PG_OVERRIDE of register PMC_ETIME120_REG_RAM_BIST_CTRL */
    reg_value = etime_reg_RAM_BIST_CTRL_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_RAM_BIST_CTRL_BIT_PG_OVERRIDE_MSK) >> ETIME120_REG_RAM_BIST_CTRL_BIT_PG_OVERRIDE_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_PG_OVERRIDE_get", value );

    return value;
}
static INLINE void etime_field_ECC_BYPASS_set( etime_buffer_t *b_ptr,
                                               etime_handle_t *h_ptr,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_ECC_BYPASS_set( etime_buffer_t *b_ptr,
                                               etime_handle_t *h_ptr,
                                               UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_ECC_BYPASS_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_ECC_BYPASS_set", value );

    /* (0x00000008 bits 2) field ECC_BYPASS of register PMC_ETIME120_REG_RAM_BIST_CTRL */
    etime_reg_RAM_BIST_CTRL_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_RAM_BIST_CTRL_BIT_ECC_BYPASS_MSK,
                                       ETIME120_REG_RAM_BIST_CTRL_BIT_ECC_BYPASS_OFF,
                                       value);
}

static INLINE UINT32 etime_field_ECC_BYPASS_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_ECC_BYPASS_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000008 bits 2) field ECC_BYPASS of register PMC_ETIME120_REG_RAM_BIST_CTRL */
    reg_value = etime_reg_RAM_BIST_CTRL_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_RAM_BIST_CTRL_BIT_ECC_BYPASS_MSK) >> ETIME120_REG_RAM_BIST_CTRL_BIT_ECC_BYPASS_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_ECC_BYPASS_get", value );

    return value;
}
static INLINE void etime_field_RAM_ERR_INJECT_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_RAM_ERR_INJECT_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value )
{
    if (value > 3)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_RAM_ERR_INJECT_set", value, 3);
    IOLOG( "%s <= 0x%08x", "etime_field_RAM_ERR_INJECT_set", value );

    /* (0x00000008 bits 1:0) field RAM_ERR_INJECT of register PMC_ETIME120_REG_RAM_BIST_CTRL */
    etime_reg_RAM_BIST_CTRL_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_RAM_BIST_CTRL_BIT_RAM_ERR_INJECT_MSK,
                                       ETIME120_REG_RAM_BIST_CTRL_BIT_RAM_ERR_INJECT_OFF,
                                       value);
}

static INLINE UINT32 etime_field_RAM_ERR_INJECT_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_RAM_ERR_INJECT_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000008 bits 1:0) field RAM_ERR_INJECT of register PMC_ETIME120_REG_RAM_BIST_CTRL */
    reg_value = etime_reg_RAM_BIST_CTRL_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_RAM_BIST_CTRL_BIT_RAM_ERR_INJECT_MSK) >> ETIME120_REG_RAM_BIST_CTRL_BIT_RAM_ERR_INJECT_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_RAM_ERR_INJECT_get", value );

    return value;
}
static INLINE void etime_field_range_RAM_ERR_INJECT_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_RAM_ERR_INJECT_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_RAM_ERR_INJECT_set", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_RAM_ERR_INJECT_set", stop_bit, 1 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_RAM_ERR_INJECT_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000008 bits 1:0) field RAM_ERR_INJECT of register PMC_ETIME120_REG_RAM_BIST_CTRL */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 1) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 1;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000008 bits 1:0) field RAM_ERR_INJECT of register PMC_ETIME120_REG_RAM_BIST_CTRL */
        etime_reg_RAM_BIST_CTRL_field_set( b_ptr,
                                           h_ptr,
                                           subfield_mask << (ETIME120_REG_RAM_BIST_CTRL_BIT_RAM_ERR_INJECT_OFF + subfield_offset),
                                           ETIME120_REG_RAM_BIST_CTRL_BIT_RAM_ERR_INJECT_OFF + subfield_offset,
                                           value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_RAM_ERR_INJECT_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_RAM_ERR_INJECT_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_RAM_ERR_INJECT_get", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_RAM_ERR_INJECT_get", stop_bit, 1 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 1) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 1;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000008 bits 1:0) field RAM_ERR_INJECT of register PMC_ETIME120_REG_RAM_BIST_CTRL */
    reg_value = etime_reg_RAM_BIST_CTRL_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_RAM_BIST_CTRL_BIT_RAM_ERR_INJECT_MSK)
                  >> ETIME120_REG_RAM_BIST_CTRL_BIT_RAM_ERR_INJECT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_RAM_BIST_CTRL_BIT_RAM_ERR_INJECT_MSK, ETIME120_REG_RAM_BIST_CTRL_BIT_RAM_ERR_INJECT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_RAM_ERR_INJECT_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_ING_47B_M_CH11_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_ING_47B_M_CH11_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_ING_47B_M_CH11_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_ING_47B_M_CH11_set", value );

    /* (0x0000006c bits 11) field ING_47B_M_CH11 of register PMC_ETIME120_REG_ING_47B_M */
    etime_reg_ING_47B_M_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH11_MSK,
                                   ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH11_OFF,
                                   value);
}

static INLINE UINT32 etime_field_ING_47B_M_CH11_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_ING_47B_M_CH11_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000006c bits 11) field ING_47B_M_CH11 of register PMC_ETIME120_REG_ING_47B_M */
    reg_value = etime_reg_ING_47B_M_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH11_MSK) >> ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH11_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_ING_47B_M_CH11_get", value );

    return value;
}
static INLINE void etime_field_ING_47B_M_CH10_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_ING_47B_M_CH10_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_ING_47B_M_CH10_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_ING_47B_M_CH10_set", value );

    /* (0x0000006c bits 10) field ING_47B_M_CH10 of register PMC_ETIME120_REG_ING_47B_M */
    etime_reg_ING_47B_M_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH10_MSK,
                                   ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH10_OFF,
                                   value);
}

static INLINE UINT32 etime_field_ING_47B_M_CH10_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_ING_47B_M_CH10_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000006c bits 10) field ING_47B_M_CH10 of register PMC_ETIME120_REG_ING_47B_M */
    reg_value = etime_reg_ING_47B_M_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH10_MSK) >> ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH10_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_ING_47B_M_CH10_get", value );

    return value;
}
static INLINE void etime_field_ING_47B_M_CH9_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_ING_47B_M_CH9_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_ING_47B_M_CH9_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_ING_47B_M_CH9_set", value );

    /* (0x0000006c bits 9) field ING_47B_M_CH9 of register PMC_ETIME120_REG_ING_47B_M */
    etime_reg_ING_47B_M_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH9_MSK,
                                   ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH9_OFF,
                                   value);
}

static INLINE UINT32 etime_field_ING_47B_M_CH9_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_ING_47B_M_CH9_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000006c bits 9) field ING_47B_M_CH9 of register PMC_ETIME120_REG_ING_47B_M */
    reg_value = etime_reg_ING_47B_M_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH9_MSK) >> ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH9_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_ING_47B_M_CH9_get", value );

    return value;
}
static INLINE void etime_field_ING_47B_M_CH8_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_ING_47B_M_CH8_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_ING_47B_M_CH8_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_ING_47B_M_CH8_set", value );

    /* (0x0000006c bits 8) field ING_47B_M_CH8 of register PMC_ETIME120_REG_ING_47B_M */
    etime_reg_ING_47B_M_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH8_MSK,
                                   ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH8_OFF,
                                   value);
}

static INLINE UINT32 etime_field_ING_47B_M_CH8_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_ING_47B_M_CH8_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000006c bits 8) field ING_47B_M_CH8 of register PMC_ETIME120_REG_ING_47B_M */
    reg_value = etime_reg_ING_47B_M_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH8_MSK) >> ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH8_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_ING_47B_M_CH8_get", value );

    return value;
}
static INLINE void etime_field_ING_47B_M_CH7_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_ING_47B_M_CH7_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_ING_47B_M_CH7_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_ING_47B_M_CH7_set", value );

    /* (0x0000006c bits 7) field ING_47B_M_CH7 of register PMC_ETIME120_REG_ING_47B_M */
    etime_reg_ING_47B_M_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH7_MSK,
                                   ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH7_OFF,
                                   value);
}

static INLINE UINT32 etime_field_ING_47B_M_CH7_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_ING_47B_M_CH7_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000006c bits 7) field ING_47B_M_CH7 of register PMC_ETIME120_REG_ING_47B_M */
    reg_value = etime_reg_ING_47B_M_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH7_MSK) >> ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH7_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_ING_47B_M_CH7_get", value );

    return value;
}
static INLINE void etime_field_ING_47B_M_CH6_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_ING_47B_M_CH6_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_ING_47B_M_CH6_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_ING_47B_M_CH6_set", value );

    /* (0x0000006c bits 6) field ING_47B_M_CH6 of register PMC_ETIME120_REG_ING_47B_M */
    etime_reg_ING_47B_M_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH6_MSK,
                                   ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH6_OFF,
                                   value);
}

static INLINE UINT32 etime_field_ING_47B_M_CH6_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_ING_47B_M_CH6_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000006c bits 6) field ING_47B_M_CH6 of register PMC_ETIME120_REG_ING_47B_M */
    reg_value = etime_reg_ING_47B_M_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH6_MSK) >> ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH6_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_ING_47B_M_CH6_get", value );

    return value;
}
static INLINE void etime_field_ING_47B_M_CH5_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_ING_47B_M_CH5_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_ING_47B_M_CH5_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_ING_47B_M_CH5_set", value );

    /* (0x0000006c bits 5) field ING_47B_M_CH5 of register PMC_ETIME120_REG_ING_47B_M */
    etime_reg_ING_47B_M_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH5_MSK,
                                   ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH5_OFF,
                                   value);
}

static INLINE UINT32 etime_field_ING_47B_M_CH5_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_ING_47B_M_CH5_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000006c bits 5) field ING_47B_M_CH5 of register PMC_ETIME120_REG_ING_47B_M */
    reg_value = etime_reg_ING_47B_M_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH5_MSK) >> ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH5_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_ING_47B_M_CH5_get", value );

    return value;
}
static INLINE void etime_field_ING_47B_M_CH4_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_ING_47B_M_CH4_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_ING_47B_M_CH4_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_ING_47B_M_CH4_set", value );

    /* (0x0000006c bits 4) field ING_47B_M_CH4 of register PMC_ETIME120_REG_ING_47B_M */
    etime_reg_ING_47B_M_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH4_MSK,
                                   ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH4_OFF,
                                   value);
}

static INLINE UINT32 etime_field_ING_47B_M_CH4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_ING_47B_M_CH4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000006c bits 4) field ING_47B_M_CH4 of register PMC_ETIME120_REG_ING_47B_M */
    reg_value = etime_reg_ING_47B_M_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH4_MSK) >> ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH4_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_ING_47B_M_CH4_get", value );

    return value;
}
static INLINE void etime_field_ING_47B_M_CH3_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_ING_47B_M_CH3_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_ING_47B_M_CH3_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_ING_47B_M_CH3_set", value );

    /* (0x0000006c bits 3) field ING_47B_M_CH3 of register PMC_ETIME120_REG_ING_47B_M */
    etime_reg_ING_47B_M_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH3_MSK,
                                   ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH3_OFF,
                                   value);
}

static INLINE UINT32 etime_field_ING_47B_M_CH3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_ING_47B_M_CH3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000006c bits 3) field ING_47B_M_CH3 of register PMC_ETIME120_REG_ING_47B_M */
    reg_value = etime_reg_ING_47B_M_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH3_MSK) >> ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH3_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_ING_47B_M_CH3_get", value );

    return value;
}
static INLINE void etime_field_ING_47B_M_CH2_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_ING_47B_M_CH2_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_ING_47B_M_CH2_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_ING_47B_M_CH2_set", value );

    /* (0x0000006c bits 2) field ING_47B_M_CH2 of register PMC_ETIME120_REG_ING_47B_M */
    etime_reg_ING_47B_M_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH2_MSK,
                                   ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH2_OFF,
                                   value);
}

static INLINE UINT32 etime_field_ING_47B_M_CH2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_ING_47B_M_CH2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000006c bits 2) field ING_47B_M_CH2 of register PMC_ETIME120_REG_ING_47B_M */
    reg_value = etime_reg_ING_47B_M_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH2_MSK) >> ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH2_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_ING_47B_M_CH2_get", value );

    return value;
}
static INLINE void etime_field_ING_47B_M_CH1_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_ING_47B_M_CH1_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_ING_47B_M_CH1_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_ING_47B_M_CH1_set", value );

    /* (0x0000006c bits 1) field ING_47B_M_CH1 of register PMC_ETIME120_REG_ING_47B_M */
    etime_reg_ING_47B_M_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH1_MSK,
                                   ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH1_OFF,
                                   value);
}

static INLINE UINT32 etime_field_ING_47B_M_CH1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_ING_47B_M_CH1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000006c bits 1) field ING_47B_M_CH1 of register PMC_ETIME120_REG_ING_47B_M */
    reg_value = etime_reg_ING_47B_M_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH1_MSK) >> ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH1_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_ING_47B_M_CH1_get", value );

    return value;
}
static INLINE void etime_field_ING_47B_M_CH0_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_ING_47B_M_CH0_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_ING_47B_M_CH0_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_ING_47B_M_CH0_set", value );

    /* (0x0000006c bits 0) field ING_47B_M_CH0 of register PMC_ETIME120_REG_ING_47B_M */
    etime_reg_ING_47B_M_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH0_MSK,
                                   ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH0_OFF,
                                   value);
}

static INLINE UINT32 etime_field_ING_47B_M_CH0_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_ING_47B_M_CH0_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000006c bits 0) field ING_47B_M_CH0 of register PMC_ETIME120_REG_ING_47B_M */
    reg_value = etime_reg_ING_47B_M_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH0_MSK) >> ETIME120_REG_ING_47B_M_BIT_ING_47B_M_CH0_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_ING_47B_M_CH0_get", value );

    return value;
}
static INLINE void etime_field_EGR_47B_M_CH11_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EGR_47B_M_CH11_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EGR_47B_M_CH11_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_EGR_47B_M_CH11_set", value );

    /* (0x00000070 bits 11) field EGR_47B_M_CH11 of register PMC_ETIME120_REG_EGR_47B_M */
    etime_reg_EGR_47B_M_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH11_MSK,
                                   ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH11_OFF,
                                   value);
}

static INLINE UINT32 etime_field_EGR_47B_M_CH11_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EGR_47B_M_CH11_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000070 bits 11) field EGR_47B_M_CH11 of register PMC_ETIME120_REG_EGR_47B_M */
    reg_value = etime_reg_EGR_47B_M_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH11_MSK) >> ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH11_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EGR_47B_M_CH11_get", value );

    return value;
}
static INLINE void etime_field_EGR_47B_M_CH10_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EGR_47B_M_CH10_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EGR_47B_M_CH10_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_EGR_47B_M_CH10_set", value );

    /* (0x00000070 bits 10) field EGR_47B_M_CH10 of register PMC_ETIME120_REG_EGR_47B_M */
    etime_reg_EGR_47B_M_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH10_MSK,
                                   ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH10_OFF,
                                   value);
}

static INLINE UINT32 etime_field_EGR_47B_M_CH10_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EGR_47B_M_CH10_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000070 bits 10) field EGR_47B_M_CH10 of register PMC_ETIME120_REG_EGR_47B_M */
    reg_value = etime_reg_EGR_47B_M_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH10_MSK) >> ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH10_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EGR_47B_M_CH10_get", value );

    return value;
}
static INLINE void etime_field_EGR_47B_M_CH9_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EGR_47B_M_CH9_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EGR_47B_M_CH9_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_EGR_47B_M_CH9_set", value );

    /* (0x00000070 bits 9) field EGR_47B_M_CH9 of register PMC_ETIME120_REG_EGR_47B_M */
    etime_reg_EGR_47B_M_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH9_MSK,
                                   ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH9_OFF,
                                   value);
}

static INLINE UINT32 etime_field_EGR_47B_M_CH9_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EGR_47B_M_CH9_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000070 bits 9) field EGR_47B_M_CH9 of register PMC_ETIME120_REG_EGR_47B_M */
    reg_value = etime_reg_EGR_47B_M_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH9_MSK) >> ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH9_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EGR_47B_M_CH9_get", value );

    return value;
}
static INLINE void etime_field_EGR_47B_M_CH8_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EGR_47B_M_CH8_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EGR_47B_M_CH8_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_EGR_47B_M_CH8_set", value );

    /* (0x00000070 bits 8) field EGR_47B_M_CH8 of register PMC_ETIME120_REG_EGR_47B_M */
    etime_reg_EGR_47B_M_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH8_MSK,
                                   ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH8_OFF,
                                   value);
}

static INLINE UINT32 etime_field_EGR_47B_M_CH8_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EGR_47B_M_CH8_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000070 bits 8) field EGR_47B_M_CH8 of register PMC_ETIME120_REG_EGR_47B_M */
    reg_value = etime_reg_EGR_47B_M_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH8_MSK) >> ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH8_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EGR_47B_M_CH8_get", value );

    return value;
}
static INLINE void etime_field_EGR_47B_M_CH7_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EGR_47B_M_CH7_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EGR_47B_M_CH7_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_EGR_47B_M_CH7_set", value );

    /* (0x00000070 bits 7) field EGR_47B_M_CH7 of register PMC_ETIME120_REG_EGR_47B_M */
    etime_reg_EGR_47B_M_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH7_MSK,
                                   ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH7_OFF,
                                   value);
}

static INLINE UINT32 etime_field_EGR_47B_M_CH7_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EGR_47B_M_CH7_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000070 bits 7) field EGR_47B_M_CH7 of register PMC_ETIME120_REG_EGR_47B_M */
    reg_value = etime_reg_EGR_47B_M_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH7_MSK) >> ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH7_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EGR_47B_M_CH7_get", value );

    return value;
}
static INLINE void etime_field_EGR_47B_M_CH6_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EGR_47B_M_CH6_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EGR_47B_M_CH6_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_EGR_47B_M_CH6_set", value );

    /* (0x00000070 bits 6) field EGR_47B_M_CH6 of register PMC_ETIME120_REG_EGR_47B_M */
    etime_reg_EGR_47B_M_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH6_MSK,
                                   ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH6_OFF,
                                   value);
}

static INLINE UINT32 etime_field_EGR_47B_M_CH6_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EGR_47B_M_CH6_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000070 bits 6) field EGR_47B_M_CH6 of register PMC_ETIME120_REG_EGR_47B_M */
    reg_value = etime_reg_EGR_47B_M_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH6_MSK) >> ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH6_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EGR_47B_M_CH6_get", value );

    return value;
}
static INLINE void etime_field_EGR_47B_M_CH5_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EGR_47B_M_CH5_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EGR_47B_M_CH5_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_EGR_47B_M_CH5_set", value );

    /* (0x00000070 bits 5) field EGR_47B_M_CH5 of register PMC_ETIME120_REG_EGR_47B_M */
    etime_reg_EGR_47B_M_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH5_MSK,
                                   ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH5_OFF,
                                   value);
}

static INLINE UINT32 etime_field_EGR_47B_M_CH5_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EGR_47B_M_CH5_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000070 bits 5) field EGR_47B_M_CH5 of register PMC_ETIME120_REG_EGR_47B_M */
    reg_value = etime_reg_EGR_47B_M_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH5_MSK) >> ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH5_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EGR_47B_M_CH5_get", value );

    return value;
}
static INLINE void etime_field_EGR_47B_M_CH4_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EGR_47B_M_CH4_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EGR_47B_M_CH4_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_EGR_47B_M_CH4_set", value );

    /* (0x00000070 bits 4) field EGR_47B_M_CH4 of register PMC_ETIME120_REG_EGR_47B_M */
    etime_reg_EGR_47B_M_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH4_MSK,
                                   ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH4_OFF,
                                   value);
}

static INLINE UINT32 etime_field_EGR_47B_M_CH4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EGR_47B_M_CH4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000070 bits 4) field EGR_47B_M_CH4 of register PMC_ETIME120_REG_EGR_47B_M */
    reg_value = etime_reg_EGR_47B_M_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH4_MSK) >> ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH4_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EGR_47B_M_CH4_get", value );

    return value;
}
static INLINE void etime_field_EGR_47B_M_CH3_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EGR_47B_M_CH3_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EGR_47B_M_CH3_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_EGR_47B_M_CH3_set", value );

    /* (0x00000070 bits 3) field EGR_47B_M_CH3 of register PMC_ETIME120_REG_EGR_47B_M */
    etime_reg_EGR_47B_M_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH3_MSK,
                                   ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH3_OFF,
                                   value);
}

static INLINE UINT32 etime_field_EGR_47B_M_CH3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EGR_47B_M_CH3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000070 bits 3) field EGR_47B_M_CH3 of register PMC_ETIME120_REG_EGR_47B_M */
    reg_value = etime_reg_EGR_47B_M_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH3_MSK) >> ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH3_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EGR_47B_M_CH3_get", value );

    return value;
}
static INLINE void etime_field_EGR_47B_M_CH2_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EGR_47B_M_CH2_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EGR_47B_M_CH2_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_EGR_47B_M_CH2_set", value );

    /* (0x00000070 bits 2) field EGR_47B_M_CH2 of register PMC_ETIME120_REG_EGR_47B_M */
    etime_reg_EGR_47B_M_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH2_MSK,
                                   ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH2_OFF,
                                   value);
}

static INLINE UINT32 etime_field_EGR_47B_M_CH2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EGR_47B_M_CH2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000070 bits 2) field EGR_47B_M_CH2 of register PMC_ETIME120_REG_EGR_47B_M */
    reg_value = etime_reg_EGR_47B_M_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH2_MSK) >> ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH2_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EGR_47B_M_CH2_get", value );

    return value;
}
static INLINE void etime_field_EGR_47B_M_CH1_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EGR_47B_M_CH1_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EGR_47B_M_CH1_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_EGR_47B_M_CH1_set", value );

    /* (0x00000070 bits 1) field EGR_47B_M_CH1 of register PMC_ETIME120_REG_EGR_47B_M */
    etime_reg_EGR_47B_M_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH1_MSK,
                                   ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH1_OFF,
                                   value);
}

static INLINE UINT32 etime_field_EGR_47B_M_CH1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EGR_47B_M_CH1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000070 bits 1) field EGR_47B_M_CH1 of register PMC_ETIME120_REG_EGR_47B_M */
    reg_value = etime_reg_EGR_47B_M_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH1_MSK) >> ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH1_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EGR_47B_M_CH1_get", value );

    return value;
}
static INLINE void etime_field_EGR_47B_M_CH0_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EGR_47B_M_CH0_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EGR_47B_M_CH0_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_EGR_47B_M_CH0_set", value );

    /* (0x00000070 bits 0) field EGR_47B_M_CH0 of register PMC_ETIME120_REG_EGR_47B_M */
    etime_reg_EGR_47B_M_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH0_MSK,
                                   ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH0_OFF,
                                   value);
}

static INLINE UINT32 etime_field_EGR_47B_M_CH0_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EGR_47B_M_CH0_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000070 bits 0) field EGR_47B_M_CH0 of register PMC_ETIME120_REG_EGR_47B_M */
    reg_value = etime_reg_EGR_47B_M_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH0_MSK) >> ETIME120_REG_EGR_47B_M_BIT_EGR_47B_M_CH0_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EGR_47B_M_CH0_get", value );

    return value;
}
static INLINE void etime_field_RX_TS_ENA_set( etime_buffer_t *b_ptr,
                                              etime_handle_t *h_ptr,
                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_RX_TS_ENA_set( etime_buffer_t *b_ptr,
                                              etime_handle_t *h_ptr,
                                              UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_RX_TS_ENA_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_RX_TS_ENA_set", value );

    /* (0x00000074 bits 0) field RX_TS_ENA of register PMC_ETIME120_REG_ING_TS_ENA_REG */
    etime_reg_ING_TS_ENA_REG_field_set( b_ptr,
                                        h_ptr,
                                        ETIME120_REG_ING_TS_ENA_REG_BIT_RX_TS_ENA_MSK,
                                        ETIME120_REG_ING_TS_ENA_REG_BIT_RX_TS_ENA_OFF,
                                        value);
}

static INLINE UINT32 etime_field_RX_TS_ENA_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_RX_TS_ENA_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000074 bits 0) field RX_TS_ENA of register PMC_ETIME120_REG_ING_TS_ENA_REG */
    reg_value = etime_reg_ING_TS_ENA_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_ING_TS_ENA_REG_BIT_RX_TS_ENA_MSK) >> ETIME120_REG_ING_TS_ENA_REG_BIT_RX_TS_ENA_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_RX_TS_ENA_get", value );

    return value;
}
static INLINE void etime_field_REFL_DEST_CH11_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_DEST_CH11_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_DEST_CH11_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_DEST_CH11_set", value );

    /* (0x00000078 bits 11) field REFL_DEST_CH11 of register PMC_ETIME120_REG_REFL_DEST */
    etime_reg_REFL_DEST_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH11_MSK,
                                   ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH11_OFF,
                                   value);
}

static INLINE UINT32 etime_field_REFL_DEST_CH11_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_DEST_CH11_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000078 bits 11) field REFL_DEST_CH11 of register PMC_ETIME120_REG_REFL_DEST */
    reg_value = etime_reg_REFL_DEST_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH11_MSK) >> ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH11_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_DEST_CH11_get", value );

    return value;
}
static INLINE void etime_field_REFL_DEST_CH10_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_DEST_CH10_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_DEST_CH10_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_DEST_CH10_set", value );

    /* (0x00000078 bits 10) field REFL_DEST_CH10 of register PMC_ETIME120_REG_REFL_DEST */
    etime_reg_REFL_DEST_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH10_MSK,
                                   ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH10_OFF,
                                   value);
}

static INLINE UINT32 etime_field_REFL_DEST_CH10_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_DEST_CH10_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000078 bits 10) field REFL_DEST_CH10 of register PMC_ETIME120_REG_REFL_DEST */
    reg_value = etime_reg_REFL_DEST_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH10_MSK) >> ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH10_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_DEST_CH10_get", value );

    return value;
}
static INLINE void etime_field_REFL_DEST_CH9_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_DEST_CH9_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_DEST_CH9_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_DEST_CH9_set", value );

    /* (0x00000078 bits 9) field REFL_DEST_CH9 of register PMC_ETIME120_REG_REFL_DEST */
    etime_reg_REFL_DEST_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH9_MSK,
                                   ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH9_OFF,
                                   value);
}

static INLINE UINT32 etime_field_REFL_DEST_CH9_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_DEST_CH9_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000078 bits 9) field REFL_DEST_CH9 of register PMC_ETIME120_REG_REFL_DEST */
    reg_value = etime_reg_REFL_DEST_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH9_MSK) >> ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH9_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_DEST_CH9_get", value );

    return value;
}
static INLINE void etime_field_REFL_DEST_CH8_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_DEST_CH8_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_DEST_CH8_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_DEST_CH8_set", value );

    /* (0x00000078 bits 8) field REFL_DEST_CH8 of register PMC_ETIME120_REG_REFL_DEST */
    etime_reg_REFL_DEST_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH8_MSK,
                                   ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH8_OFF,
                                   value);
}

static INLINE UINT32 etime_field_REFL_DEST_CH8_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_DEST_CH8_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000078 bits 8) field REFL_DEST_CH8 of register PMC_ETIME120_REG_REFL_DEST */
    reg_value = etime_reg_REFL_DEST_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH8_MSK) >> ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH8_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_DEST_CH8_get", value );

    return value;
}
static INLINE void etime_field_REFL_DEST_CH7_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_DEST_CH7_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_DEST_CH7_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_DEST_CH7_set", value );

    /* (0x00000078 bits 7) field REFL_DEST_CH7 of register PMC_ETIME120_REG_REFL_DEST */
    etime_reg_REFL_DEST_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH7_MSK,
                                   ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH7_OFF,
                                   value);
}

static INLINE UINT32 etime_field_REFL_DEST_CH7_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_DEST_CH7_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000078 bits 7) field REFL_DEST_CH7 of register PMC_ETIME120_REG_REFL_DEST */
    reg_value = etime_reg_REFL_DEST_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH7_MSK) >> ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH7_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_DEST_CH7_get", value );

    return value;
}
static INLINE void etime_field_REFL_DEST_CH6_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_DEST_CH6_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_DEST_CH6_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_DEST_CH6_set", value );

    /* (0x00000078 bits 6) field REFL_DEST_CH6 of register PMC_ETIME120_REG_REFL_DEST */
    etime_reg_REFL_DEST_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH6_MSK,
                                   ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH6_OFF,
                                   value);
}

static INLINE UINT32 etime_field_REFL_DEST_CH6_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_DEST_CH6_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000078 bits 6) field REFL_DEST_CH6 of register PMC_ETIME120_REG_REFL_DEST */
    reg_value = etime_reg_REFL_DEST_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH6_MSK) >> ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH6_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_DEST_CH6_get", value );

    return value;
}
static INLINE void etime_field_REFL_DEST_CH5_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_DEST_CH5_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_DEST_CH5_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_DEST_CH5_set", value );

    /* (0x00000078 bits 5) field REFL_DEST_CH5 of register PMC_ETIME120_REG_REFL_DEST */
    etime_reg_REFL_DEST_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH5_MSK,
                                   ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH5_OFF,
                                   value);
}

static INLINE UINT32 etime_field_REFL_DEST_CH5_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_DEST_CH5_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000078 bits 5) field REFL_DEST_CH5 of register PMC_ETIME120_REG_REFL_DEST */
    reg_value = etime_reg_REFL_DEST_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH5_MSK) >> ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH5_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_DEST_CH5_get", value );

    return value;
}
static INLINE void etime_field_REFL_DEST_CH4_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_DEST_CH4_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_DEST_CH4_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_DEST_CH4_set", value );

    /* (0x00000078 bits 4) field REFL_DEST_CH4 of register PMC_ETIME120_REG_REFL_DEST */
    etime_reg_REFL_DEST_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH4_MSK,
                                   ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH4_OFF,
                                   value);
}

static INLINE UINT32 etime_field_REFL_DEST_CH4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_DEST_CH4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000078 bits 4) field REFL_DEST_CH4 of register PMC_ETIME120_REG_REFL_DEST */
    reg_value = etime_reg_REFL_DEST_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH4_MSK) >> ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH4_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_DEST_CH4_get", value );

    return value;
}
static INLINE void etime_field_REFL_DEST_CH3_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_DEST_CH3_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_DEST_CH3_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_DEST_CH3_set", value );

    /* (0x00000078 bits 3) field REFL_DEST_CH3 of register PMC_ETIME120_REG_REFL_DEST */
    etime_reg_REFL_DEST_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH3_MSK,
                                   ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH3_OFF,
                                   value);
}

static INLINE UINT32 etime_field_REFL_DEST_CH3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_DEST_CH3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000078 bits 3) field REFL_DEST_CH3 of register PMC_ETIME120_REG_REFL_DEST */
    reg_value = etime_reg_REFL_DEST_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH3_MSK) >> ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH3_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_DEST_CH3_get", value );

    return value;
}
static INLINE void etime_field_REFL_DEST_CH2_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_DEST_CH2_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_DEST_CH2_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_DEST_CH2_set", value );

    /* (0x00000078 bits 2) field REFL_DEST_CH2 of register PMC_ETIME120_REG_REFL_DEST */
    etime_reg_REFL_DEST_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH2_MSK,
                                   ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH2_OFF,
                                   value);
}

static INLINE UINT32 etime_field_REFL_DEST_CH2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_DEST_CH2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000078 bits 2) field REFL_DEST_CH2 of register PMC_ETIME120_REG_REFL_DEST */
    reg_value = etime_reg_REFL_DEST_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH2_MSK) >> ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH2_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_DEST_CH2_get", value );

    return value;
}
static INLINE void etime_field_REFL_DEST_CH1_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_DEST_CH1_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_DEST_CH1_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_DEST_CH1_set", value );

    /* (0x00000078 bits 1) field REFL_DEST_CH1 of register PMC_ETIME120_REG_REFL_DEST */
    etime_reg_REFL_DEST_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH1_MSK,
                                   ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH1_OFF,
                                   value);
}

static INLINE UINT32 etime_field_REFL_DEST_CH1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_DEST_CH1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000078 bits 1) field REFL_DEST_CH1 of register PMC_ETIME120_REG_REFL_DEST */
    reg_value = etime_reg_REFL_DEST_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH1_MSK) >> ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH1_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_DEST_CH1_get", value );

    return value;
}
static INLINE void etime_field_REFL_DEST_CH0_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_DEST_CH0_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_DEST_CH0_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_DEST_CH0_set", value );

    /* (0x00000078 bits 0) field REFL_DEST_CH0 of register PMC_ETIME120_REG_REFL_DEST */
    etime_reg_REFL_DEST_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH0_MSK,
                                   ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH0_OFF,
                                   value);
}

static INLINE UINT32 etime_field_REFL_DEST_CH0_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_DEST_CH0_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000078 bits 0) field REFL_DEST_CH0 of register PMC_ETIME120_REG_REFL_DEST */
    reg_value = etime_reg_REFL_DEST_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH0_MSK) >> ETIME120_REG_REFL_DEST_BIT_REFL_DEST_CH0_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_DEST_CH0_get", value );

    return value;
}
static INLINE void etime_field_TX_TS_ENA_LINK11_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TX_TS_ENA_LINK11_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TX_TS_ENA_LINK11_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_TX_TS_ENA_LINK11_set", value );

    /* (0x0000007c bits 11) field TX_TS_ENA_LINK11 of register PMC_ETIME120_REG_EGR_TS_ENA_REG */
    etime_reg_EGR_TS_ENA_REG_field_set( b_ptr,
                                        h_ptr,
                                        ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK11_MSK,
                                        ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK11_OFF,
                                        value);
}

static INLINE UINT32 etime_field_TX_TS_ENA_LINK11_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TX_TS_ENA_LINK11_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000007c bits 11) field TX_TS_ENA_LINK11 of register PMC_ETIME120_REG_EGR_TS_ENA_REG */
    reg_value = etime_reg_EGR_TS_ENA_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK11_MSK) >> ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK11_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TX_TS_ENA_LINK11_get", value );

    return value;
}
static INLINE void etime_field_TX_TS_ENA_LINK10_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TX_TS_ENA_LINK10_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TX_TS_ENA_LINK10_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_TX_TS_ENA_LINK10_set", value );

    /* (0x0000007c bits 10) field TX_TS_ENA_LINK10 of register PMC_ETIME120_REG_EGR_TS_ENA_REG */
    etime_reg_EGR_TS_ENA_REG_field_set( b_ptr,
                                        h_ptr,
                                        ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK10_MSK,
                                        ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK10_OFF,
                                        value);
}

static INLINE UINT32 etime_field_TX_TS_ENA_LINK10_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TX_TS_ENA_LINK10_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000007c bits 10) field TX_TS_ENA_LINK10 of register PMC_ETIME120_REG_EGR_TS_ENA_REG */
    reg_value = etime_reg_EGR_TS_ENA_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK10_MSK) >> ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK10_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TX_TS_ENA_LINK10_get", value );

    return value;
}
static INLINE void etime_field_TX_TS_ENA_LINK9_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TX_TS_ENA_LINK9_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TX_TS_ENA_LINK9_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_TX_TS_ENA_LINK9_set", value );

    /* (0x0000007c bits 9) field TX_TS_ENA_LINK9 of register PMC_ETIME120_REG_EGR_TS_ENA_REG */
    etime_reg_EGR_TS_ENA_REG_field_set( b_ptr,
                                        h_ptr,
                                        ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK9_MSK,
                                        ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK9_OFF,
                                        value);
}

static INLINE UINT32 etime_field_TX_TS_ENA_LINK9_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TX_TS_ENA_LINK9_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000007c bits 9) field TX_TS_ENA_LINK9 of register PMC_ETIME120_REG_EGR_TS_ENA_REG */
    reg_value = etime_reg_EGR_TS_ENA_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK9_MSK) >> ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK9_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TX_TS_ENA_LINK9_get", value );

    return value;
}
static INLINE void etime_field_TX_TS_ENA_LINK8_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TX_TS_ENA_LINK8_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TX_TS_ENA_LINK8_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_TX_TS_ENA_LINK8_set", value );

    /* (0x0000007c bits 8) field TX_TS_ENA_LINK8 of register PMC_ETIME120_REG_EGR_TS_ENA_REG */
    etime_reg_EGR_TS_ENA_REG_field_set( b_ptr,
                                        h_ptr,
                                        ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK8_MSK,
                                        ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK8_OFF,
                                        value);
}

static INLINE UINT32 etime_field_TX_TS_ENA_LINK8_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TX_TS_ENA_LINK8_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000007c bits 8) field TX_TS_ENA_LINK8 of register PMC_ETIME120_REG_EGR_TS_ENA_REG */
    reg_value = etime_reg_EGR_TS_ENA_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK8_MSK) >> ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK8_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TX_TS_ENA_LINK8_get", value );

    return value;
}
static INLINE void etime_field_TX_TS_ENA_LINK7_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TX_TS_ENA_LINK7_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TX_TS_ENA_LINK7_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_TX_TS_ENA_LINK7_set", value );

    /* (0x0000007c bits 7) field TX_TS_ENA_LINK7 of register PMC_ETIME120_REG_EGR_TS_ENA_REG */
    etime_reg_EGR_TS_ENA_REG_field_set( b_ptr,
                                        h_ptr,
                                        ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK7_MSK,
                                        ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK7_OFF,
                                        value);
}

static INLINE UINT32 etime_field_TX_TS_ENA_LINK7_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TX_TS_ENA_LINK7_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000007c bits 7) field TX_TS_ENA_LINK7 of register PMC_ETIME120_REG_EGR_TS_ENA_REG */
    reg_value = etime_reg_EGR_TS_ENA_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK7_MSK) >> ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK7_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TX_TS_ENA_LINK7_get", value );

    return value;
}
static INLINE void etime_field_TX_TS_ENA_LINK6_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TX_TS_ENA_LINK6_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TX_TS_ENA_LINK6_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_TX_TS_ENA_LINK6_set", value );

    /* (0x0000007c bits 6) field TX_TS_ENA_LINK6 of register PMC_ETIME120_REG_EGR_TS_ENA_REG */
    etime_reg_EGR_TS_ENA_REG_field_set( b_ptr,
                                        h_ptr,
                                        ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK6_MSK,
                                        ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK6_OFF,
                                        value);
}

static INLINE UINT32 etime_field_TX_TS_ENA_LINK6_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TX_TS_ENA_LINK6_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000007c bits 6) field TX_TS_ENA_LINK6 of register PMC_ETIME120_REG_EGR_TS_ENA_REG */
    reg_value = etime_reg_EGR_TS_ENA_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK6_MSK) >> ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK6_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TX_TS_ENA_LINK6_get", value );

    return value;
}
static INLINE void etime_field_TX_TS_ENA_LINK5_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TX_TS_ENA_LINK5_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TX_TS_ENA_LINK5_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_TX_TS_ENA_LINK5_set", value );

    /* (0x0000007c bits 5) field TX_TS_ENA_LINK5 of register PMC_ETIME120_REG_EGR_TS_ENA_REG */
    etime_reg_EGR_TS_ENA_REG_field_set( b_ptr,
                                        h_ptr,
                                        ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK5_MSK,
                                        ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK5_OFF,
                                        value);
}

static INLINE UINT32 etime_field_TX_TS_ENA_LINK5_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TX_TS_ENA_LINK5_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000007c bits 5) field TX_TS_ENA_LINK5 of register PMC_ETIME120_REG_EGR_TS_ENA_REG */
    reg_value = etime_reg_EGR_TS_ENA_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK5_MSK) >> ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK5_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TX_TS_ENA_LINK5_get", value );

    return value;
}
static INLINE void etime_field_TX_TS_ENA_LINK4_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TX_TS_ENA_LINK4_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TX_TS_ENA_LINK4_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_TX_TS_ENA_LINK4_set", value );

    /* (0x0000007c bits 4) field TX_TS_ENA_LINK4 of register PMC_ETIME120_REG_EGR_TS_ENA_REG */
    etime_reg_EGR_TS_ENA_REG_field_set( b_ptr,
                                        h_ptr,
                                        ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK4_MSK,
                                        ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK4_OFF,
                                        value);
}

static INLINE UINT32 etime_field_TX_TS_ENA_LINK4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TX_TS_ENA_LINK4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000007c bits 4) field TX_TS_ENA_LINK4 of register PMC_ETIME120_REG_EGR_TS_ENA_REG */
    reg_value = etime_reg_EGR_TS_ENA_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK4_MSK) >> ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK4_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TX_TS_ENA_LINK4_get", value );

    return value;
}
static INLINE void etime_field_TX_TS_ENA_LINK3_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TX_TS_ENA_LINK3_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TX_TS_ENA_LINK3_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_TX_TS_ENA_LINK3_set", value );

    /* (0x0000007c bits 3) field TX_TS_ENA_LINK3 of register PMC_ETIME120_REG_EGR_TS_ENA_REG */
    etime_reg_EGR_TS_ENA_REG_field_set( b_ptr,
                                        h_ptr,
                                        ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK3_MSK,
                                        ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK3_OFF,
                                        value);
}

static INLINE UINT32 etime_field_TX_TS_ENA_LINK3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TX_TS_ENA_LINK3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000007c bits 3) field TX_TS_ENA_LINK3 of register PMC_ETIME120_REG_EGR_TS_ENA_REG */
    reg_value = etime_reg_EGR_TS_ENA_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK3_MSK) >> ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK3_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TX_TS_ENA_LINK3_get", value );

    return value;
}
static INLINE void etime_field_TX_TS_ENA_LINK2_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TX_TS_ENA_LINK2_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TX_TS_ENA_LINK2_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_TX_TS_ENA_LINK2_set", value );

    /* (0x0000007c bits 2) field TX_TS_ENA_LINK2 of register PMC_ETIME120_REG_EGR_TS_ENA_REG */
    etime_reg_EGR_TS_ENA_REG_field_set( b_ptr,
                                        h_ptr,
                                        ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK2_MSK,
                                        ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK2_OFF,
                                        value);
}

static INLINE UINT32 etime_field_TX_TS_ENA_LINK2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TX_TS_ENA_LINK2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000007c bits 2) field TX_TS_ENA_LINK2 of register PMC_ETIME120_REG_EGR_TS_ENA_REG */
    reg_value = etime_reg_EGR_TS_ENA_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK2_MSK) >> ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK2_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TX_TS_ENA_LINK2_get", value );

    return value;
}
static INLINE void etime_field_TX_TS_ENA_LINK1_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TX_TS_ENA_LINK1_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TX_TS_ENA_LINK1_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_TX_TS_ENA_LINK1_set", value );

    /* (0x0000007c bits 1) field TX_TS_ENA_LINK1 of register PMC_ETIME120_REG_EGR_TS_ENA_REG */
    etime_reg_EGR_TS_ENA_REG_field_set( b_ptr,
                                        h_ptr,
                                        ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK1_MSK,
                                        ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK1_OFF,
                                        value);
}

static INLINE UINT32 etime_field_TX_TS_ENA_LINK1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TX_TS_ENA_LINK1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000007c bits 1) field TX_TS_ENA_LINK1 of register PMC_ETIME120_REG_EGR_TS_ENA_REG */
    reg_value = etime_reg_EGR_TS_ENA_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK1_MSK) >> ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK1_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TX_TS_ENA_LINK1_get", value );

    return value;
}
static INLINE void etime_field_TX_TS_ENA_LINK0_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TX_TS_ENA_LINK0_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TX_TS_ENA_LINK0_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_TX_TS_ENA_LINK0_set", value );

    /* (0x0000007c bits 0) field TX_TS_ENA_LINK0 of register PMC_ETIME120_REG_EGR_TS_ENA_REG */
    etime_reg_EGR_TS_ENA_REG_field_set( b_ptr,
                                        h_ptr,
                                        ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK0_MSK,
                                        ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK0_OFF,
                                        value);
}

static INLINE UINT32 etime_field_TX_TS_ENA_LINK0_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TX_TS_ENA_LINK0_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000007c bits 0) field TX_TS_ENA_LINK0 of register PMC_ETIME120_REG_EGR_TS_ENA_REG */
    reg_value = etime_reg_EGR_TS_ENA_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK0_MSK) >> ETIME120_REG_EGR_TS_ENA_REG_BIT_TX_TS_ENA_LINK0_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TX_TS_ENA_LINK0_get", value );

    return value;
}
static INLINE void etime_field_OFFS_TS_PAGE_set( etime_buffer_t *b_ptr,
                                                 etime_handle_t *h_ptr,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_OFFS_TS_PAGE_set( etime_buffer_t *b_ptr,
                                                 etime_handle_t *h_ptr,
                                                 UINT32 value )
{
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_OFFS_TS_PAGE_set", value, 7);
    IOLOG( "%s <= 0x%08x", "etime_field_OFFS_TS_PAGE_set", value );

    /* (0x00000080 bits 18:16) field OFFS_TS_PAGE of register PMC_ETIME120_REG_TOD_OFFS_SEC_HI */
    etime_reg_TOD_OFFS_SEC_HI_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_TOD_OFFS_SEC_HI_BIT_OFFS_TS_PAGE_MSK,
                                         ETIME120_REG_TOD_OFFS_SEC_HI_BIT_OFFS_TS_PAGE_OFF,
                                         value);
}

static INLINE UINT32 etime_field_OFFS_TS_PAGE_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_OFFS_TS_PAGE_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000080 bits 18:16) field OFFS_TS_PAGE of register PMC_ETIME120_REG_TOD_OFFS_SEC_HI */
    reg_value = etime_reg_TOD_OFFS_SEC_HI_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TOD_OFFS_SEC_HI_BIT_OFFS_TS_PAGE_MSK) >> ETIME120_REG_TOD_OFFS_SEC_HI_BIT_OFFS_TS_PAGE_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_OFFS_TS_PAGE_get", value );

    return value;
}
static INLINE void etime_field_range_OFFS_TS_PAGE_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_OFFS_TS_PAGE_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_OFFS_TS_PAGE_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_OFFS_TS_PAGE_set", stop_bit, 2 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_OFFS_TS_PAGE_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000080 bits 18:16) field OFFS_TS_PAGE of register PMC_ETIME120_REG_TOD_OFFS_SEC_HI */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000080 bits 18:16) field OFFS_TS_PAGE of register PMC_ETIME120_REG_TOD_OFFS_SEC_HI */
        etime_reg_TOD_OFFS_SEC_HI_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_TOD_OFFS_SEC_HI_BIT_OFFS_TS_PAGE_OFF + subfield_offset),
                                             ETIME120_REG_TOD_OFFS_SEC_HI_BIT_OFFS_TS_PAGE_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_OFFS_TS_PAGE_get( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_OFFS_TS_PAGE_get( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_OFFS_TS_PAGE_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_OFFS_TS_PAGE_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000080 bits 18:16) field OFFS_TS_PAGE of register PMC_ETIME120_REG_TOD_OFFS_SEC_HI */
    reg_value = etime_reg_TOD_OFFS_SEC_HI_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_OFFS_SEC_HI_BIT_OFFS_TS_PAGE_MSK)
                  >> ETIME120_REG_TOD_OFFS_SEC_HI_BIT_OFFS_TS_PAGE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_OFFS_SEC_HI_BIT_OFFS_TS_PAGE_MSK, ETIME120_REG_TOD_OFFS_SEC_HI_BIT_OFFS_TS_PAGE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_OFFS_TS_PAGE_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TOD_OFFS_SEC_HI_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_OFFS_SEC_HI_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_OFFS_SEC_HI_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_OFFS_SEC_HI_set", value );

    /* (0x00000080 bits 15:0) field TOD_OFFS_SEC_HI of register PMC_ETIME120_REG_TOD_OFFS_SEC_HI */
    etime_reg_TOD_OFFS_SEC_HI_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_TOD_OFFS_SEC_HI_BIT_TOD_OFFS_SEC_HI_MSK,
                                         ETIME120_REG_TOD_OFFS_SEC_HI_BIT_TOD_OFFS_SEC_HI_OFF,
                                         value);
}

static INLINE UINT32 etime_field_TOD_OFFS_SEC_HI_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_OFFS_SEC_HI_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000080 bits 15:0) field TOD_OFFS_SEC_HI of register PMC_ETIME120_REG_TOD_OFFS_SEC_HI */
    reg_value = etime_reg_TOD_OFFS_SEC_HI_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TOD_OFFS_SEC_HI_BIT_TOD_OFFS_SEC_HI_MSK) >> ETIME120_REG_TOD_OFFS_SEC_HI_BIT_TOD_OFFS_SEC_HI_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_OFFS_SEC_HI_get", value );

    return value;
}
static INLINE void etime_field_range_TOD_OFFS_SEC_HI_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TOD_OFFS_SEC_HI_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_OFFS_SEC_HI_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_OFFS_SEC_HI_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_OFFS_SEC_HI_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000080 bits 15:0) field TOD_OFFS_SEC_HI of register PMC_ETIME120_REG_TOD_OFFS_SEC_HI */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000080 bits 15:0) field TOD_OFFS_SEC_HI of register PMC_ETIME120_REG_TOD_OFFS_SEC_HI */
        etime_reg_TOD_OFFS_SEC_HI_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_TOD_OFFS_SEC_HI_BIT_TOD_OFFS_SEC_HI_OFF + subfield_offset),
                                             ETIME120_REG_TOD_OFFS_SEC_HI_BIT_TOD_OFFS_SEC_HI_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TOD_OFFS_SEC_HI_get( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_OFFS_SEC_HI_get( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_OFFS_SEC_HI_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_OFFS_SEC_HI_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000080 bits 15:0) field TOD_OFFS_SEC_HI of register PMC_ETIME120_REG_TOD_OFFS_SEC_HI */
    reg_value = etime_reg_TOD_OFFS_SEC_HI_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_OFFS_SEC_HI_BIT_TOD_OFFS_SEC_HI_MSK)
                  >> ETIME120_REG_TOD_OFFS_SEC_HI_BIT_TOD_OFFS_SEC_HI_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_OFFS_SEC_HI_BIT_TOD_OFFS_SEC_HI_MSK, ETIME120_REG_TOD_OFFS_SEC_HI_BIT_TOD_OFFS_SEC_HI_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_OFFS_SEC_HI_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TOD_OFFS_SEC_LO_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_OFFS_SEC_LO_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_OFFS_SEC_LO_set", value );

    /* (0x00000084 bits 31:0) field TOD_OFFS_SEC_LO of register PMC_ETIME120_REG_TOD_OFFS_SEC_LO */
    etime_reg_TOD_OFFS_SEC_LO_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_TOD_OFFS_SEC_LO_BIT_TOD_OFFS_SEC_LO_MSK,
                                         ETIME120_REG_TOD_OFFS_SEC_LO_BIT_TOD_OFFS_SEC_LO_OFF,
                                         value);
}

static INLINE UINT32 etime_field_TOD_OFFS_SEC_LO_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_OFFS_SEC_LO_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000084 bits 31:0) field TOD_OFFS_SEC_LO of register PMC_ETIME120_REG_TOD_OFFS_SEC_LO */
    reg_value = etime_reg_TOD_OFFS_SEC_LO_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TOD_OFFS_SEC_LO_BIT_TOD_OFFS_SEC_LO_MSK) >> ETIME120_REG_TOD_OFFS_SEC_LO_BIT_TOD_OFFS_SEC_LO_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_OFFS_SEC_LO_get", value );

    return value;
}
static INLINE void etime_field_range_TOD_OFFS_SEC_LO_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TOD_OFFS_SEC_LO_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_OFFS_SEC_LO_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_OFFS_SEC_LO_set", stop_bit, 31 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_OFFS_SEC_LO_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000084 bits 31:0) field TOD_OFFS_SEC_LO of register PMC_ETIME120_REG_TOD_OFFS_SEC_LO */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000084 bits 31:0) field TOD_OFFS_SEC_LO of register PMC_ETIME120_REG_TOD_OFFS_SEC_LO */
        etime_reg_TOD_OFFS_SEC_LO_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_TOD_OFFS_SEC_LO_BIT_TOD_OFFS_SEC_LO_OFF + subfield_offset),
                                             ETIME120_REG_TOD_OFFS_SEC_LO_BIT_TOD_OFFS_SEC_LO_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TOD_OFFS_SEC_LO_get( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_OFFS_SEC_LO_get( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_OFFS_SEC_LO_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_OFFS_SEC_LO_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000084 bits 31:0) field TOD_OFFS_SEC_LO of register PMC_ETIME120_REG_TOD_OFFS_SEC_LO */
    reg_value = etime_reg_TOD_OFFS_SEC_LO_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_OFFS_SEC_LO_BIT_TOD_OFFS_SEC_LO_MSK)
                  >> ETIME120_REG_TOD_OFFS_SEC_LO_BIT_TOD_OFFS_SEC_LO_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_OFFS_SEC_LO_BIT_TOD_OFFS_SEC_LO_MSK, ETIME120_REG_TOD_OFFS_SEC_LO_BIT_TOD_OFFS_SEC_LO_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_OFFS_SEC_LO_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TOD_OFFS_NSEC_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_OFFS_NSEC_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_OFFS_NSEC_set", value );

    /* (0x00000088 bits 31:0) field TOD_OFFS_NSEC of register PMC_ETIME120_REG_TOD_OFFS_NSEC */
    etime_reg_TOD_OFFS_NSEC_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_TOD_OFFS_NSEC_BIT_TOD_OFFS_NSEC_MSK,
                                       ETIME120_REG_TOD_OFFS_NSEC_BIT_TOD_OFFS_NSEC_OFF,
                                       value);
}

static INLINE UINT32 etime_field_TOD_OFFS_NSEC_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_OFFS_NSEC_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000088 bits 31:0) field TOD_OFFS_NSEC of register PMC_ETIME120_REG_TOD_OFFS_NSEC */
    reg_value = etime_reg_TOD_OFFS_NSEC_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TOD_OFFS_NSEC_BIT_TOD_OFFS_NSEC_MSK) >> ETIME120_REG_TOD_OFFS_NSEC_BIT_TOD_OFFS_NSEC_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_OFFS_NSEC_get", value );

    return value;
}
static INLINE void etime_field_range_TOD_OFFS_NSEC_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TOD_OFFS_NSEC_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_OFFS_NSEC_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_OFFS_NSEC_set", stop_bit, 31 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_OFFS_NSEC_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000088 bits 31:0) field TOD_OFFS_NSEC of register PMC_ETIME120_REG_TOD_OFFS_NSEC */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000088 bits 31:0) field TOD_OFFS_NSEC of register PMC_ETIME120_REG_TOD_OFFS_NSEC */
        etime_reg_TOD_OFFS_NSEC_field_set( b_ptr,
                                           h_ptr,
                                           subfield_mask << (ETIME120_REG_TOD_OFFS_NSEC_BIT_TOD_OFFS_NSEC_OFF + subfield_offset),
                                           ETIME120_REG_TOD_OFFS_NSEC_BIT_TOD_OFFS_NSEC_OFF + subfield_offset,
                                           value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TOD_OFFS_NSEC_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_OFFS_NSEC_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_OFFS_NSEC_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_OFFS_NSEC_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000088 bits 31:0) field TOD_OFFS_NSEC of register PMC_ETIME120_REG_TOD_OFFS_NSEC */
    reg_value = etime_reg_TOD_OFFS_NSEC_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_OFFS_NSEC_BIT_TOD_OFFS_NSEC_MSK)
                  >> ETIME120_REG_TOD_OFFS_NSEC_BIT_TOD_OFFS_NSEC_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_OFFS_NSEC_BIT_TOD_OFFS_NSEC_MSK, ETIME120_REG_TOD_OFFS_NSEC_BIT_TOD_OFFS_NSEC_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_OFFS_NSEC_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CFC_OFFS_NSEC_HI_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CFC_OFFS_NSEC_HI_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CFC_OFFS_NSEC_HI_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_CFC_OFFS_NSEC_HI_set", value );

    /* (0x0000008c bits 15:0) field CFC_OFFS_NSEC_HI of register PMC_ETIME120_REG_CFC_OFFS_NSEC_HI */
    etime_reg_CFC_OFFS_NSEC_HI_field_set( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_CFC_OFFS_NSEC_HI_BIT_CFC_OFFS_NSEC_HI_MSK,
                                          ETIME120_REG_CFC_OFFS_NSEC_HI_BIT_CFC_OFFS_NSEC_HI_OFF,
                                          value);
}

static INLINE UINT32 etime_field_CFC_OFFS_NSEC_HI_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_OFFS_NSEC_HI_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000008c bits 15:0) field CFC_OFFS_NSEC_HI of register PMC_ETIME120_REG_CFC_OFFS_NSEC_HI */
    reg_value = etime_reg_CFC_OFFS_NSEC_HI_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CFC_OFFS_NSEC_HI_BIT_CFC_OFFS_NSEC_HI_MSK) >> ETIME120_REG_CFC_OFFS_NSEC_HI_BIT_CFC_OFFS_NSEC_HI_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_OFFS_NSEC_HI_get", value );

    return value;
}
static INLINE void etime_field_range_CFC_OFFS_NSEC_HI_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CFC_OFFS_NSEC_HI_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit,
                                                           UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_OFFS_NSEC_HI_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_OFFS_NSEC_HI_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_OFFS_NSEC_HI_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000008c bits 15:0) field CFC_OFFS_NSEC_HI of register PMC_ETIME120_REG_CFC_OFFS_NSEC_HI */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000008c bits 15:0) field CFC_OFFS_NSEC_HI of register PMC_ETIME120_REG_CFC_OFFS_NSEC_HI */
        etime_reg_CFC_OFFS_NSEC_HI_field_set( b_ptr,
                                              h_ptr,
                                              subfield_mask << (ETIME120_REG_CFC_OFFS_NSEC_HI_BIT_CFC_OFFS_NSEC_HI_OFF + subfield_offset),
                                              ETIME120_REG_CFC_OFFS_NSEC_HI_BIT_CFC_OFFS_NSEC_HI_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CFC_OFFS_NSEC_HI_get( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_OFFS_NSEC_HI_get( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_OFFS_NSEC_HI_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_OFFS_NSEC_HI_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000008c bits 15:0) field CFC_OFFS_NSEC_HI of register PMC_ETIME120_REG_CFC_OFFS_NSEC_HI */
    reg_value = etime_reg_CFC_OFFS_NSEC_HI_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_OFFS_NSEC_HI_BIT_CFC_OFFS_NSEC_HI_MSK)
                  >> ETIME120_REG_CFC_OFFS_NSEC_HI_BIT_CFC_OFFS_NSEC_HI_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_OFFS_NSEC_HI_BIT_CFC_OFFS_NSEC_HI_MSK, ETIME120_REG_CFC_OFFS_NSEC_HI_BIT_CFC_OFFS_NSEC_HI_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_OFFS_NSEC_HI_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CFC_OFFS_NSEC_LO_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CFC_OFFS_NSEC_LO_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    IOLOG( "%s <= 0x%08x", "etime_field_CFC_OFFS_NSEC_LO_set", value );

    /* (0x00000090 bits 31:0) field CFC_OFFS_NSEC_LO of register PMC_ETIME120_REG_CFC_OFFS_NSEC_LO */
    etime_reg_CFC_OFFS_NSEC_LO_field_set( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_CFC_OFFS_NSEC_LO_BIT_CFC_OFFS_NSEC_LO_MSK,
                                          ETIME120_REG_CFC_OFFS_NSEC_LO_BIT_CFC_OFFS_NSEC_LO_OFF,
                                          value);
}

static INLINE UINT32 etime_field_CFC_OFFS_NSEC_LO_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_OFFS_NSEC_LO_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000090 bits 31:0) field CFC_OFFS_NSEC_LO of register PMC_ETIME120_REG_CFC_OFFS_NSEC_LO */
    reg_value = etime_reg_CFC_OFFS_NSEC_LO_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CFC_OFFS_NSEC_LO_BIT_CFC_OFFS_NSEC_LO_MSK) >> ETIME120_REG_CFC_OFFS_NSEC_LO_BIT_CFC_OFFS_NSEC_LO_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_OFFS_NSEC_LO_get", value );

    return value;
}
static INLINE void etime_field_range_CFC_OFFS_NSEC_LO_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CFC_OFFS_NSEC_LO_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit,
                                                           UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_OFFS_NSEC_LO_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_OFFS_NSEC_LO_set", stop_bit, 31 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_OFFS_NSEC_LO_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000090 bits 31:0) field CFC_OFFS_NSEC_LO of register PMC_ETIME120_REG_CFC_OFFS_NSEC_LO */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000090 bits 31:0) field CFC_OFFS_NSEC_LO of register PMC_ETIME120_REG_CFC_OFFS_NSEC_LO */
        etime_reg_CFC_OFFS_NSEC_LO_field_set( b_ptr,
                                              h_ptr,
                                              subfield_mask << (ETIME120_REG_CFC_OFFS_NSEC_LO_BIT_CFC_OFFS_NSEC_LO_OFF + subfield_offset),
                                              ETIME120_REG_CFC_OFFS_NSEC_LO_BIT_CFC_OFFS_NSEC_LO_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CFC_OFFS_NSEC_LO_get( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_OFFS_NSEC_LO_get( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_OFFS_NSEC_LO_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_OFFS_NSEC_LO_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000090 bits 31:0) field CFC_OFFS_NSEC_LO of register PMC_ETIME120_REG_CFC_OFFS_NSEC_LO */
    reg_value = etime_reg_CFC_OFFS_NSEC_LO_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_OFFS_NSEC_LO_BIT_CFC_OFFS_NSEC_LO_MSK)
                  >> ETIME120_REG_CFC_OFFS_NSEC_LO_BIT_CFC_OFFS_NSEC_LO_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_OFFS_NSEC_LO_BIT_CFC_OFFS_NSEC_LO_MSK, ETIME120_REG_CFC_OFFS_NSEC_LO_BIT_CFC_OFFS_NSEC_LO_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_OFFS_NSEC_LO_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TOD_ING_DLY_0_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_ING_DLY_0_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_ING_DLY_0_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_ING_DLY_0_set", value );

    /* (0x00000094 bits 15:0) field TOD_ING_DLY_0 of register PMC_ETIME120_REG_TOD_ING_DLY_CH0 */
    etime_reg_TOD_ING_DLY_CH0_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_TOD_ING_DLY_CH0_BIT_TOD_ING_DLY_0_MSK,
                                         ETIME120_REG_TOD_ING_DLY_CH0_BIT_TOD_ING_DLY_0_OFF,
                                         value);
}

static INLINE UINT32 etime_field_TOD_ING_DLY_0_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_ING_DLY_0_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000094 bits 15:0) field TOD_ING_DLY_0 of register PMC_ETIME120_REG_TOD_ING_DLY_CH0 */
    reg_value = etime_reg_TOD_ING_DLY_CH0_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TOD_ING_DLY_CH0_BIT_TOD_ING_DLY_0_MSK) >> ETIME120_REG_TOD_ING_DLY_CH0_BIT_TOD_ING_DLY_0_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_ING_DLY_0_get", value );

    return value;
}
static INLINE void etime_field_range_TOD_ING_DLY_0_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TOD_ING_DLY_0_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_ING_DLY_0_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_ING_DLY_0_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_ING_DLY_0_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000094 bits 15:0) field TOD_ING_DLY_0 of register PMC_ETIME120_REG_TOD_ING_DLY_CH0 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000094 bits 15:0) field TOD_ING_DLY_0 of register PMC_ETIME120_REG_TOD_ING_DLY_CH0 */
        etime_reg_TOD_ING_DLY_CH0_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_TOD_ING_DLY_CH0_BIT_TOD_ING_DLY_0_OFF + subfield_offset),
                                             ETIME120_REG_TOD_ING_DLY_CH0_BIT_TOD_ING_DLY_0_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TOD_ING_DLY_0_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_ING_DLY_0_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_ING_DLY_0_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_ING_DLY_0_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000094 bits 15:0) field TOD_ING_DLY_0 of register PMC_ETIME120_REG_TOD_ING_DLY_CH0 */
    reg_value = etime_reg_TOD_ING_DLY_CH0_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_ING_DLY_CH0_BIT_TOD_ING_DLY_0_MSK)
                  >> ETIME120_REG_TOD_ING_DLY_CH0_BIT_TOD_ING_DLY_0_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_ING_DLY_CH0_BIT_TOD_ING_DLY_0_MSK, ETIME120_REG_TOD_ING_DLY_CH0_BIT_TOD_ING_DLY_0_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_ING_DLY_0_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TOD_ING_DLY_1_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_ING_DLY_1_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_ING_DLY_1_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_ING_DLY_1_set", value );

    /* (0x00000098 bits 15:0) field TOD_ING_DLY_1 of register PMC_ETIME120_REG_TOD_ING_DLY_CH1 */
    etime_reg_TOD_ING_DLY_CH1_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_TOD_ING_DLY_CH1_BIT_TOD_ING_DLY_1_MSK,
                                         ETIME120_REG_TOD_ING_DLY_CH1_BIT_TOD_ING_DLY_1_OFF,
                                         value);
}

static INLINE UINT32 etime_field_TOD_ING_DLY_1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_ING_DLY_1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000098 bits 15:0) field TOD_ING_DLY_1 of register PMC_ETIME120_REG_TOD_ING_DLY_CH1 */
    reg_value = etime_reg_TOD_ING_DLY_CH1_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TOD_ING_DLY_CH1_BIT_TOD_ING_DLY_1_MSK) >> ETIME120_REG_TOD_ING_DLY_CH1_BIT_TOD_ING_DLY_1_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_ING_DLY_1_get", value );

    return value;
}
static INLINE void etime_field_range_TOD_ING_DLY_1_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TOD_ING_DLY_1_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_ING_DLY_1_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_ING_DLY_1_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_ING_DLY_1_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000098 bits 15:0) field TOD_ING_DLY_1 of register PMC_ETIME120_REG_TOD_ING_DLY_CH1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000098 bits 15:0) field TOD_ING_DLY_1 of register PMC_ETIME120_REG_TOD_ING_DLY_CH1 */
        etime_reg_TOD_ING_DLY_CH1_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_TOD_ING_DLY_CH1_BIT_TOD_ING_DLY_1_OFF + subfield_offset),
                                             ETIME120_REG_TOD_ING_DLY_CH1_BIT_TOD_ING_DLY_1_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TOD_ING_DLY_1_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_ING_DLY_1_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_ING_DLY_1_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_ING_DLY_1_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000098 bits 15:0) field TOD_ING_DLY_1 of register PMC_ETIME120_REG_TOD_ING_DLY_CH1 */
    reg_value = etime_reg_TOD_ING_DLY_CH1_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_ING_DLY_CH1_BIT_TOD_ING_DLY_1_MSK)
                  >> ETIME120_REG_TOD_ING_DLY_CH1_BIT_TOD_ING_DLY_1_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_ING_DLY_CH1_BIT_TOD_ING_DLY_1_MSK, ETIME120_REG_TOD_ING_DLY_CH1_BIT_TOD_ING_DLY_1_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_ING_DLY_1_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TOD_ING_DLY_2_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_ING_DLY_2_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_ING_DLY_2_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_ING_DLY_2_set", value );

    /* (0x0000009c bits 15:0) field TOD_ING_DLY_2 of register PMC_ETIME120_REG_TOD_ING_DLY_CH2 */
    etime_reg_TOD_ING_DLY_CH2_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_TOD_ING_DLY_CH2_BIT_TOD_ING_DLY_2_MSK,
                                         ETIME120_REG_TOD_ING_DLY_CH2_BIT_TOD_ING_DLY_2_OFF,
                                         value);
}

static INLINE UINT32 etime_field_TOD_ING_DLY_2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_ING_DLY_2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000009c bits 15:0) field TOD_ING_DLY_2 of register PMC_ETIME120_REG_TOD_ING_DLY_CH2 */
    reg_value = etime_reg_TOD_ING_DLY_CH2_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TOD_ING_DLY_CH2_BIT_TOD_ING_DLY_2_MSK) >> ETIME120_REG_TOD_ING_DLY_CH2_BIT_TOD_ING_DLY_2_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_ING_DLY_2_get", value );

    return value;
}
static INLINE void etime_field_range_TOD_ING_DLY_2_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TOD_ING_DLY_2_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_ING_DLY_2_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_ING_DLY_2_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_ING_DLY_2_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000009c bits 15:0) field TOD_ING_DLY_2 of register PMC_ETIME120_REG_TOD_ING_DLY_CH2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000009c bits 15:0) field TOD_ING_DLY_2 of register PMC_ETIME120_REG_TOD_ING_DLY_CH2 */
        etime_reg_TOD_ING_DLY_CH2_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_TOD_ING_DLY_CH2_BIT_TOD_ING_DLY_2_OFF + subfield_offset),
                                             ETIME120_REG_TOD_ING_DLY_CH2_BIT_TOD_ING_DLY_2_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TOD_ING_DLY_2_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_ING_DLY_2_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_ING_DLY_2_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_ING_DLY_2_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000009c bits 15:0) field TOD_ING_DLY_2 of register PMC_ETIME120_REG_TOD_ING_DLY_CH2 */
    reg_value = etime_reg_TOD_ING_DLY_CH2_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_ING_DLY_CH2_BIT_TOD_ING_DLY_2_MSK)
                  >> ETIME120_REG_TOD_ING_DLY_CH2_BIT_TOD_ING_DLY_2_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_ING_DLY_CH2_BIT_TOD_ING_DLY_2_MSK, ETIME120_REG_TOD_ING_DLY_CH2_BIT_TOD_ING_DLY_2_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_ING_DLY_2_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TOD_ING_DLY_3_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_ING_DLY_3_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_ING_DLY_3_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_ING_DLY_3_set", value );

    /* (0x000000a0 bits 15:0) field TOD_ING_DLY_3 of register PMC_ETIME120_REG_TOD_ING_DLY_CH3 */
    etime_reg_TOD_ING_DLY_CH3_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_TOD_ING_DLY_CH3_BIT_TOD_ING_DLY_3_MSK,
                                         ETIME120_REG_TOD_ING_DLY_CH3_BIT_TOD_ING_DLY_3_OFF,
                                         value);
}

static INLINE UINT32 etime_field_TOD_ING_DLY_3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_ING_DLY_3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000000a0 bits 15:0) field TOD_ING_DLY_3 of register PMC_ETIME120_REG_TOD_ING_DLY_CH3 */
    reg_value = etime_reg_TOD_ING_DLY_CH3_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TOD_ING_DLY_CH3_BIT_TOD_ING_DLY_3_MSK) >> ETIME120_REG_TOD_ING_DLY_CH3_BIT_TOD_ING_DLY_3_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_ING_DLY_3_get", value );

    return value;
}
static INLINE void etime_field_range_TOD_ING_DLY_3_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TOD_ING_DLY_3_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_ING_DLY_3_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_ING_DLY_3_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_ING_DLY_3_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000000a0 bits 15:0) field TOD_ING_DLY_3 of register PMC_ETIME120_REG_TOD_ING_DLY_CH3 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000000a0 bits 15:0) field TOD_ING_DLY_3 of register PMC_ETIME120_REG_TOD_ING_DLY_CH3 */
        etime_reg_TOD_ING_DLY_CH3_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_TOD_ING_DLY_CH3_BIT_TOD_ING_DLY_3_OFF + subfield_offset),
                                             ETIME120_REG_TOD_ING_DLY_CH3_BIT_TOD_ING_DLY_3_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TOD_ING_DLY_3_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_ING_DLY_3_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_ING_DLY_3_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_ING_DLY_3_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000000a0 bits 15:0) field TOD_ING_DLY_3 of register PMC_ETIME120_REG_TOD_ING_DLY_CH3 */
    reg_value = etime_reg_TOD_ING_DLY_CH3_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_ING_DLY_CH3_BIT_TOD_ING_DLY_3_MSK)
                  >> ETIME120_REG_TOD_ING_DLY_CH3_BIT_TOD_ING_DLY_3_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_ING_DLY_CH3_BIT_TOD_ING_DLY_3_MSK, ETIME120_REG_TOD_ING_DLY_CH3_BIT_TOD_ING_DLY_3_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_ING_DLY_3_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TOD_ING_DLY_4_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_ING_DLY_4_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_ING_DLY_4_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_ING_DLY_4_set", value );

    /* (0x000000a4 bits 15:0) field TOD_ING_DLY_4 of register PMC_ETIME120_REG_TOD_ING_DLY_CH4 */
    etime_reg_TOD_ING_DLY_CH4_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_TOD_ING_DLY_CH4_BIT_TOD_ING_DLY_4_MSK,
                                         ETIME120_REG_TOD_ING_DLY_CH4_BIT_TOD_ING_DLY_4_OFF,
                                         value);
}

static INLINE UINT32 etime_field_TOD_ING_DLY_4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_ING_DLY_4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000000a4 bits 15:0) field TOD_ING_DLY_4 of register PMC_ETIME120_REG_TOD_ING_DLY_CH4 */
    reg_value = etime_reg_TOD_ING_DLY_CH4_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TOD_ING_DLY_CH4_BIT_TOD_ING_DLY_4_MSK) >> ETIME120_REG_TOD_ING_DLY_CH4_BIT_TOD_ING_DLY_4_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_ING_DLY_4_get", value );

    return value;
}
static INLINE void etime_field_range_TOD_ING_DLY_4_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TOD_ING_DLY_4_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_ING_DLY_4_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_ING_DLY_4_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_ING_DLY_4_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000000a4 bits 15:0) field TOD_ING_DLY_4 of register PMC_ETIME120_REG_TOD_ING_DLY_CH4 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000000a4 bits 15:0) field TOD_ING_DLY_4 of register PMC_ETIME120_REG_TOD_ING_DLY_CH4 */
        etime_reg_TOD_ING_DLY_CH4_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_TOD_ING_DLY_CH4_BIT_TOD_ING_DLY_4_OFF + subfield_offset),
                                             ETIME120_REG_TOD_ING_DLY_CH4_BIT_TOD_ING_DLY_4_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TOD_ING_DLY_4_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_ING_DLY_4_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_ING_DLY_4_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_ING_DLY_4_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000000a4 bits 15:0) field TOD_ING_DLY_4 of register PMC_ETIME120_REG_TOD_ING_DLY_CH4 */
    reg_value = etime_reg_TOD_ING_DLY_CH4_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_ING_DLY_CH4_BIT_TOD_ING_DLY_4_MSK)
                  >> ETIME120_REG_TOD_ING_DLY_CH4_BIT_TOD_ING_DLY_4_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_ING_DLY_CH4_BIT_TOD_ING_DLY_4_MSK, ETIME120_REG_TOD_ING_DLY_CH4_BIT_TOD_ING_DLY_4_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_ING_DLY_4_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TOD_ING_DLY_5_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_ING_DLY_5_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_ING_DLY_5_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_ING_DLY_5_set", value );

    /* (0x000000a8 bits 15:0) field TOD_ING_DLY_5 of register PMC_ETIME120_REG_TOD_ING_DLY_CH5 */
    etime_reg_TOD_ING_DLY_CH5_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_TOD_ING_DLY_CH5_BIT_TOD_ING_DLY_5_MSK,
                                         ETIME120_REG_TOD_ING_DLY_CH5_BIT_TOD_ING_DLY_5_OFF,
                                         value);
}

static INLINE UINT32 etime_field_TOD_ING_DLY_5_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_ING_DLY_5_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000000a8 bits 15:0) field TOD_ING_DLY_5 of register PMC_ETIME120_REG_TOD_ING_DLY_CH5 */
    reg_value = etime_reg_TOD_ING_DLY_CH5_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TOD_ING_DLY_CH5_BIT_TOD_ING_DLY_5_MSK) >> ETIME120_REG_TOD_ING_DLY_CH5_BIT_TOD_ING_DLY_5_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_ING_DLY_5_get", value );

    return value;
}
static INLINE void etime_field_range_TOD_ING_DLY_5_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TOD_ING_DLY_5_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_ING_DLY_5_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_ING_DLY_5_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_ING_DLY_5_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000000a8 bits 15:0) field TOD_ING_DLY_5 of register PMC_ETIME120_REG_TOD_ING_DLY_CH5 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000000a8 bits 15:0) field TOD_ING_DLY_5 of register PMC_ETIME120_REG_TOD_ING_DLY_CH5 */
        etime_reg_TOD_ING_DLY_CH5_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_TOD_ING_DLY_CH5_BIT_TOD_ING_DLY_5_OFF + subfield_offset),
                                             ETIME120_REG_TOD_ING_DLY_CH5_BIT_TOD_ING_DLY_5_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TOD_ING_DLY_5_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_ING_DLY_5_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_ING_DLY_5_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_ING_DLY_5_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000000a8 bits 15:0) field TOD_ING_DLY_5 of register PMC_ETIME120_REG_TOD_ING_DLY_CH5 */
    reg_value = etime_reg_TOD_ING_DLY_CH5_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_ING_DLY_CH5_BIT_TOD_ING_DLY_5_MSK)
                  >> ETIME120_REG_TOD_ING_DLY_CH5_BIT_TOD_ING_DLY_5_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_ING_DLY_CH5_BIT_TOD_ING_DLY_5_MSK, ETIME120_REG_TOD_ING_DLY_CH5_BIT_TOD_ING_DLY_5_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_ING_DLY_5_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TOD_ING_DLY_6_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_ING_DLY_6_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_ING_DLY_6_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_ING_DLY_6_set", value );

    /* (0x000000ac bits 15:0) field TOD_ING_DLY_6 of register PMC_ETIME120_REG_TOD_ING_DLY_CH6 */
    etime_reg_TOD_ING_DLY_CH6_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_TOD_ING_DLY_CH6_BIT_TOD_ING_DLY_6_MSK,
                                         ETIME120_REG_TOD_ING_DLY_CH6_BIT_TOD_ING_DLY_6_OFF,
                                         value);
}

static INLINE UINT32 etime_field_TOD_ING_DLY_6_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_ING_DLY_6_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000000ac bits 15:0) field TOD_ING_DLY_6 of register PMC_ETIME120_REG_TOD_ING_DLY_CH6 */
    reg_value = etime_reg_TOD_ING_DLY_CH6_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TOD_ING_DLY_CH6_BIT_TOD_ING_DLY_6_MSK) >> ETIME120_REG_TOD_ING_DLY_CH6_BIT_TOD_ING_DLY_6_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_ING_DLY_6_get", value );

    return value;
}
static INLINE void etime_field_range_TOD_ING_DLY_6_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TOD_ING_DLY_6_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_ING_DLY_6_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_ING_DLY_6_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_ING_DLY_6_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000000ac bits 15:0) field TOD_ING_DLY_6 of register PMC_ETIME120_REG_TOD_ING_DLY_CH6 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000000ac bits 15:0) field TOD_ING_DLY_6 of register PMC_ETIME120_REG_TOD_ING_DLY_CH6 */
        etime_reg_TOD_ING_DLY_CH6_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_TOD_ING_DLY_CH6_BIT_TOD_ING_DLY_6_OFF + subfield_offset),
                                             ETIME120_REG_TOD_ING_DLY_CH6_BIT_TOD_ING_DLY_6_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TOD_ING_DLY_6_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_ING_DLY_6_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_ING_DLY_6_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_ING_DLY_6_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000000ac bits 15:0) field TOD_ING_DLY_6 of register PMC_ETIME120_REG_TOD_ING_DLY_CH6 */
    reg_value = etime_reg_TOD_ING_DLY_CH6_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_ING_DLY_CH6_BIT_TOD_ING_DLY_6_MSK)
                  >> ETIME120_REG_TOD_ING_DLY_CH6_BIT_TOD_ING_DLY_6_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_ING_DLY_CH6_BIT_TOD_ING_DLY_6_MSK, ETIME120_REG_TOD_ING_DLY_CH6_BIT_TOD_ING_DLY_6_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_ING_DLY_6_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TOD_ING_DLY_7_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_ING_DLY_7_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_ING_DLY_7_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_ING_DLY_7_set", value );

    /* (0x000000b0 bits 15:0) field TOD_ING_DLY_7 of register PMC_ETIME120_REG_TOD_ING_DLY_CH7 */
    etime_reg_TOD_ING_DLY_CH7_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_TOD_ING_DLY_CH7_BIT_TOD_ING_DLY_7_MSK,
                                         ETIME120_REG_TOD_ING_DLY_CH7_BIT_TOD_ING_DLY_7_OFF,
                                         value);
}

static INLINE UINT32 etime_field_TOD_ING_DLY_7_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_ING_DLY_7_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000000b0 bits 15:0) field TOD_ING_DLY_7 of register PMC_ETIME120_REG_TOD_ING_DLY_CH7 */
    reg_value = etime_reg_TOD_ING_DLY_CH7_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TOD_ING_DLY_CH7_BIT_TOD_ING_DLY_7_MSK) >> ETIME120_REG_TOD_ING_DLY_CH7_BIT_TOD_ING_DLY_7_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_ING_DLY_7_get", value );

    return value;
}
static INLINE void etime_field_range_TOD_ING_DLY_7_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TOD_ING_DLY_7_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_ING_DLY_7_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_ING_DLY_7_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_ING_DLY_7_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000000b0 bits 15:0) field TOD_ING_DLY_7 of register PMC_ETIME120_REG_TOD_ING_DLY_CH7 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000000b0 bits 15:0) field TOD_ING_DLY_7 of register PMC_ETIME120_REG_TOD_ING_DLY_CH7 */
        etime_reg_TOD_ING_DLY_CH7_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_TOD_ING_DLY_CH7_BIT_TOD_ING_DLY_7_OFF + subfield_offset),
                                             ETIME120_REG_TOD_ING_DLY_CH7_BIT_TOD_ING_DLY_7_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TOD_ING_DLY_7_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_ING_DLY_7_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_ING_DLY_7_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_ING_DLY_7_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000000b0 bits 15:0) field TOD_ING_DLY_7 of register PMC_ETIME120_REG_TOD_ING_DLY_CH7 */
    reg_value = etime_reg_TOD_ING_DLY_CH7_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_ING_DLY_CH7_BIT_TOD_ING_DLY_7_MSK)
                  >> ETIME120_REG_TOD_ING_DLY_CH7_BIT_TOD_ING_DLY_7_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_ING_DLY_CH7_BIT_TOD_ING_DLY_7_MSK, ETIME120_REG_TOD_ING_DLY_CH7_BIT_TOD_ING_DLY_7_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_ING_DLY_7_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TOD_ING_DLY_8_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_ING_DLY_8_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_ING_DLY_8_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_ING_DLY_8_set", value );

    /* (0x000000b4 bits 15:0) field TOD_ING_DLY_8 of register PMC_ETIME120_REG_TOD_ING_DLY_CH8 */
    etime_reg_TOD_ING_DLY_CH8_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_TOD_ING_DLY_CH8_BIT_TOD_ING_DLY_8_MSK,
                                         ETIME120_REG_TOD_ING_DLY_CH8_BIT_TOD_ING_DLY_8_OFF,
                                         value);
}

static INLINE UINT32 etime_field_TOD_ING_DLY_8_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_ING_DLY_8_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000000b4 bits 15:0) field TOD_ING_DLY_8 of register PMC_ETIME120_REG_TOD_ING_DLY_CH8 */
    reg_value = etime_reg_TOD_ING_DLY_CH8_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TOD_ING_DLY_CH8_BIT_TOD_ING_DLY_8_MSK) >> ETIME120_REG_TOD_ING_DLY_CH8_BIT_TOD_ING_DLY_8_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_ING_DLY_8_get", value );

    return value;
}
static INLINE void etime_field_range_TOD_ING_DLY_8_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TOD_ING_DLY_8_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_ING_DLY_8_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_ING_DLY_8_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_ING_DLY_8_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000000b4 bits 15:0) field TOD_ING_DLY_8 of register PMC_ETIME120_REG_TOD_ING_DLY_CH8 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000000b4 bits 15:0) field TOD_ING_DLY_8 of register PMC_ETIME120_REG_TOD_ING_DLY_CH8 */
        etime_reg_TOD_ING_DLY_CH8_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_TOD_ING_DLY_CH8_BIT_TOD_ING_DLY_8_OFF + subfield_offset),
                                             ETIME120_REG_TOD_ING_DLY_CH8_BIT_TOD_ING_DLY_8_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TOD_ING_DLY_8_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_ING_DLY_8_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_ING_DLY_8_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_ING_DLY_8_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000000b4 bits 15:0) field TOD_ING_DLY_8 of register PMC_ETIME120_REG_TOD_ING_DLY_CH8 */
    reg_value = etime_reg_TOD_ING_DLY_CH8_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_ING_DLY_CH8_BIT_TOD_ING_DLY_8_MSK)
                  >> ETIME120_REG_TOD_ING_DLY_CH8_BIT_TOD_ING_DLY_8_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_ING_DLY_CH8_BIT_TOD_ING_DLY_8_MSK, ETIME120_REG_TOD_ING_DLY_CH8_BIT_TOD_ING_DLY_8_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_ING_DLY_8_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TOD_ING_DLY_9_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_ING_DLY_9_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_ING_DLY_9_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_ING_DLY_9_set", value );

    /* (0x000000b8 bits 15:0) field TOD_ING_DLY_9 of register PMC_ETIME120_REG_TOD_ING_DLY_CH9 */
    etime_reg_TOD_ING_DLY_CH9_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_TOD_ING_DLY_CH9_BIT_TOD_ING_DLY_9_MSK,
                                         ETIME120_REG_TOD_ING_DLY_CH9_BIT_TOD_ING_DLY_9_OFF,
                                         value);
}

static INLINE UINT32 etime_field_TOD_ING_DLY_9_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_ING_DLY_9_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000000b8 bits 15:0) field TOD_ING_DLY_9 of register PMC_ETIME120_REG_TOD_ING_DLY_CH9 */
    reg_value = etime_reg_TOD_ING_DLY_CH9_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TOD_ING_DLY_CH9_BIT_TOD_ING_DLY_9_MSK) >> ETIME120_REG_TOD_ING_DLY_CH9_BIT_TOD_ING_DLY_9_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_ING_DLY_9_get", value );

    return value;
}
static INLINE void etime_field_range_TOD_ING_DLY_9_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TOD_ING_DLY_9_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_ING_DLY_9_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_ING_DLY_9_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_ING_DLY_9_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000000b8 bits 15:0) field TOD_ING_DLY_9 of register PMC_ETIME120_REG_TOD_ING_DLY_CH9 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000000b8 bits 15:0) field TOD_ING_DLY_9 of register PMC_ETIME120_REG_TOD_ING_DLY_CH9 */
        etime_reg_TOD_ING_DLY_CH9_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_TOD_ING_DLY_CH9_BIT_TOD_ING_DLY_9_OFF + subfield_offset),
                                             ETIME120_REG_TOD_ING_DLY_CH9_BIT_TOD_ING_DLY_9_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TOD_ING_DLY_9_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_ING_DLY_9_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_ING_DLY_9_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_ING_DLY_9_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000000b8 bits 15:0) field TOD_ING_DLY_9 of register PMC_ETIME120_REG_TOD_ING_DLY_CH9 */
    reg_value = etime_reg_TOD_ING_DLY_CH9_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_ING_DLY_CH9_BIT_TOD_ING_DLY_9_MSK)
                  >> ETIME120_REG_TOD_ING_DLY_CH9_BIT_TOD_ING_DLY_9_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_ING_DLY_CH9_BIT_TOD_ING_DLY_9_MSK, ETIME120_REG_TOD_ING_DLY_CH9_BIT_TOD_ING_DLY_9_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_ING_DLY_9_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TOD_ING_DLY_10_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_ING_DLY_10_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_ING_DLY_10_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_ING_DLY_10_set", value );

    /* (0x000000bc bits 15:0) field TOD_ING_DLY_10 of register PMC_ETIME120_REG_TOD_ING_DLY_CH10 */
    etime_reg_TOD_ING_DLY_CH10_field_set( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_TOD_ING_DLY_CH10_BIT_TOD_ING_DLY_10_MSK,
                                          ETIME120_REG_TOD_ING_DLY_CH10_BIT_TOD_ING_DLY_10_OFF,
                                          value);
}

static INLINE UINT32 etime_field_TOD_ING_DLY_10_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_ING_DLY_10_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000000bc bits 15:0) field TOD_ING_DLY_10 of register PMC_ETIME120_REG_TOD_ING_DLY_CH10 */
    reg_value = etime_reg_TOD_ING_DLY_CH10_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TOD_ING_DLY_CH10_BIT_TOD_ING_DLY_10_MSK) >> ETIME120_REG_TOD_ING_DLY_CH10_BIT_TOD_ING_DLY_10_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_ING_DLY_10_get", value );

    return value;
}
static INLINE void etime_field_range_TOD_ING_DLY_10_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TOD_ING_DLY_10_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_ING_DLY_10_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_ING_DLY_10_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_ING_DLY_10_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000000bc bits 15:0) field TOD_ING_DLY_10 of register PMC_ETIME120_REG_TOD_ING_DLY_CH10 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000000bc bits 15:0) field TOD_ING_DLY_10 of register PMC_ETIME120_REG_TOD_ING_DLY_CH10 */
        etime_reg_TOD_ING_DLY_CH10_field_set( b_ptr,
                                              h_ptr,
                                              subfield_mask << (ETIME120_REG_TOD_ING_DLY_CH10_BIT_TOD_ING_DLY_10_OFF + subfield_offset),
                                              ETIME120_REG_TOD_ING_DLY_CH10_BIT_TOD_ING_DLY_10_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TOD_ING_DLY_10_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_ING_DLY_10_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_ING_DLY_10_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_ING_DLY_10_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000000bc bits 15:0) field TOD_ING_DLY_10 of register PMC_ETIME120_REG_TOD_ING_DLY_CH10 */
    reg_value = etime_reg_TOD_ING_DLY_CH10_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_ING_DLY_CH10_BIT_TOD_ING_DLY_10_MSK)
                  >> ETIME120_REG_TOD_ING_DLY_CH10_BIT_TOD_ING_DLY_10_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_ING_DLY_CH10_BIT_TOD_ING_DLY_10_MSK, ETIME120_REG_TOD_ING_DLY_CH10_BIT_TOD_ING_DLY_10_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_ING_DLY_10_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TOD_ING_DLY_11_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_ING_DLY_11_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_ING_DLY_11_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_ING_DLY_11_set", value );

    /* (0x000000c0 bits 15:0) field TOD_ING_DLY_11 of register PMC_ETIME120_REG_TOD_ING_DLY_CH11 */
    etime_reg_TOD_ING_DLY_CH11_field_set( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_TOD_ING_DLY_CH11_BIT_TOD_ING_DLY_11_MSK,
                                          ETIME120_REG_TOD_ING_DLY_CH11_BIT_TOD_ING_DLY_11_OFF,
                                          value);
}

static INLINE UINT32 etime_field_TOD_ING_DLY_11_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_ING_DLY_11_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000000c0 bits 15:0) field TOD_ING_DLY_11 of register PMC_ETIME120_REG_TOD_ING_DLY_CH11 */
    reg_value = etime_reg_TOD_ING_DLY_CH11_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TOD_ING_DLY_CH11_BIT_TOD_ING_DLY_11_MSK) >> ETIME120_REG_TOD_ING_DLY_CH11_BIT_TOD_ING_DLY_11_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_ING_DLY_11_get", value );

    return value;
}
static INLINE void etime_field_range_TOD_ING_DLY_11_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TOD_ING_DLY_11_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_ING_DLY_11_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_ING_DLY_11_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_ING_DLY_11_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000000c0 bits 15:0) field TOD_ING_DLY_11 of register PMC_ETIME120_REG_TOD_ING_DLY_CH11 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000000c0 bits 15:0) field TOD_ING_DLY_11 of register PMC_ETIME120_REG_TOD_ING_DLY_CH11 */
        etime_reg_TOD_ING_DLY_CH11_field_set( b_ptr,
                                              h_ptr,
                                              subfield_mask << (ETIME120_REG_TOD_ING_DLY_CH11_BIT_TOD_ING_DLY_11_OFF + subfield_offset),
                                              ETIME120_REG_TOD_ING_DLY_CH11_BIT_TOD_ING_DLY_11_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TOD_ING_DLY_11_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_ING_DLY_11_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_ING_DLY_11_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_ING_DLY_11_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000000c0 bits 15:0) field TOD_ING_DLY_11 of register PMC_ETIME120_REG_TOD_ING_DLY_CH11 */
    reg_value = etime_reg_TOD_ING_DLY_CH11_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_ING_DLY_CH11_BIT_TOD_ING_DLY_11_MSK)
                  >> ETIME120_REG_TOD_ING_DLY_CH11_BIT_TOD_ING_DLY_11_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_ING_DLY_CH11_BIT_TOD_ING_DLY_11_MSK, ETIME120_REG_TOD_ING_DLY_CH11_BIT_TOD_ING_DLY_11_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_ING_DLY_11_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CFC_ING_DLY_0_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CFC_ING_DLY_0_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CFC_ING_DLY_0_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_CFC_ING_DLY_0_set", value );

    /* (0x000000c4 bits 15:0) field CFC_ING_DLY_0 of register PMC_ETIME120_REG_CFC_ING_DLY_CH0 */
    etime_reg_CFC_ING_DLY_CH0_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_CFC_ING_DLY_CH0_BIT_CFC_ING_DLY_0_MSK,
                                         ETIME120_REG_CFC_ING_DLY_CH0_BIT_CFC_ING_DLY_0_OFF,
                                         value);
}

static INLINE UINT32 etime_field_CFC_ING_DLY_0_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_ING_DLY_0_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000000c4 bits 15:0) field CFC_ING_DLY_0 of register PMC_ETIME120_REG_CFC_ING_DLY_CH0 */
    reg_value = etime_reg_CFC_ING_DLY_CH0_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CFC_ING_DLY_CH0_BIT_CFC_ING_DLY_0_MSK) >> ETIME120_REG_CFC_ING_DLY_CH0_BIT_CFC_ING_DLY_0_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_ING_DLY_0_get", value );

    return value;
}
static INLINE void etime_field_range_CFC_ING_DLY_0_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CFC_ING_DLY_0_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_ING_DLY_0_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_ING_DLY_0_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_ING_DLY_0_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000000c4 bits 15:0) field CFC_ING_DLY_0 of register PMC_ETIME120_REG_CFC_ING_DLY_CH0 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000000c4 bits 15:0) field CFC_ING_DLY_0 of register PMC_ETIME120_REG_CFC_ING_DLY_CH0 */
        etime_reg_CFC_ING_DLY_CH0_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_CFC_ING_DLY_CH0_BIT_CFC_ING_DLY_0_OFF + subfield_offset),
                                             ETIME120_REG_CFC_ING_DLY_CH0_BIT_CFC_ING_DLY_0_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CFC_ING_DLY_0_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_ING_DLY_0_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_ING_DLY_0_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_ING_DLY_0_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000000c4 bits 15:0) field CFC_ING_DLY_0 of register PMC_ETIME120_REG_CFC_ING_DLY_CH0 */
    reg_value = etime_reg_CFC_ING_DLY_CH0_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_ING_DLY_CH0_BIT_CFC_ING_DLY_0_MSK)
                  >> ETIME120_REG_CFC_ING_DLY_CH0_BIT_CFC_ING_DLY_0_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_ING_DLY_CH0_BIT_CFC_ING_DLY_0_MSK, ETIME120_REG_CFC_ING_DLY_CH0_BIT_CFC_ING_DLY_0_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_ING_DLY_0_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CFC_ING_DLY_1_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CFC_ING_DLY_1_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CFC_ING_DLY_1_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_CFC_ING_DLY_1_set", value );

    /* (0x000000c8 bits 15:0) field CFC_ING_DLY_1 of register PMC_ETIME120_REG_CFC_ING_DLY_CH1 */
    etime_reg_CFC_ING_DLY_CH1_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_CFC_ING_DLY_CH1_BIT_CFC_ING_DLY_1_MSK,
                                         ETIME120_REG_CFC_ING_DLY_CH1_BIT_CFC_ING_DLY_1_OFF,
                                         value);
}

static INLINE UINT32 etime_field_CFC_ING_DLY_1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_ING_DLY_1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000000c8 bits 15:0) field CFC_ING_DLY_1 of register PMC_ETIME120_REG_CFC_ING_DLY_CH1 */
    reg_value = etime_reg_CFC_ING_DLY_CH1_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CFC_ING_DLY_CH1_BIT_CFC_ING_DLY_1_MSK) >> ETIME120_REG_CFC_ING_DLY_CH1_BIT_CFC_ING_DLY_1_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_ING_DLY_1_get", value );

    return value;
}
static INLINE void etime_field_range_CFC_ING_DLY_1_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CFC_ING_DLY_1_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_ING_DLY_1_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_ING_DLY_1_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_ING_DLY_1_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000000c8 bits 15:0) field CFC_ING_DLY_1 of register PMC_ETIME120_REG_CFC_ING_DLY_CH1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000000c8 bits 15:0) field CFC_ING_DLY_1 of register PMC_ETIME120_REG_CFC_ING_DLY_CH1 */
        etime_reg_CFC_ING_DLY_CH1_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_CFC_ING_DLY_CH1_BIT_CFC_ING_DLY_1_OFF + subfield_offset),
                                             ETIME120_REG_CFC_ING_DLY_CH1_BIT_CFC_ING_DLY_1_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CFC_ING_DLY_1_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_ING_DLY_1_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_ING_DLY_1_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_ING_DLY_1_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000000c8 bits 15:0) field CFC_ING_DLY_1 of register PMC_ETIME120_REG_CFC_ING_DLY_CH1 */
    reg_value = etime_reg_CFC_ING_DLY_CH1_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_ING_DLY_CH1_BIT_CFC_ING_DLY_1_MSK)
                  >> ETIME120_REG_CFC_ING_DLY_CH1_BIT_CFC_ING_DLY_1_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_ING_DLY_CH1_BIT_CFC_ING_DLY_1_MSK, ETIME120_REG_CFC_ING_DLY_CH1_BIT_CFC_ING_DLY_1_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_ING_DLY_1_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CFC_ING_DLY_2_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CFC_ING_DLY_2_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CFC_ING_DLY_2_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_CFC_ING_DLY_2_set", value );

    /* (0x000000cc bits 15:0) field CFC_ING_DLY_2 of register PMC_ETIME120_REG_CFC_ING_DLY_CH2 */
    etime_reg_CFC_ING_DLY_CH2_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_CFC_ING_DLY_CH2_BIT_CFC_ING_DLY_2_MSK,
                                         ETIME120_REG_CFC_ING_DLY_CH2_BIT_CFC_ING_DLY_2_OFF,
                                         value);
}

static INLINE UINT32 etime_field_CFC_ING_DLY_2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_ING_DLY_2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000000cc bits 15:0) field CFC_ING_DLY_2 of register PMC_ETIME120_REG_CFC_ING_DLY_CH2 */
    reg_value = etime_reg_CFC_ING_DLY_CH2_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CFC_ING_DLY_CH2_BIT_CFC_ING_DLY_2_MSK) >> ETIME120_REG_CFC_ING_DLY_CH2_BIT_CFC_ING_DLY_2_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_ING_DLY_2_get", value );

    return value;
}
static INLINE void etime_field_range_CFC_ING_DLY_2_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CFC_ING_DLY_2_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_ING_DLY_2_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_ING_DLY_2_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_ING_DLY_2_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000000cc bits 15:0) field CFC_ING_DLY_2 of register PMC_ETIME120_REG_CFC_ING_DLY_CH2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000000cc bits 15:0) field CFC_ING_DLY_2 of register PMC_ETIME120_REG_CFC_ING_DLY_CH2 */
        etime_reg_CFC_ING_DLY_CH2_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_CFC_ING_DLY_CH2_BIT_CFC_ING_DLY_2_OFF + subfield_offset),
                                             ETIME120_REG_CFC_ING_DLY_CH2_BIT_CFC_ING_DLY_2_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CFC_ING_DLY_2_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_ING_DLY_2_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_ING_DLY_2_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_ING_DLY_2_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000000cc bits 15:0) field CFC_ING_DLY_2 of register PMC_ETIME120_REG_CFC_ING_DLY_CH2 */
    reg_value = etime_reg_CFC_ING_DLY_CH2_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_ING_DLY_CH2_BIT_CFC_ING_DLY_2_MSK)
                  >> ETIME120_REG_CFC_ING_DLY_CH2_BIT_CFC_ING_DLY_2_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_ING_DLY_CH2_BIT_CFC_ING_DLY_2_MSK, ETIME120_REG_CFC_ING_DLY_CH2_BIT_CFC_ING_DLY_2_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_ING_DLY_2_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CFC_ING_DLY_3_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CFC_ING_DLY_3_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CFC_ING_DLY_3_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_CFC_ING_DLY_3_set", value );

    /* (0x000000d0 bits 15:0) field CFC_ING_DLY_3 of register PMC_ETIME120_REG_CFC_ING_DLY_CH3 */
    etime_reg_CFC_ING_DLY_CH3_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_CFC_ING_DLY_CH3_BIT_CFC_ING_DLY_3_MSK,
                                         ETIME120_REG_CFC_ING_DLY_CH3_BIT_CFC_ING_DLY_3_OFF,
                                         value);
}

static INLINE UINT32 etime_field_CFC_ING_DLY_3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_ING_DLY_3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000000d0 bits 15:0) field CFC_ING_DLY_3 of register PMC_ETIME120_REG_CFC_ING_DLY_CH3 */
    reg_value = etime_reg_CFC_ING_DLY_CH3_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CFC_ING_DLY_CH3_BIT_CFC_ING_DLY_3_MSK) >> ETIME120_REG_CFC_ING_DLY_CH3_BIT_CFC_ING_DLY_3_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_ING_DLY_3_get", value );

    return value;
}
static INLINE void etime_field_range_CFC_ING_DLY_3_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CFC_ING_DLY_3_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_ING_DLY_3_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_ING_DLY_3_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_ING_DLY_3_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000000d0 bits 15:0) field CFC_ING_DLY_3 of register PMC_ETIME120_REG_CFC_ING_DLY_CH3 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000000d0 bits 15:0) field CFC_ING_DLY_3 of register PMC_ETIME120_REG_CFC_ING_DLY_CH3 */
        etime_reg_CFC_ING_DLY_CH3_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_CFC_ING_DLY_CH3_BIT_CFC_ING_DLY_3_OFF + subfield_offset),
                                             ETIME120_REG_CFC_ING_DLY_CH3_BIT_CFC_ING_DLY_3_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CFC_ING_DLY_3_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_ING_DLY_3_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_ING_DLY_3_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_ING_DLY_3_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000000d0 bits 15:0) field CFC_ING_DLY_3 of register PMC_ETIME120_REG_CFC_ING_DLY_CH3 */
    reg_value = etime_reg_CFC_ING_DLY_CH3_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_ING_DLY_CH3_BIT_CFC_ING_DLY_3_MSK)
                  >> ETIME120_REG_CFC_ING_DLY_CH3_BIT_CFC_ING_DLY_3_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_ING_DLY_CH3_BIT_CFC_ING_DLY_3_MSK, ETIME120_REG_CFC_ING_DLY_CH3_BIT_CFC_ING_DLY_3_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_ING_DLY_3_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CFC_ING_DLY_4_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CFC_ING_DLY_4_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CFC_ING_DLY_4_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_CFC_ING_DLY_4_set", value );

    /* (0x000000d4 bits 15:0) field CFC_ING_DLY_4 of register PMC_ETIME120_REG_CFC_ING_DLY_CH4 */
    etime_reg_CFC_ING_DLY_CH4_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_CFC_ING_DLY_CH4_BIT_CFC_ING_DLY_4_MSK,
                                         ETIME120_REG_CFC_ING_DLY_CH4_BIT_CFC_ING_DLY_4_OFF,
                                         value);
}

static INLINE UINT32 etime_field_CFC_ING_DLY_4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_ING_DLY_4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000000d4 bits 15:0) field CFC_ING_DLY_4 of register PMC_ETIME120_REG_CFC_ING_DLY_CH4 */
    reg_value = etime_reg_CFC_ING_DLY_CH4_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CFC_ING_DLY_CH4_BIT_CFC_ING_DLY_4_MSK) >> ETIME120_REG_CFC_ING_DLY_CH4_BIT_CFC_ING_DLY_4_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_ING_DLY_4_get", value );

    return value;
}
static INLINE void etime_field_range_CFC_ING_DLY_4_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CFC_ING_DLY_4_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_ING_DLY_4_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_ING_DLY_4_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_ING_DLY_4_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000000d4 bits 15:0) field CFC_ING_DLY_4 of register PMC_ETIME120_REG_CFC_ING_DLY_CH4 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000000d4 bits 15:0) field CFC_ING_DLY_4 of register PMC_ETIME120_REG_CFC_ING_DLY_CH4 */
        etime_reg_CFC_ING_DLY_CH4_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_CFC_ING_DLY_CH4_BIT_CFC_ING_DLY_4_OFF + subfield_offset),
                                             ETIME120_REG_CFC_ING_DLY_CH4_BIT_CFC_ING_DLY_4_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CFC_ING_DLY_4_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_ING_DLY_4_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_ING_DLY_4_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_ING_DLY_4_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000000d4 bits 15:0) field CFC_ING_DLY_4 of register PMC_ETIME120_REG_CFC_ING_DLY_CH4 */
    reg_value = etime_reg_CFC_ING_DLY_CH4_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_ING_DLY_CH4_BIT_CFC_ING_DLY_4_MSK)
                  >> ETIME120_REG_CFC_ING_DLY_CH4_BIT_CFC_ING_DLY_4_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_ING_DLY_CH4_BIT_CFC_ING_DLY_4_MSK, ETIME120_REG_CFC_ING_DLY_CH4_BIT_CFC_ING_DLY_4_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_ING_DLY_4_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CFC_ING_DLY_5_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CFC_ING_DLY_5_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CFC_ING_DLY_5_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_CFC_ING_DLY_5_set", value );

    /* (0x000000d8 bits 15:0) field CFC_ING_DLY_5 of register PMC_ETIME120_REG_CFC_ING_DLY_CH5 */
    etime_reg_CFC_ING_DLY_CH5_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_CFC_ING_DLY_CH5_BIT_CFC_ING_DLY_5_MSK,
                                         ETIME120_REG_CFC_ING_DLY_CH5_BIT_CFC_ING_DLY_5_OFF,
                                         value);
}

static INLINE UINT32 etime_field_CFC_ING_DLY_5_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_ING_DLY_5_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000000d8 bits 15:0) field CFC_ING_DLY_5 of register PMC_ETIME120_REG_CFC_ING_DLY_CH5 */
    reg_value = etime_reg_CFC_ING_DLY_CH5_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CFC_ING_DLY_CH5_BIT_CFC_ING_DLY_5_MSK) >> ETIME120_REG_CFC_ING_DLY_CH5_BIT_CFC_ING_DLY_5_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_ING_DLY_5_get", value );

    return value;
}
static INLINE void etime_field_range_CFC_ING_DLY_5_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CFC_ING_DLY_5_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_ING_DLY_5_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_ING_DLY_5_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_ING_DLY_5_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000000d8 bits 15:0) field CFC_ING_DLY_5 of register PMC_ETIME120_REG_CFC_ING_DLY_CH5 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000000d8 bits 15:0) field CFC_ING_DLY_5 of register PMC_ETIME120_REG_CFC_ING_DLY_CH5 */
        etime_reg_CFC_ING_DLY_CH5_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_CFC_ING_DLY_CH5_BIT_CFC_ING_DLY_5_OFF + subfield_offset),
                                             ETIME120_REG_CFC_ING_DLY_CH5_BIT_CFC_ING_DLY_5_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CFC_ING_DLY_5_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_ING_DLY_5_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_ING_DLY_5_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_ING_DLY_5_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000000d8 bits 15:0) field CFC_ING_DLY_5 of register PMC_ETIME120_REG_CFC_ING_DLY_CH5 */
    reg_value = etime_reg_CFC_ING_DLY_CH5_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_ING_DLY_CH5_BIT_CFC_ING_DLY_5_MSK)
                  >> ETIME120_REG_CFC_ING_DLY_CH5_BIT_CFC_ING_DLY_5_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_ING_DLY_CH5_BIT_CFC_ING_DLY_5_MSK, ETIME120_REG_CFC_ING_DLY_CH5_BIT_CFC_ING_DLY_5_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_ING_DLY_5_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CFC_ING_DLY_6_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CFC_ING_DLY_6_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CFC_ING_DLY_6_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_CFC_ING_DLY_6_set", value );

    /* (0x000000dc bits 15:0) field CFC_ING_DLY_6 of register PMC_ETIME120_REG_CFC_ING_DLY_CH6 */
    etime_reg_CFC_ING_DLY_CH6_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_CFC_ING_DLY_CH6_BIT_CFC_ING_DLY_6_MSK,
                                         ETIME120_REG_CFC_ING_DLY_CH6_BIT_CFC_ING_DLY_6_OFF,
                                         value);
}

static INLINE UINT32 etime_field_CFC_ING_DLY_6_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_ING_DLY_6_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000000dc bits 15:0) field CFC_ING_DLY_6 of register PMC_ETIME120_REG_CFC_ING_DLY_CH6 */
    reg_value = etime_reg_CFC_ING_DLY_CH6_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CFC_ING_DLY_CH6_BIT_CFC_ING_DLY_6_MSK) >> ETIME120_REG_CFC_ING_DLY_CH6_BIT_CFC_ING_DLY_6_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_ING_DLY_6_get", value );

    return value;
}
static INLINE void etime_field_range_CFC_ING_DLY_6_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CFC_ING_DLY_6_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_ING_DLY_6_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_ING_DLY_6_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_ING_DLY_6_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000000dc bits 15:0) field CFC_ING_DLY_6 of register PMC_ETIME120_REG_CFC_ING_DLY_CH6 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000000dc bits 15:0) field CFC_ING_DLY_6 of register PMC_ETIME120_REG_CFC_ING_DLY_CH6 */
        etime_reg_CFC_ING_DLY_CH6_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_CFC_ING_DLY_CH6_BIT_CFC_ING_DLY_6_OFF + subfield_offset),
                                             ETIME120_REG_CFC_ING_DLY_CH6_BIT_CFC_ING_DLY_6_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CFC_ING_DLY_6_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_ING_DLY_6_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_ING_DLY_6_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_ING_DLY_6_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000000dc bits 15:0) field CFC_ING_DLY_6 of register PMC_ETIME120_REG_CFC_ING_DLY_CH6 */
    reg_value = etime_reg_CFC_ING_DLY_CH6_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_ING_DLY_CH6_BIT_CFC_ING_DLY_6_MSK)
                  >> ETIME120_REG_CFC_ING_DLY_CH6_BIT_CFC_ING_DLY_6_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_ING_DLY_CH6_BIT_CFC_ING_DLY_6_MSK, ETIME120_REG_CFC_ING_DLY_CH6_BIT_CFC_ING_DLY_6_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_ING_DLY_6_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CFC_ING_DLY_7_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CFC_ING_DLY_7_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CFC_ING_DLY_7_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_CFC_ING_DLY_7_set", value );

    /* (0x000000e0 bits 15:0) field CFC_ING_DLY_7 of register PMC_ETIME120_REG_CFC_ING_DLY_CH7 */
    etime_reg_CFC_ING_DLY_CH7_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_CFC_ING_DLY_CH7_BIT_CFC_ING_DLY_7_MSK,
                                         ETIME120_REG_CFC_ING_DLY_CH7_BIT_CFC_ING_DLY_7_OFF,
                                         value);
}

static INLINE UINT32 etime_field_CFC_ING_DLY_7_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_ING_DLY_7_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000000e0 bits 15:0) field CFC_ING_DLY_7 of register PMC_ETIME120_REG_CFC_ING_DLY_CH7 */
    reg_value = etime_reg_CFC_ING_DLY_CH7_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CFC_ING_DLY_CH7_BIT_CFC_ING_DLY_7_MSK) >> ETIME120_REG_CFC_ING_DLY_CH7_BIT_CFC_ING_DLY_7_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_ING_DLY_7_get", value );

    return value;
}
static INLINE void etime_field_range_CFC_ING_DLY_7_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CFC_ING_DLY_7_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_ING_DLY_7_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_ING_DLY_7_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_ING_DLY_7_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000000e0 bits 15:0) field CFC_ING_DLY_7 of register PMC_ETIME120_REG_CFC_ING_DLY_CH7 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000000e0 bits 15:0) field CFC_ING_DLY_7 of register PMC_ETIME120_REG_CFC_ING_DLY_CH7 */
        etime_reg_CFC_ING_DLY_CH7_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_CFC_ING_DLY_CH7_BIT_CFC_ING_DLY_7_OFF + subfield_offset),
                                             ETIME120_REG_CFC_ING_DLY_CH7_BIT_CFC_ING_DLY_7_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CFC_ING_DLY_7_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_ING_DLY_7_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_ING_DLY_7_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_ING_DLY_7_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000000e0 bits 15:0) field CFC_ING_DLY_7 of register PMC_ETIME120_REG_CFC_ING_DLY_CH7 */
    reg_value = etime_reg_CFC_ING_DLY_CH7_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_ING_DLY_CH7_BIT_CFC_ING_DLY_7_MSK)
                  >> ETIME120_REG_CFC_ING_DLY_CH7_BIT_CFC_ING_DLY_7_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_ING_DLY_CH7_BIT_CFC_ING_DLY_7_MSK, ETIME120_REG_CFC_ING_DLY_CH7_BIT_CFC_ING_DLY_7_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_ING_DLY_7_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CFC_ING_DLY_8_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CFC_ING_DLY_8_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CFC_ING_DLY_8_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_CFC_ING_DLY_8_set", value );

    /* (0x000000e4 bits 15:0) field CFC_ING_DLY_8 of register PMC_ETIME120_REG_CFC_ING_DLY_CH8 */
    etime_reg_CFC_ING_DLY_CH8_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_CFC_ING_DLY_CH8_BIT_CFC_ING_DLY_8_MSK,
                                         ETIME120_REG_CFC_ING_DLY_CH8_BIT_CFC_ING_DLY_8_OFF,
                                         value);
}

static INLINE UINT32 etime_field_CFC_ING_DLY_8_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_ING_DLY_8_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000000e4 bits 15:0) field CFC_ING_DLY_8 of register PMC_ETIME120_REG_CFC_ING_DLY_CH8 */
    reg_value = etime_reg_CFC_ING_DLY_CH8_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CFC_ING_DLY_CH8_BIT_CFC_ING_DLY_8_MSK) >> ETIME120_REG_CFC_ING_DLY_CH8_BIT_CFC_ING_DLY_8_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_ING_DLY_8_get", value );

    return value;
}
static INLINE void etime_field_range_CFC_ING_DLY_8_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CFC_ING_DLY_8_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_ING_DLY_8_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_ING_DLY_8_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_ING_DLY_8_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000000e4 bits 15:0) field CFC_ING_DLY_8 of register PMC_ETIME120_REG_CFC_ING_DLY_CH8 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000000e4 bits 15:0) field CFC_ING_DLY_8 of register PMC_ETIME120_REG_CFC_ING_DLY_CH8 */
        etime_reg_CFC_ING_DLY_CH8_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_CFC_ING_DLY_CH8_BIT_CFC_ING_DLY_8_OFF + subfield_offset),
                                             ETIME120_REG_CFC_ING_DLY_CH8_BIT_CFC_ING_DLY_8_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CFC_ING_DLY_8_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_ING_DLY_8_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_ING_DLY_8_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_ING_DLY_8_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000000e4 bits 15:0) field CFC_ING_DLY_8 of register PMC_ETIME120_REG_CFC_ING_DLY_CH8 */
    reg_value = etime_reg_CFC_ING_DLY_CH8_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_ING_DLY_CH8_BIT_CFC_ING_DLY_8_MSK)
                  >> ETIME120_REG_CFC_ING_DLY_CH8_BIT_CFC_ING_DLY_8_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_ING_DLY_CH8_BIT_CFC_ING_DLY_8_MSK, ETIME120_REG_CFC_ING_DLY_CH8_BIT_CFC_ING_DLY_8_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_ING_DLY_8_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CFC_ING_DLY_9_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CFC_ING_DLY_9_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CFC_ING_DLY_9_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_CFC_ING_DLY_9_set", value );

    /* (0x000000e8 bits 15:0) field CFC_ING_DLY_9 of register PMC_ETIME120_REG_CFC_ING_DLY_CH9 */
    etime_reg_CFC_ING_DLY_CH9_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_CFC_ING_DLY_CH9_BIT_CFC_ING_DLY_9_MSK,
                                         ETIME120_REG_CFC_ING_DLY_CH9_BIT_CFC_ING_DLY_9_OFF,
                                         value);
}

static INLINE UINT32 etime_field_CFC_ING_DLY_9_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_ING_DLY_9_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000000e8 bits 15:0) field CFC_ING_DLY_9 of register PMC_ETIME120_REG_CFC_ING_DLY_CH9 */
    reg_value = etime_reg_CFC_ING_DLY_CH9_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CFC_ING_DLY_CH9_BIT_CFC_ING_DLY_9_MSK) >> ETIME120_REG_CFC_ING_DLY_CH9_BIT_CFC_ING_DLY_9_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_ING_DLY_9_get", value );

    return value;
}
static INLINE void etime_field_range_CFC_ING_DLY_9_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CFC_ING_DLY_9_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_ING_DLY_9_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_ING_DLY_9_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_ING_DLY_9_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000000e8 bits 15:0) field CFC_ING_DLY_9 of register PMC_ETIME120_REG_CFC_ING_DLY_CH9 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000000e8 bits 15:0) field CFC_ING_DLY_9 of register PMC_ETIME120_REG_CFC_ING_DLY_CH9 */
        etime_reg_CFC_ING_DLY_CH9_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_CFC_ING_DLY_CH9_BIT_CFC_ING_DLY_9_OFF + subfield_offset),
                                             ETIME120_REG_CFC_ING_DLY_CH9_BIT_CFC_ING_DLY_9_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CFC_ING_DLY_9_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_ING_DLY_9_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_ING_DLY_9_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_ING_DLY_9_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000000e8 bits 15:0) field CFC_ING_DLY_9 of register PMC_ETIME120_REG_CFC_ING_DLY_CH9 */
    reg_value = etime_reg_CFC_ING_DLY_CH9_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_ING_DLY_CH9_BIT_CFC_ING_DLY_9_MSK)
                  >> ETIME120_REG_CFC_ING_DLY_CH9_BIT_CFC_ING_DLY_9_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_ING_DLY_CH9_BIT_CFC_ING_DLY_9_MSK, ETIME120_REG_CFC_ING_DLY_CH9_BIT_CFC_ING_DLY_9_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_ING_DLY_9_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CFC_ING_DLY_10_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CFC_ING_DLY_10_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CFC_ING_DLY_10_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_CFC_ING_DLY_10_set", value );

    /* (0x000000ec bits 15:0) field CFC_ING_DLY_10 of register PMC_ETIME120_REG_CFC_ING_DLY_CH10 */
    etime_reg_CFC_ING_DLY_CH10_field_set( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_CFC_ING_DLY_CH10_BIT_CFC_ING_DLY_10_MSK,
                                          ETIME120_REG_CFC_ING_DLY_CH10_BIT_CFC_ING_DLY_10_OFF,
                                          value);
}

static INLINE UINT32 etime_field_CFC_ING_DLY_10_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_ING_DLY_10_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000000ec bits 15:0) field CFC_ING_DLY_10 of register PMC_ETIME120_REG_CFC_ING_DLY_CH10 */
    reg_value = etime_reg_CFC_ING_DLY_CH10_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CFC_ING_DLY_CH10_BIT_CFC_ING_DLY_10_MSK) >> ETIME120_REG_CFC_ING_DLY_CH10_BIT_CFC_ING_DLY_10_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_ING_DLY_10_get", value );

    return value;
}
static INLINE void etime_field_range_CFC_ING_DLY_10_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CFC_ING_DLY_10_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_ING_DLY_10_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_ING_DLY_10_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_ING_DLY_10_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000000ec bits 15:0) field CFC_ING_DLY_10 of register PMC_ETIME120_REG_CFC_ING_DLY_CH10 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000000ec bits 15:0) field CFC_ING_DLY_10 of register PMC_ETIME120_REG_CFC_ING_DLY_CH10 */
        etime_reg_CFC_ING_DLY_CH10_field_set( b_ptr,
                                              h_ptr,
                                              subfield_mask << (ETIME120_REG_CFC_ING_DLY_CH10_BIT_CFC_ING_DLY_10_OFF + subfield_offset),
                                              ETIME120_REG_CFC_ING_DLY_CH10_BIT_CFC_ING_DLY_10_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CFC_ING_DLY_10_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_ING_DLY_10_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_ING_DLY_10_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_ING_DLY_10_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000000ec bits 15:0) field CFC_ING_DLY_10 of register PMC_ETIME120_REG_CFC_ING_DLY_CH10 */
    reg_value = etime_reg_CFC_ING_DLY_CH10_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_ING_DLY_CH10_BIT_CFC_ING_DLY_10_MSK)
                  >> ETIME120_REG_CFC_ING_DLY_CH10_BIT_CFC_ING_DLY_10_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_ING_DLY_CH10_BIT_CFC_ING_DLY_10_MSK, ETIME120_REG_CFC_ING_DLY_CH10_BIT_CFC_ING_DLY_10_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_ING_DLY_10_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CFC_ING_DLY_11_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CFC_ING_DLY_11_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CFC_ING_DLY_11_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_CFC_ING_DLY_11_set", value );

    /* (0x000000f0 bits 15:0) field CFC_ING_DLY_11 of register PMC_ETIME120_REG_CFC_ING_DLY_CH11 */
    etime_reg_CFC_ING_DLY_CH11_field_set( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_CFC_ING_DLY_CH11_BIT_CFC_ING_DLY_11_MSK,
                                          ETIME120_REG_CFC_ING_DLY_CH11_BIT_CFC_ING_DLY_11_OFF,
                                          value);
}

static INLINE UINT32 etime_field_CFC_ING_DLY_11_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_ING_DLY_11_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000000f0 bits 15:0) field CFC_ING_DLY_11 of register PMC_ETIME120_REG_CFC_ING_DLY_CH11 */
    reg_value = etime_reg_CFC_ING_DLY_CH11_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CFC_ING_DLY_CH11_BIT_CFC_ING_DLY_11_MSK) >> ETIME120_REG_CFC_ING_DLY_CH11_BIT_CFC_ING_DLY_11_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_ING_DLY_11_get", value );

    return value;
}
static INLINE void etime_field_range_CFC_ING_DLY_11_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CFC_ING_DLY_11_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_ING_DLY_11_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_ING_DLY_11_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_ING_DLY_11_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000000f0 bits 15:0) field CFC_ING_DLY_11 of register PMC_ETIME120_REG_CFC_ING_DLY_CH11 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000000f0 bits 15:0) field CFC_ING_DLY_11 of register PMC_ETIME120_REG_CFC_ING_DLY_CH11 */
        etime_reg_CFC_ING_DLY_CH11_field_set( b_ptr,
                                              h_ptr,
                                              subfield_mask << (ETIME120_REG_CFC_ING_DLY_CH11_BIT_CFC_ING_DLY_11_OFF + subfield_offset),
                                              ETIME120_REG_CFC_ING_DLY_CH11_BIT_CFC_ING_DLY_11_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CFC_ING_DLY_11_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_ING_DLY_11_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_ING_DLY_11_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_ING_DLY_11_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000000f0 bits 15:0) field CFC_ING_DLY_11 of register PMC_ETIME120_REG_CFC_ING_DLY_CH11 */
    reg_value = etime_reg_CFC_ING_DLY_CH11_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_ING_DLY_CH11_BIT_CFC_ING_DLY_11_MSK)
                  >> ETIME120_REG_CFC_ING_DLY_CH11_BIT_CFC_ING_DLY_11_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_ING_DLY_CH11_BIT_CFC_ING_DLY_11_MSK, ETIME120_REG_CFC_ING_DLY_CH11_BIT_CFC_ING_DLY_11_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_ING_DLY_11_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TOD_EGR_DLY_0_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_EGR_DLY_0_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_EGR_DLY_0_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_EGR_DLY_0_set", value );

    /* (0x000000f4 bits 15:0) field TOD_EGR_DLY_0 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH0 */
    etime_reg_TOD_EGR_DLY_CH0_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_TOD_EGR_DLY_CH0_BIT_TOD_EGR_DLY_0_MSK,
                                         ETIME120_REG_TOD_EGR_DLY_CH0_BIT_TOD_EGR_DLY_0_OFF,
                                         value);
}

static INLINE UINT32 etime_field_TOD_EGR_DLY_0_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_EGR_DLY_0_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000000f4 bits 15:0) field TOD_EGR_DLY_0 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH0 */
    reg_value = etime_reg_TOD_EGR_DLY_CH0_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TOD_EGR_DLY_CH0_BIT_TOD_EGR_DLY_0_MSK) >> ETIME120_REG_TOD_EGR_DLY_CH0_BIT_TOD_EGR_DLY_0_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_EGR_DLY_0_get", value );

    return value;
}
static INLINE void etime_field_range_TOD_EGR_DLY_0_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TOD_EGR_DLY_0_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_EGR_DLY_0_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_EGR_DLY_0_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_EGR_DLY_0_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000000f4 bits 15:0) field TOD_EGR_DLY_0 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH0 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000000f4 bits 15:0) field TOD_EGR_DLY_0 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH0 */
        etime_reg_TOD_EGR_DLY_CH0_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_TOD_EGR_DLY_CH0_BIT_TOD_EGR_DLY_0_OFF + subfield_offset),
                                             ETIME120_REG_TOD_EGR_DLY_CH0_BIT_TOD_EGR_DLY_0_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TOD_EGR_DLY_0_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_EGR_DLY_0_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_EGR_DLY_0_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_EGR_DLY_0_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000000f4 bits 15:0) field TOD_EGR_DLY_0 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH0 */
    reg_value = etime_reg_TOD_EGR_DLY_CH0_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_EGR_DLY_CH0_BIT_TOD_EGR_DLY_0_MSK)
                  >> ETIME120_REG_TOD_EGR_DLY_CH0_BIT_TOD_EGR_DLY_0_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_EGR_DLY_CH0_BIT_TOD_EGR_DLY_0_MSK, ETIME120_REG_TOD_EGR_DLY_CH0_BIT_TOD_EGR_DLY_0_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_EGR_DLY_0_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TOD_EGR_DLY_1_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_EGR_DLY_1_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_EGR_DLY_1_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_EGR_DLY_1_set", value );

    /* (0x000000f8 bits 15:0) field TOD_EGR_DLY_1 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH1 */
    etime_reg_TOD_EGR_DLY_CH1_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_TOD_EGR_DLY_CH1_BIT_TOD_EGR_DLY_1_MSK,
                                         ETIME120_REG_TOD_EGR_DLY_CH1_BIT_TOD_EGR_DLY_1_OFF,
                                         value);
}

static INLINE UINT32 etime_field_TOD_EGR_DLY_1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_EGR_DLY_1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000000f8 bits 15:0) field TOD_EGR_DLY_1 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH1 */
    reg_value = etime_reg_TOD_EGR_DLY_CH1_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TOD_EGR_DLY_CH1_BIT_TOD_EGR_DLY_1_MSK) >> ETIME120_REG_TOD_EGR_DLY_CH1_BIT_TOD_EGR_DLY_1_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_EGR_DLY_1_get", value );

    return value;
}
static INLINE void etime_field_range_TOD_EGR_DLY_1_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TOD_EGR_DLY_1_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_EGR_DLY_1_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_EGR_DLY_1_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_EGR_DLY_1_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000000f8 bits 15:0) field TOD_EGR_DLY_1 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000000f8 bits 15:0) field TOD_EGR_DLY_1 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH1 */
        etime_reg_TOD_EGR_DLY_CH1_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_TOD_EGR_DLY_CH1_BIT_TOD_EGR_DLY_1_OFF + subfield_offset),
                                             ETIME120_REG_TOD_EGR_DLY_CH1_BIT_TOD_EGR_DLY_1_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TOD_EGR_DLY_1_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_EGR_DLY_1_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_EGR_DLY_1_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_EGR_DLY_1_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000000f8 bits 15:0) field TOD_EGR_DLY_1 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH1 */
    reg_value = etime_reg_TOD_EGR_DLY_CH1_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_EGR_DLY_CH1_BIT_TOD_EGR_DLY_1_MSK)
                  >> ETIME120_REG_TOD_EGR_DLY_CH1_BIT_TOD_EGR_DLY_1_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_EGR_DLY_CH1_BIT_TOD_EGR_DLY_1_MSK, ETIME120_REG_TOD_EGR_DLY_CH1_BIT_TOD_EGR_DLY_1_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_EGR_DLY_1_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TOD_EGR_DLY_2_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_EGR_DLY_2_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_EGR_DLY_2_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_EGR_DLY_2_set", value );

    /* (0x000000fc bits 15:0) field TOD_EGR_DLY_2 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH2 */
    etime_reg_TOD_EGR_DLY_CH2_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_TOD_EGR_DLY_CH2_BIT_TOD_EGR_DLY_2_MSK,
                                         ETIME120_REG_TOD_EGR_DLY_CH2_BIT_TOD_EGR_DLY_2_OFF,
                                         value);
}

static INLINE UINT32 etime_field_TOD_EGR_DLY_2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_EGR_DLY_2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000000fc bits 15:0) field TOD_EGR_DLY_2 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH2 */
    reg_value = etime_reg_TOD_EGR_DLY_CH2_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TOD_EGR_DLY_CH2_BIT_TOD_EGR_DLY_2_MSK) >> ETIME120_REG_TOD_EGR_DLY_CH2_BIT_TOD_EGR_DLY_2_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_EGR_DLY_2_get", value );

    return value;
}
static INLINE void etime_field_range_TOD_EGR_DLY_2_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TOD_EGR_DLY_2_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_EGR_DLY_2_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_EGR_DLY_2_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_EGR_DLY_2_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000000fc bits 15:0) field TOD_EGR_DLY_2 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000000fc bits 15:0) field TOD_EGR_DLY_2 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH2 */
        etime_reg_TOD_EGR_DLY_CH2_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_TOD_EGR_DLY_CH2_BIT_TOD_EGR_DLY_2_OFF + subfield_offset),
                                             ETIME120_REG_TOD_EGR_DLY_CH2_BIT_TOD_EGR_DLY_2_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TOD_EGR_DLY_2_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_EGR_DLY_2_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_EGR_DLY_2_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_EGR_DLY_2_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000000fc bits 15:0) field TOD_EGR_DLY_2 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH2 */
    reg_value = etime_reg_TOD_EGR_DLY_CH2_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_EGR_DLY_CH2_BIT_TOD_EGR_DLY_2_MSK)
                  >> ETIME120_REG_TOD_EGR_DLY_CH2_BIT_TOD_EGR_DLY_2_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_EGR_DLY_CH2_BIT_TOD_EGR_DLY_2_MSK, ETIME120_REG_TOD_EGR_DLY_CH2_BIT_TOD_EGR_DLY_2_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_EGR_DLY_2_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TOD_EGR_DLY_3_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_EGR_DLY_3_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_EGR_DLY_3_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_EGR_DLY_3_set", value );

    /* (0x00000100 bits 15:0) field TOD_EGR_DLY_3 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH3 */
    etime_reg_TOD_EGR_DLY_CH3_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_TOD_EGR_DLY_CH3_BIT_TOD_EGR_DLY_3_MSK,
                                         ETIME120_REG_TOD_EGR_DLY_CH3_BIT_TOD_EGR_DLY_3_OFF,
                                         value);
}

static INLINE UINT32 etime_field_TOD_EGR_DLY_3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_EGR_DLY_3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000100 bits 15:0) field TOD_EGR_DLY_3 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH3 */
    reg_value = etime_reg_TOD_EGR_DLY_CH3_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TOD_EGR_DLY_CH3_BIT_TOD_EGR_DLY_3_MSK) >> ETIME120_REG_TOD_EGR_DLY_CH3_BIT_TOD_EGR_DLY_3_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_EGR_DLY_3_get", value );

    return value;
}
static INLINE void etime_field_range_TOD_EGR_DLY_3_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TOD_EGR_DLY_3_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_EGR_DLY_3_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_EGR_DLY_3_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_EGR_DLY_3_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000100 bits 15:0) field TOD_EGR_DLY_3 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH3 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000100 bits 15:0) field TOD_EGR_DLY_3 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH3 */
        etime_reg_TOD_EGR_DLY_CH3_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_TOD_EGR_DLY_CH3_BIT_TOD_EGR_DLY_3_OFF + subfield_offset),
                                             ETIME120_REG_TOD_EGR_DLY_CH3_BIT_TOD_EGR_DLY_3_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TOD_EGR_DLY_3_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_EGR_DLY_3_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_EGR_DLY_3_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_EGR_DLY_3_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000100 bits 15:0) field TOD_EGR_DLY_3 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH3 */
    reg_value = etime_reg_TOD_EGR_DLY_CH3_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_EGR_DLY_CH3_BIT_TOD_EGR_DLY_3_MSK)
                  >> ETIME120_REG_TOD_EGR_DLY_CH3_BIT_TOD_EGR_DLY_3_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_EGR_DLY_CH3_BIT_TOD_EGR_DLY_3_MSK, ETIME120_REG_TOD_EGR_DLY_CH3_BIT_TOD_EGR_DLY_3_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_EGR_DLY_3_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TOD_EGR_DLY_4_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_EGR_DLY_4_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_EGR_DLY_4_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_EGR_DLY_4_set", value );

    /* (0x00000104 bits 15:0) field TOD_EGR_DLY_4 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH4 */
    etime_reg_TOD_EGR_DLY_CH4_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_TOD_EGR_DLY_CH4_BIT_TOD_EGR_DLY_4_MSK,
                                         ETIME120_REG_TOD_EGR_DLY_CH4_BIT_TOD_EGR_DLY_4_OFF,
                                         value);
}

static INLINE UINT32 etime_field_TOD_EGR_DLY_4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_EGR_DLY_4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000104 bits 15:0) field TOD_EGR_DLY_4 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH4 */
    reg_value = etime_reg_TOD_EGR_DLY_CH4_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TOD_EGR_DLY_CH4_BIT_TOD_EGR_DLY_4_MSK) >> ETIME120_REG_TOD_EGR_DLY_CH4_BIT_TOD_EGR_DLY_4_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_EGR_DLY_4_get", value );

    return value;
}
static INLINE void etime_field_range_TOD_EGR_DLY_4_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TOD_EGR_DLY_4_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_EGR_DLY_4_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_EGR_DLY_4_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_EGR_DLY_4_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000104 bits 15:0) field TOD_EGR_DLY_4 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH4 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000104 bits 15:0) field TOD_EGR_DLY_4 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH4 */
        etime_reg_TOD_EGR_DLY_CH4_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_TOD_EGR_DLY_CH4_BIT_TOD_EGR_DLY_4_OFF + subfield_offset),
                                             ETIME120_REG_TOD_EGR_DLY_CH4_BIT_TOD_EGR_DLY_4_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TOD_EGR_DLY_4_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_EGR_DLY_4_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_EGR_DLY_4_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_EGR_DLY_4_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000104 bits 15:0) field TOD_EGR_DLY_4 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH4 */
    reg_value = etime_reg_TOD_EGR_DLY_CH4_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_EGR_DLY_CH4_BIT_TOD_EGR_DLY_4_MSK)
                  >> ETIME120_REG_TOD_EGR_DLY_CH4_BIT_TOD_EGR_DLY_4_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_EGR_DLY_CH4_BIT_TOD_EGR_DLY_4_MSK, ETIME120_REG_TOD_EGR_DLY_CH4_BIT_TOD_EGR_DLY_4_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_EGR_DLY_4_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TOD_EGR_DLY_5_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_EGR_DLY_5_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_EGR_DLY_5_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_EGR_DLY_5_set", value );

    /* (0x00000108 bits 15:0) field TOD_EGR_DLY_5 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH5 */
    etime_reg_TOD_EGR_DLY_CH5_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_TOD_EGR_DLY_CH5_BIT_TOD_EGR_DLY_5_MSK,
                                         ETIME120_REG_TOD_EGR_DLY_CH5_BIT_TOD_EGR_DLY_5_OFF,
                                         value);
}

static INLINE UINT32 etime_field_TOD_EGR_DLY_5_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_EGR_DLY_5_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000108 bits 15:0) field TOD_EGR_DLY_5 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH5 */
    reg_value = etime_reg_TOD_EGR_DLY_CH5_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TOD_EGR_DLY_CH5_BIT_TOD_EGR_DLY_5_MSK) >> ETIME120_REG_TOD_EGR_DLY_CH5_BIT_TOD_EGR_DLY_5_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_EGR_DLY_5_get", value );

    return value;
}
static INLINE void etime_field_range_TOD_EGR_DLY_5_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TOD_EGR_DLY_5_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_EGR_DLY_5_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_EGR_DLY_5_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_EGR_DLY_5_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000108 bits 15:0) field TOD_EGR_DLY_5 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH5 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000108 bits 15:0) field TOD_EGR_DLY_5 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH5 */
        etime_reg_TOD_EGR_DLY_CH5_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_TOD_EGR_DLY_CH5_BIT_TOD_EGR_DLY_5_OFF + subfield_offset),
                                             ETIME120_REG_TOD_EGR_DLY_CH5_BIT_TOD_EGR_DLY_5_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TOD_EGR_DLY_5_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_EGR_DLY_5_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_EGR_DLY_5_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_EGR_DLY_5_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000108 bits 15:0) field TOD_EGR_DLY_5 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH5 */
    reg_value = etime_reg_TOD_EGR_DLY_CH5_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_EGR_DLY_CH5_BIT_TOD_EGR_DLY_5_MSK)
                  >> ETIME120_REG_TOD_EGR_DLY_CH5_BIT_TOD_EGR_DLY_5_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_EGR_DLY_CH5_BIT_TOD_EGR_DLY_5_MSK, ETIME120_REG_TOD_EGR_DLY_CH5_BIT_TOD_EGR_DLY_5_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_EGR_DLY_5_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TOD_EGR_DLY_6_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_EGR_DLY_6_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_EGR_DLY_6_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_EGR_DLY_6_set", value );

    /* (0x0000010c bits 15:0) field TOD_EGR_DLY_6 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH6 */
    etime_reg_TOD_EGR_DLY_CH6_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_TOD_EGR_DLY_CH6_BIT_TOD_EGR_DLY_6_MSK,
                                         ETIME120_REG_TOD_EGR_DLY_CH6_BIT_TOD_EGR_DLY_6_OFF,
                                         value);
}

static INLINE UINT32 etime_field_TOD_EGR_DLY_6_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_EGR_DLY_6_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000010c bits 15:0) field TOD_EGR_DLY_6 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH6 */
    reg_value = etime_reg_TOD_EGR_DLY_CH6_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TOD_EGR_DLY_CH6_BIT_TOD_EGR_DLY_6_MSK) >> ETIME120_REG_TOD_EGR_DLY_CH6_BIT_TOD_EGR_DLY_6_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_EGR_DLY_6_get", value );

    return value;
}
static INLINE void etime_field_range_TOD_EGR_DLY_6_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TOD_EGR_DLY_6_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_EGR_DLY_6_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_EGR_DLY_6_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_EGR_DLY_6_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000010c bits 15:0) field TOD_EGR_DLY_6 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH6 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000010c bits 15:0) field TOD_EGR_DLY_6 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH6 */
        etime_reg_TOD_EGR_DLY_CH6_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_TOD_EGR_DLY_CH6_BIT_TOD_EGR_DLY_6_OFF + subfield_offset),
                                             ETIME120_REG_TOD_EGR_DLY_CH6_BIT_TOD_EGR_DLY_6_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TOD_EGR_DLY_6_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_EGR_DLY_6_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_EGR_DLY_6_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_EGR_DLY_6_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000010c bits 15:0) field TOD_EGR_DLY_6 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH6 */
    reg_value = etime_reg_TOD_EGR_DLY_CH6_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_EGR_DLY_CH6_BIT_TOD_EGR_DLY_6_MSK)
                  >> ETIME120_REG_TOD_EGR_DLY_CH6_BIT_TOD_EGR_DLY_6_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_EGR_DLY_CH6_BIT_TOD_EGR_DLY_6_MSK, ETIME120_REG_TOD_EGR_DLY_CH6_BIT_TOD_EGR_DLY_6_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_EGR_DLY_6_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TOD_EGR_DLY_7_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_EGR_DLY_7_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_EGR_DLY_7_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_EGR_DLY_7_set", value );

    /* (0x00000110 bits 15:0) field TOD_EGR_DLY_7 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH7 */
    etime_reg_TOD_EGR_DLY_CH7_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_TOD_EGR_DLY_CH7_BIT_TOD_EGR_DLY_7_MSK,
                                         ETIME120_REG_TOD_EGR_DLY_CH7_BIT_TOD_EGR_DLY_7_OFF,
                                         value);
}

static INLINE UINT32 etime_field_TOD_EGR_DLY_7_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_EGR_DLY_7_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000110 bits 15:0) field TOD_EGR_DLY_7 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH7 */
    reg_value = etime_reg_TOD_EGR_DLY_CH7_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TOD_EGR_DLY_CH7_BIT_TOD_EGR_DLY_7_MSK) >> ETIME120_REG_TOD_EGR_DLY_CH7_BIT_TOD_EGR_DLY_7_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_EGR_DLY_7_get", value );

    return value;
}
static INLINE void etime_field_range_TOD_EGR_DLY_7_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TOD_EGR_DLY_7_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_EGR_DLY_7_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_EGR_DLY_7_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_EGR_DLY_7_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000110 bits 15:0) field TOD_EGR_DLY_7 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH7 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000110 bits 15:0) field TOD_EGR_DLY_7 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH7 */
        etime_reg_TOD_EGR_DLY_CH7_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_TOD_EGR_DLY_CH7_BIT_TOD_EGR_DLY_7_OFF + subfield_offset),
                                             ETIME120_REG_TOD_EGR_DLY_CH7_BIT_TOD_EGR_DLY_7_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TOD_EGR_DLY_7_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_EGR_DLY_7_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_EGR_DLY_7_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_EGR_DLY_7_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000110 bits 15:0) field TOD_EGR_DLY_7 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH7 */
    reg_value = etime_reg_TOD_EGR_DLY_CH7_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_EGR_DLY_CH7_BIT_TOD_EGR_DLY_7_MSK)
                  >> ETIME120_REG_TOD_EGR_DLY_CH7_BIT_TOD_EGR_DLY_7_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_EGR_DLY_CH7_BIT_TOD_EGR_DLY_7_MSK, ETIME120_REG_TOD_EGR_DLY_CH7_BIT_TOD_EGR_DLY_7_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_EGR_DLY_7_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TOD_EGR_DLY_8_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_EGR_DLY_8_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_EGR_DLY_8_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_EGR_DLY_8_set", value );

    /* (0x00000114 bits 15:0) field TOD_EGR_DLY_8 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH8 */
    etime_reg_TOD_EGR_DLY_CH8_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_TOD_EGR_DLY_CH8_BIT_TOD_EGR_DLY_8_MSK,
                                         ETIME120_REG_TOD_EGR_DLY_CH8_BIT_TOD_EGR_DLY_8_OFF,
                                         value);
}

static INLINE UINT32 etime_field_TOD_EGR_DLY_8_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_EGR_DLY_8_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000114 bits 15:0) field TOD_EGR_DLY_8 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH8 */
    reg_value = etime_reg_TOD_EGR_DLY_CH8_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TOD_EGR_DLY_CH8_BIT_TOD_EGR_DLY_8_MSK) >> ETIME120_REG_TOD_EGR_DLY_CH8_BIT_TOD_EGR_DLY_8_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_EGR_DLY_8_get", value );

    return value;
}
static INLINE void etime_field_range_TOD_EGR_DLY_8_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TOD_EGR_DLY_8_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_EGR_DLY_8_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_EGR_DLY_8_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_EGR_DLY_8_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000114 bits 15:0) field TOD_EGR_DLY_8 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH8 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000114 bits 15:0) field TOD_EGR_DLY_8 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH8 */
        etime_reg_TOD_EGR_DLY_CH8_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_TOD_EGR_DLY_CH8_BIT_TOD_EGR_DLY_8_OFF + subfield_offset),
                                             ETIME120_REG_TOD_EGR_DLY_CH8_BIT_TOD_EGR_DLY_8_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TOD_EGR_DLY_8_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_EGR_DLY_8_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_EGR_DLY_8_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_EGR_DLY_8_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000114 bits 15:0) field TOD_EGR_DLY_8 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH8 */
    reg_value = etime_reg_TOD_EGR_DLY_CH8_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_EGR_DLY_CH8_BIT_TOD_EGR_DLY_8_MSK)
                  >> ETIME120_REG_TOD_EGR_DLY_CH8_BIT_TOD_EGR_DLY_8_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_EGR_DLY_CH8_BIT_TOD_EGR_DLY_8_MSK, ETIME120_REG_TOD_EGR_DLY_CH8_BIT_TOD_EGR_DLY_8_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_EGR_DLY_8_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TOD_EGR_DLY_9_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_EGR_DLY_9_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_EGR_DLY_9_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_EGR_DLY_9_set", value );

    /* (0x00000118 bits 15:0) field TOD_EGR_DLY_9 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH9 */
    etime_reg_TOD_EGR_DLY_CH9_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_TOD_EGR_DLY_CH9_BIT_TOD_EGR_DLY_9_MSK,
                                         ETIME120_REG_TOD_EGR_DLY_CH9_BIT_TOD_EGR_DLY_9_OFF,
                                         value);
}

static INLINE UINT32 etime_field_TOD_EGR_DLY_9_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_EGR_DLY_9_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000118 bits 15:0) field TOD_EGR_DLY_9 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH9 */
    reg_value = etime_reg_TOD_EGR_DLY_CH9_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TOD_EGR_DLY_CH9_BIT_TOD_EGR_DLY_9_MSK) >> ETIME120_REG_TOD_EGR_DLY_CH9_BIT_TOD_EGR_DLY_9_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_EGR_DLY_9_get", value );

    return value;
}
static INLINE void etime_field_range_TOD_EGR_DLY_9_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TOD_EGR_DLY_9_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_EGR_DLY_9_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_EGR_DLY_9_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_EGR_DLY_9_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000118 bits 15:0) field TOD_EGR_DLY_9 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH9 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000118 bits 15:0) field TOD_EGR_DLY_9 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH9 */
        etime_reg_TOD_EGR_DLY_CH9_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_TOD_EGR_DLY_CH9_BIT_TOD_EGR_DLY_9_OFF + subfield_offset),
                                             ETIME120_REG_TOD_EGR_DLY_CH9_BIT_TOD_EGR_DLY_9_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TOD_EGR_DLY_9_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_EGR_DLY_9_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_EGR_DLY_9_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_EGR_DLY_9_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000118 bits 15:0) field TOD_EGR_DLY_9 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH9 */
    reg_value = etime_reg_TOD_EGR_DLY_CH9_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_EGR_DLY_CH9_BIT_TOD_EGR_DLY_9_MSK)
                  >> ETIME120_REG_TOD_EGR_DLY_CH9_BIT_TOD_EGR_DLY_9_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_EGR_DLY_CH9_BIT_TOD_EGR_DLY_9_MSK, ETIME120_REG_TOD_EGR_DLY_CH9_BIT_TOD_EGR_DLY_9_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_EGR_DLY_9_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TOD_EGR_DLY_10_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_EGR_DLY_10_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_EGR_DLY_10_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_EGR_DLY_10_set", value );

    /* (0x0000011c bits 15:0) field TOD_EGR_DLY_10 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH10 */
    etime_reg_TOD_EGR_DLY_CH10_field_set( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_TOD_EGR_DLY_CH10_BIT_TOD_EGR_DLY_10_MSK,
                                          ETIME120_REG_TOD_EGR_DLY_CH10_BIT_TOD_EGR_DLY_10_OFF,
                                          value);
}

static INLINE UINT32 etime_field_TOD_EGR_DLY_10_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_EGR_DLY_10_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000011c bits 15:0) field TOD_EGR_DLY_10 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH10 */
    reg_value = etime_reg_TOD_EGR_DLY_CH10_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TOD_EGR_DLY_CH10_BIT_TOD_EGR_DLY_10_MSK) >> ETIME120_REG_TOD_EGR_DLY_CH10_BIT_TOD_EGR_DLY_10_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_EGR_DLY_10_get", value );

    return value;
}
static INLINE void etime_field_range_TOD_EGR_DLY_10_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TOD_EGR_DLY_10_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_EGR_DLY_10_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_EGR_DLY_10_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_EGR_DLY_10_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000011c bits 15:0) field TOD_EGR_DLY_10 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH10 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000011c bits 15:0) field TOD_EGR_DLY_10 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH10 */
        etime_reg_TOD_EGR_DLY_CH10_field_set( b_ptr,
                                              h_ptr,
                                              subfield_mask << (ETIME120_REG_TOD_EGR_DLY_CH10_BIT_TOD_EGR_DLY_10_OFF + subfield_offset),
                                              ETIME120_REG_TOD_EGR_DLY_CH10_BIT_TOD_EGR_DLY_10_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TOD_EGR_DLY_10_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_EGR_DLY_10_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_EGR_DLY_10_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_EGR_DLY_10_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000011c bits 15:0) field TOD_EGR_DLY_10 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH10 */
    reg_value = etime_reg_TOD_EGR_DLY_CH10_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_EGR_DLY_CH10_BIT_TOD_EGR_DLY_10_MSK)
                  >> ETIME120_REG_TOD_EGR_DLY_CH10_BIT_TOD_EGR_DLY_10_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_EGR_DLY_CH10_BIT_TOD_EGR_DLY_10_MSK, ETIME120_REG_TOD_EGR_DLY_CH10_BIT_TOD_EGR_DLY_10_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_EGR_DLY_10_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TOD_EGR_DLY_11_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_EGR_DLY_11_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_EGR_DLY_11_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_EGR_DLY_11_set", value );

    /* (0x00000120 bits 15:0) field TOD_EGR_DLY_11 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH11 */
    etime_reg_TOD_EGR_DLY_CH11_field_set( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_TOD_EGR_DLY_CH11_BIT_TOD_EGR_DLY_11_MSK,
                                          ETIME120_REG_TOD_EGR_DLY_CH11_BIT_TOD_EGR_DLY_11_OFF,
                                          value);
}

static INLINE UINT32 etime_field_TOD_EGR_DLY_11_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_EGR_DLY_11_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000120 bits 15:0) field TOD_EGR_DLY_11 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH11 */
    reg_value = etime_reg_TOD_EGR_DLY_CH11_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TOD_EGR_DLY_CH11_BIT_TOD_EGR_DLY_11_MSK) >> ETIME120_REG_TOD_EGR_DLY_CH11_BIT_TOD_EGR_DLY_11_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_EGR_DLY_11_get", value );

    return value;
}
static INLINE void etime_field_range_TOD_EGR_DLY_11_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TOD_EGR_DLY_11_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_EGR_DLY_11_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_EGR_DLY_11_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_EGR_DLY_11_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000120 bits 15:0) field TOD_EGR_DLY_11 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH11 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000120 bits 15:0) field TOD_EGR_DLY_11 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH11 */
        etime_reg_TOD_EGR_DLY_CH11_field_set( b_ptr,
                                              h_ptr,
                                              subfield_mask << (ETIME120_REG_TOD_EGR_DLY_CH11_BIT_TOD_EGR_DLY_11_OFF + subfield_offset),
                                              ETIME120_REG_TOD_EGR_DLY_CH11_BIT_TOD_EGR_DLY_11_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TOD_EGR_DLY_11_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_EGR_DLY_11_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_EGR_DLY_11_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_EGR_DLY_11_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000120 bits 15:0) field TOD_EGR_DLY_11 of register PMC_ETIME120_REG_TOD_EGR_DLY_CH11 */
    reg_value = etime_reg_TOD_EGR_DLY_CH11_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_EGR_DLY_CH11_BIT_TOD_EGR_DLY_11_MSK)
                  >> ETIME120_REG_TOD_EGR_DLY_CH11_BIT_TOD_EGR_DLY_11_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_EGR_DLY_CH11_BIT_TOD_EGR_DLY_11_MSK, ETIME120_REG_TOD_EGR_DLY_CH11_BIT_TOD_EGR_DLY_11_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_EGR_DLY_11_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CFC_EGR_DLY_0_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CFC_EGR_DLY_0_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CFC_EGR_DLY_0_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_CFC_EGR_DLY_0_set", value );

    /* (0x00000124 bits 15:0) field CFC_EGR_DLY_0 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH0 */
    etime_reg_CFC_EGR_DLY_CH0_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_CFC_EGR_DLY_CH0_BIT_CFC_EGR_DLY_0_MSK,
                                         ETIME120_REG_CFC_EGR_DLY_CH0_BIT_CFC_EGR_DLY_0_OFF,
                                         value);
}

static INLINE UINT32 etime_field_CFC_EGR_DLY_0_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_EGR_DLY_0_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000124 bits 15:0) field CFC_EGR_DLY_0 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH0 */
    reg_value = etime_reg_CFC_EGR_DLY_CH0_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CFC_EGR_DLY_CH0_BIT_CFC_EGR_DLY_0_MSK) >> ETIME120_REG_CFC_EGR_DLY_CH0_BIT_CFC_EGR_DLY_0_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_EGR_DLY_0_get", value );

    return value;
}
static INLINE void etime_field_range_CFC_EGR_DLY_0_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CFC_EGR_DLY_0_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_EGR_DLY_0_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_EGR_DLY_0_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_EGR_DLY_0_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000124 bits 15:0) field CFC_EGR_DLY_0 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH0 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000124 bits 15:0) field CFC_EGR_DLY_0 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH0 */
        etime_reg_CFC_EGR_DLY_CH0_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_CFC_EGR_DLY_CH0_BIT_CFC_EGR_DLY_0_OFF + subfield_offset),
                                             ETIME120_REG_CFC_EGR_DLY_CH0_BIT_CFC_EGR_DLY_0_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CFC_EGR_DLY_0_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_EGR_DLY_0_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_EGR_DLY_0_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_EGR_DLY_0_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000124 bits 15:0) field CFC_EGR_DLY_0 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH0 */
    reg_value = etime_reg_CFC_EGR_DLY_CH0_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_EGR_DLY_CH0_BIT_CFC_EGR_DLY_0_MSK)
                  >> ETIME120_REG_CFC_EGR_DLY_CH0_BIT_CFC_EGR_DLY_0_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_EGR_DLY_CH0_BIT_CFC_EGR_DLY_0_MSK, ETIME120_REG_CFC_EGR_DLY_CH0_BIT_CFC_EGR_DLY_0_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_EGR_DLY_0_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CFC_EGR_DLY_1_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CFC_EGR_DLY_1_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CFC_EGR_DLY_1_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_CFC_EGR_DLY_1_set", value );

    /* (0x00000128 bits 15:0) field CFC_EGR_DLY_1 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH1 */
    etime_reg_CFC_EGR_DLY_CH1_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_CFC_EGR_DLY_CH1_BIT_CFC_EGR_DLY_1_MSK,
                                         ETIME120_REG_CFC_EGR_DLY_CH1_BIT_CFC_EGR_DLY_1_OFF,
                                         value);
}

static INLINE UINT32 etime_field_CFC_EGR_DLY_1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_EGR_DLY_1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000128 bits 15:0) field CFC_EGR_DLY_1 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH1 */
    reg_value = etime_reg_CFC_EGR_DLY_CH1_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CFC_EGR_DLY_CH1_BIT_CFC_EGR_DLY_1_MSK) >> ETIME120_REG_CFC_EGR_DLY_CH1_BIT_CFC_EGR_DLY_1_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_EGR_DLY_1_get", value );

    return value;
}
static INLINE void etime_field_range_CFC_EGR_DLY_1_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CFC_EGR_DLY_1_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_EGR_DLY_1_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_EGR_DLY_1_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_EGR_DLY_1_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000128 bits 15:0) field CFC_EGR_DLY_1 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000128 bits 15:0) field CFC_EGR_DLY_1 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH1 */
        etime_reg_CFC_EGR_DLY_CH1_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_CFC_EGR_DLY_CH1_BIT_CFC_EGR_DLY_1_OFF + subfield_offset),
                                             ETIME120_REG_CFC_EGR_DLY_CH1_BIT_CFC_EGR_DLY_1_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CFC_EGR_DLY_1_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_EGR_DLY_1_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_EGR_DLY_1_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_EGR_DLY_1_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000128 bits 15:0) field CFC_EGR_DLY_1 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH1 */
    reg_value = etime_reg_CFC_EGR_DLY_CH1_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_EGR_DLY_CH1_BIT_CFC_EGR_DLY_1_MSK)
                  >> ETIME120_REG_CFC_EGR_DLY_CH1_BIT_CFC_EGR_DLY_1_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_EGR_DLY_CH1_BIT_CFC_EGR_DLY_1_MSK, ETIME120_REG_CFC_EGR_DLY_CH1_BIT_CFC_EGR_DLY_1_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_EGR_DLY_1_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CFC_EGR_DLY_2_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CFC_EGR_DLY_2_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CFC_EGR_DLY_2_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_CFC_EGR_DLY_2_set", value );

    /* (0x0000012c bits 15:0) field CFC_EGR_DLY_2 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH2 */
    etime_reg_CFC_EGR_DLY_CH2_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_CFC_EGR_DLY_CH2_BIT_CFC_EGR_DLY_2_MSK,
                                         ETIME120_REG_CFC_EGR_DLY_CH2_BIT_CFC_EGR_DLY_2_OFF,
                                         value);
}

static INLINE UINT32 etime_field_CFC_EGR_DLY_2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_EGR_DLY_2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000012c bits 15:0) field CFC_EGR_DLY_2 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH2 */
    reg_value = etime_reg_CFC_EGR_DLY_CH2_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CFC_EGR_DLY_CH2_BIT_CFC_EGR_DLY_2_MSK) >> ETIME120_REG_CFC_EGR_DLY_CH2_BIT_CFC_EGR_DLY_2_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_EGR_DLY_2_get", value );

    return value;
}
static INLINE void etime_field_range_CFC_EGR_DLY_2_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CFC_EGR_DLY_2_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_EGR_DLY_2_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_EGR_DLY_2_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_EGR_DLY_2_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000012c bits 15:0) field CFC_EGR_DLY_2 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000012c bits 15:0) field CFC_EGR_DLY_2 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH2 */
        etime_reg_CFC_EGR_DLY_CH2_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_CFC_EGR_DLY_CH2_BIT_CFC_EGR_DLY_2_OFF + subfield_offset),
                                             ETIME120_REG_CFC_EGR_DLY_CH2_BIT_CFC_EGR_DLY_2_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CFC_EGR_DLY_2_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_EGR_DLY_2_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_EGR_DLY_2_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_EGR_DLY_2_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000012c bits 15:0) field CFC_EGR_DLY_2 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH2 */
    reg_value = etime_reg_CFC_EGR_DLY_CH2_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_EGR_DLY_CH2_BIT_CFC_EGR_DLY_2_MSK)
                  >> ETIME120_REG_CFC_EGR_DLY_CH2_BIT_CFC_EGR_DLY_2_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_EGR_DLY_CH2_BIT_CFC_EGR_DLY_2_MSK, ETIME120_REG_CFC_EGR_DLY_CH2_BIT_CFC_EGR_DLY_2_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_EGR_DLY_2_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CFC_EGR_DLY_3_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CFC_EGR_DLY_3_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CFC_EGR_DLY_3_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_CFC_EGR_DLY_3_set", value );

    /* (0x00000130 bits 15:0) field CFC_EGR_DLY_3 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH3 */
    etime_reg_CFC_EGR_DLY_CH3_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_CFC_EGR_DLY_CH3_BIT_CFC_EGR_DLY_3_MSK,
                                         ETIME120_REG_CFC_EGR_DLY_CH3_BIT_CFC_EGR_DLY_3_OFF,
                                         value);
}

static INLINE UINT32 etime_field_CFC_EGR_DLY_3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_EGR_DLY_3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000130 bits 15:0) field CFC_EGR_DLY_3 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH3 */
    reg_value = etime_reg_CFC_EGR_DLY_CH3_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CFC_EGR_DLY_CH3_BIT_CFC_EGR_DLY_3_MSK) >> ETIME120_REG_CFC_EGR_DLY_CH3_BIT_CFC_EGR_DLY_3_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_EGR_DLY_3_get", value );

    return value;
}
static INLINE void etime_field_range_CFC_EGR_DLY_3_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CFC_EGR_DLY_3_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_EGR_DLY_3_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_EGR_DLY_3_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_EGR_DLY_3_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000130 bits 15:0) field CFC_EGR_DLY_3 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH3 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000130 bits 15:0) field CFC_EGR_DLY_3 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH3 */
        etime_reg_CFC_EGR_DLY_CH3_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_CFC_EGR_DLY_CH3_BIT_CFC_EGR_DLY_3_OFF + subfield_offset),
                                             ETIME120_REG_CFC_EGR_DLY_CH3_BIT_CFC_EGR_DLY_3_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CFC_EGR_DLY_3_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_EGR_DLY_3_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_EGR_DLY_3_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_EGR_DLY_3_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000130 bits 15:0) field CFC_EGR_DLY_3 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH3 */
    reg_value = etime_reg_CFC_EGR_DLY_CH3_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_EGR_DLY_CH3_BIT_CFC_EGR_DLY_3_MSK)
                  >> ETIME120_REG_CFC_EGR_DLY_CH3_BIT_CFC_EGR_DLY_3_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_EGR_DLY_CH3_BIT_CFC_EGR_DLY_3_MSK, ETIME120_REG_CFC_EGR_DLY_CH3_BIT_CFC_EGR_DLY_3_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_EGR_DLY_3_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CFC_EGR_DLY_4_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CFC_EGR_DLY_4_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CFC_EGR_DLY_4_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_CFC_EGR_DLY_4_set", value );

    /* (0x00000134 bits 15:0) field CFC_EGR_DLY_4 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH4 */
    etime_reg_CFC_EGR_DLY_CH4_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_CFC_EGR_DLY_CH4_BIT_CFC_EGR_DLY_4_MSK,
                                         ETIME120_REG_CFC_EGR_DLY_CH4_BIT_CFC_EGR_DLY_4_OFF,
                                         value);
}

static INLINE UINT32 etime_field_CFC_EGR_DLY_4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_EGR_DLY_4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000134 bits 15:0) field CFC_EGR_DLY_4 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH4 */
    reg_value = etime_reg_CFC_EGR_DLY_CH4_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CFC_EGR_DLY_CH4_BIT_CFC_EGR_DLY_4_MSK) >> ETIME120_REG_CFC_EGR_DLY_CH4_BIT_CFC_EGR_DLY_4_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_EGR_DLY_4_get", value );

    return value;
}
static INLINE void etime_field_range_CFC_EGR_DLY_4_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CFC_EGR_DLY_4_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_EGR_DLY_4_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_EGR_DLY_4_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_EGR_DLY_4_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000134 bits 15:0) field CFC_EGR_DLY_4 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH4 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000134 bits 15:0) field CFC_EGR_DLY_4 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH4 */
        etime_reg_CFC_EGR_DLY_CH4_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_CFC_EGR_DLY_CH4_BIT_CFC_EGR_DLY_4_OFF + subfield_offset),
                                             ETIME120_REG_CFC_EGR_DLY_CH4_BIT_CFC_EGR_DLY_4_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CFC_EGR_DLY_4_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_EGR_DLY_4_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_EGR_DLY_4_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_EGR_DLY_4_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000134 bits 15:0) field CFC_EGR_DLY_4 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH4 */
    reg_value = etime_reg_CFC_EGR_DLY_CH4_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_EGR_DLY_CH4_BIT_CFC_EGR_DLY_4_MSK)
                  >> ETIME120_REG_CFC_EGR_DLY_CH4_BIT_CFC_EGR_DLY_4_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_EGR_DLY_CH4_BIT_CFC_EGR_DLY_4_MSK, ETIME120_REG_CFC_EGR_DLY_CH4_BIT_CFC_EGR_DLY_4_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_EGR_DLY_4_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CFC_EGR_DLY_5_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CFC_EGR_DLY_5_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CFC_EGR_DLY_5_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_CFC_EGR_DLY_5_set", value );

    /* (0x00000138 bits 15:0) field CFC_EGR_DLY_5 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH5 */
    etime_reg_CFC_EGR_DLY_CH5_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_CFC_EGR_DLY_CH5_BIT_CFC_EGR_DLY_5_MSK,
                                         ETIME120_REG_CFC_EGR_DLY_CH5_BIT_CFC_EGR_DLY_5_OFF,
                                         value);
}

static INLINE UINT32 etime_field_CFC_EGR_DLY_5_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_EGR_DLY_5_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000138 bits 15:0) field CFC_EGR_DLY_5 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH5 */
    reg_value = etime_reg_CFC_EGR_DLY_CH5_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CFC_EGR_DLY_CH5_BIT_CFC_EGR_DLY_5_MSK) >> ETIME120_REG_CFC_EGR_DLY_CH5_BIT_CFC_EGR_DLY_5_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_EGR_DLY_5_get", value );

    return value;
}
static INLINE void etime_field_range_CFC_EGR_DLY_5_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CFC_EGR_DLY_5_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_EGR_DLY_5_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_EGR_DLY_5_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_EGR_DLY_5_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000138 bits 15:0) field CFC_EGR_DLY_5 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH5 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000138 bits 15:0) field CFC_EGR_DLY_5 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH5 */
        etime_reg_CFC_EGR_DLY_CH5_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_CFC_EGR_DLY_CH5_BIT_CFC_EGR_DLY_5_OFF + subfield_offset),
                                             ETIME120_REG_CFC_EGR_DLY_CH5_BIT_CFC_EGR_DLY_5_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CFC_EGR_DLY_5_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_EGR_DLY_5_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_EGR_DLY_5_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_EGR_DLY_5_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000138 bits 15:0) field CFC_EGR_DLY_5 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH5 */
    reg_value = etime_reg_CFC_EGR_DLY_CH5_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_EGR_DLY_CH5_BIT_CFC_EGR_DLY_5_MSK)
                  >> ETIME120_REG_CFC_EGR_DLY_CH5_BIT_CFC_EGR_DLY_5_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_EGR_DLY_CH5_BIT_CFC_EGR_DLY_5_MSK, ETIME120_REG_CFC_EGR_DLY_CH5_BIT_CFC_EGR_DLY_5_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_EGR_DLY_5_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CFC_EGR_DLY_6_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CFC_EGR_DLY_6_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CFC_EGR_DLY_6_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_CFC_EGR_DLY_6_set", value );

    /* (0x0000013c bits 15:0) field CFC_EGR_DLY_6 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH6 */
    etime_reg_CFC_EGR_DLY_CH6_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_CFC_EGR_DLY_CH6_BIT_CFC_EGR_DLY_6_MSK,
                                         ETIME120_REG_CFC_EGR_DLY_CH6_BIT_CFC_EGR_DLY_6_OFF,
                                         value);
}

static INLINE UINT32 etime_field_CFC_EGR_DLY_6_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_EGR_DLY_6_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000013c bits 15:0) field CFC_EGR_DLY_6 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH6 */
    reg_value = etime_reg_CFC_EGR_DLY_CH6_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CFC_EGR_DLY_CH6_BIT_CFC_EGR_DLY_6_MSK) >> ETIME120_REG_CFC_EGR_DLY_CH6_BIT_CFC_EGR_DLY_6_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_EGR_DLY_6_get", value );

    return value;
}
static INLINE void etime_field_range_CFC_EGR_DLY_6_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CFC_EGR_DLY_6_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_EGR_DLY_6_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_EGR_DLY_6_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_EGR_DLY_6_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000013c bits 15:0) field CFC_EGR_DLY_6 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH6 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000013c bits 15:0) field CFC_EGR_DLY_6 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH6 */
        etime_reg_CFC_EGR_DLY_CH6_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_CFC_EGR_DLY_CH6_BIT_CFC_EGR_DLY_6_OFF + subfield_offset),
                                             ETIME120_REG_CFC_EGR_DLY_CH6_BIT_CFC_EGR_DLY_6_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CFC_EGR_DLY_6_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_EGR_DLY_6_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_EGR_DLY_6_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_EGR_DLY_6_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000013c bits 15:0) field CFC_EGR_DLY_6 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH6 */
    reg_value = etime_reg_CFC_EGR_DLY_CH6_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_EGR_DLY_CH6_BIT_CFC_EGR_DLY_6_MSK)
                  >> ETIME120_REG_CFC_EGR_DLY_CH6_BIT_CFC_EGR_DLY_6_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_EGR_DLY_CH6_BIT_CFC_EGR_DLY_6_MSK, ETIME120_REG_CFC_EGR_DLY_CH6_BIT_CFC_EGR_DLY_6_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_EGR_DLY_6_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CFC_EGR_DLY_7_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CFC_EGR_DLY_7_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CFC_EGR_DLY_7_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_CFC_EGR_DLY_7_set", value );

    /* (0x00000140 bits 15:0) field CFC_EGR_DLY_7 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH7 */
    etime_reg_CFC_EGR_DLY_CH7_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_CFC_EGR_DLY_CH7_BIT_CFC_EGR_DLY_7_MSK,
                                         ETIME120_REG_CFC_EGR_DLY_CH7_BIT_CFC_EGR_DLY_7_OFF,
                                         value);
}

static INLINE UINT32 etime_field_CFC_EGR_DLY_7_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_EGR_DLY_7_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000140 bits 15:0) field CFC_EGR_DLY_7 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH7 */
    reg_value = etime_reg_CFC_EGR_DLY_CH7_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CFC_EGR_DLY_CH7_BIT_CFC_EGR_DLY_7_MSK) >> ETIME120_REG_CFC_EGR_DLY_CH7_BIT_CFC_EGR_DLY_7_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_EGR_DLY_7_get", value );

    return value;
}
static INLINE void etime_field_range_CFC_EGR_DLY_7_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CFC_EGR_DLY_7_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_EGR_DLY_7_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_EGR_DLY_7_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_EGR_DLY_7_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000140 bits 15:0) field CFC_EGR_DLY_7 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH7 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000140 bits 15:0) field CFC_EGR_DLY_7 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH7 */
        etime_reg_CFC_EGR_DLY_CH7_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_CFC_EGR_DLY_CH7_BIT_CFC_EGR_DLY_7_OFF + subfield_offset),
                                             ETIME120_REG_CFC_EGR_DLY_CH7_BIT_CFC_EGR_DLY_7_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CFC_EGR_DLY_7_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_EGR_DLY_7_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_EGR_DLY_7_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_EGR_DLY_7_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000140 bits 15:0) field CFC_EGR_DLY_7 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH7 */
    reg_value = etime_reg_CFC_EGR_DLY_CH7_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_EGR_DLY_CH7_BIT_CFC_EGR_DLY_7_MSK)
                  >> ETIME120_REG_CFC_EGR_DLY_CH7_BIT_CFC_EGR_DLY_7_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_EGR_DLY_CH7_BIT_CFC_EGR_DLY_7_MSK, ETIME120_REG_CFC_EGR_DLY_CH7_BIT_CFC_EGR_DLY_7_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_EGR_DLY_7_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CFC_EGR_DLY_8_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CFC_EGR_DLY_8_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CFC_EGR_DLY_8_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_CFC_EGR_DLY_8_set", value );

    /* (0x00000144 bits 15:0) field CFC_EGR_DLY_8 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH8 */
    etime_reg_CFC_EGR_DLY_CH8_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_CFC_EGR_DLY_CH8_BIT_CFC_EGR_DLY_8_MSK,
                                         ETIME120_REG_CFC_EGR_DLY_CH8_BIT_CFC_EGR_DLY_8_OFF,
                                         value);
}

static INLINE UINT32 etime_field_CFC_EGR_DLY_8_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_EGR_DLY_8_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000144 bits 15:0) field CFC_EGR_DLY_8 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH8 */
    reg_value = etime_reg_CFC_EGR_DLY_CH8_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CFC_EGR_DLY_CH8_BIT_CFC_EGR_DLY_8_MSK) >> ETIME120_REG_CFC_EGR_DLY_CH8_BIT_CFC_EGR_DLY_8_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_EGR_DLY_8_get", value );

    return value;
}
static INLINE void etime_field_range_CFC_EGR_DLY_8_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CFC_EGR_DLY_8_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_EGR_DLY_8_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_EGR_DLY_8_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_EGR_DLY_8_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000144 bits 15:0) field CFC_EGR_DLY_8 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH8 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000144 bits 15:0) field CFC_EGR_DLY_8 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH8 */
        etime_reg_CFC_EGR_DLY_CH8_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_CFC_EGR_DLY_CH8_BIT_CFC_EGR_DLY_8_OFF + subfield_offset),
                                             ETIME120_REG_CFC_EGR_DLY_CH8_BIT_CFC_EGR_DLY_8_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CFC_EGR_DLY_8_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_EGR_DLY_8_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_EGR_DLY_8_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_EGR_DLY_8_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000144 bits 15:0) field CFC_EGR_DLY_8 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH8 */
    reg_value = etime_reg_CFC_EGR_DLY_CH8_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_EGR_DLY_CH8_BIT_CFC_EGR_DLY_8_MSK)
                  >> ETIME120_REG_CFC_EGR_DLY_CH8_BIT_CFC_EGR_DLY_8_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_EGR_DLY_CH8_BIT_CFC_EGR_DLY_8_MSK, ETIME120_REG_CFC_EGR_DLY_CH8_BIT_CFC_EGR_DLY_8_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_EGR_DLY_8_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CFC_EGR_DLY_9_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CFC_EGR_DLY_9_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CFC_EGR_DLY_9_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_CFC_EGR_DLY_9_set", value );

    /* (0x00000148 bits 15:0) field CFC_EGR_DLY_9 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH9 */
    etime_reg_CFC_EGR_DLY_CH9_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_CFC_EGR_DLY_CH9_BIT_CFC_EGR_DLY_9_MSK,
                                         ETIME120_REG_CFC_EGR_DLY_CH9_BIT_CFC_EGR_DLY_9_OFF,
                                         value);
}

static INLINE UINT32 etime_field_CFC_EGR_DLY_9_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_EGR_DLY_9_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000148 bits 15:0) field CFC_EGR_DLY_9 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH9 */
    reg_value = etime_reg_CFC_EGR_DLY_CH9_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CFC_EGR_DLY_CH9_BIT_CFC_EGR_DLY_9_MSK) >> ETIME120_REG_CFC_EGR_DLY_CH9_BIT_CFC_EGR_DLY_9_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_EGR_DLY_9_get", value );

    return value;
}
static INLINE void etime_field_range_CFC_EGR_DLY_9_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CFC_EGR_DLY_9_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_EGR_DLY_9_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_EGR_DLY_9_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_EGR_DLY_9_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000148 bits 15:0) field CFC_EGR_DLY_9 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH9 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000148 bits 15:0) field CFC_EGR_DLY_9 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH9 */
        etime_reg_CFC_EGR_DLY_CH9_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_CFC_EGR_DLY_CH9_BIT_CFC_EGR_DLY_9_OFF + subfield_offset),
                                             ETIME120_REG_CFC_EGR_DLY_CH9_BIT_CFC_EGR_DLY_9_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CFC_EGR_DLY_9_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_EGR_DLY_9_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_EGR_DLY_9_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_EGR_DLY_9_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000148 bits 15:0) field CFC_EGR_DLY_9 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH9 */
    reg_value = etime_reg_CFC_EGR_DLY_CH9_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_EGR_DLY_CH9_BIT_CFC_EGR_DLY_9_MSK)
                  >> ETIME120_REG_CFC_EGR_DLY_CH9_BIT_CFC_EGR_DLY_9_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_EGR_DLY_CH9_BIT_CFC_EGR_DLY_9_MSK, ETIME120_REG_CFC_EGR_DLY_CH9_BIT_CFC_EGR_DLY_9_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_EGR_DLY_9_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CFC_EGR_DLY_10_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CFC_EGR_DLY_10_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CFC_EGR_DLY_10_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_CFC_EGR_DLY_10_set", value );

    /* (0x0000014c bits 15:0) field CFC_EGR_DLY_10 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH10 */
    etime_reg_CFC_EGR_DLY_CH10_field_set( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_CFC_EGR_DLY_CH10_BIT_CFC_EGR_DLY_10_MSK,
                                          ETIME120_REG_CFC_EGR_DLY_CH10_BIT_CFC_EGR_DLY_10_OFF,
                                          value);
}

static INLINE UINT32 etime_field_CFC_EGR_DLY_10_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_EGR_DLY_10_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000014c bits 15:0) field CFC_EGR_DLY_10 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH10 */
    reg_value = etime_reg_CFC_EGR_DLY_CH10_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CFC_EGR_DLY_CH10_BIT_CFC_EGR_DLY_10_MSK) >> ETIME120_REG_CFC_EGR_DLY_CH10_BIT_CFC_EGR_DLY_10_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_EGR_DLY_10_get", value );

    return value;
}
static INLINE void etime_field_range_CFC_EGR_DLY_10_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CFC_EGR_DLY_10_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_EGR_DLY_10_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_EGR_DLY_10_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_EGR_DLY_10_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000014c bits 15:0) field CFC_EGR_DLY_10 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH10 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000014c bits 15:0) field CFC_EGR_DLY_10 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH10 */
        etime_reg_CFC_EGR_DLY_CH10_field_set( b_ptr,
                                              h_ptr,
                                              subfield_mask << (ETIME120_REG_CFC_EGR_DLY_CH10_BIT_CFC_EGR_DLY_10_OFF + subfield_offset),
                                              ETIME120_REG_CFC_EGR_DLY_CH10_BIT_CFC_EGR_DLY_10_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CFC_EGR_DLY_10_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_EGR_DLY_10_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_EGR_DLY_10_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_EGR_DLY_10_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000014c bits 15:0) field CFC_EGR_DLY_10 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH10 */
    reg_value = etime_reg_CFC_EGR_DLY_CH10_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_EGR_DLY_CH10_BIT_CFC_EGR_DLY_10_MSK)
                  >> ETIME120_REG_CFC_EGR_DLY_CH10_BIT_CFC_EGR_DLY_10_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_EGR_DLY_CH10_BIT_CFC_EGR_DLY_10_MSK, ETIME120_REG_CFC_EGR_DLY_CH10_BIT_CFC_EGR_DLY_10_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_EGR_DLY_10_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CFC_EGR_DLY_11_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CFC_EGR_DLY_11_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CFC_EGR_DLY_11_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_CFC_EGR_DLY_11_set", value );

    /* (0x00000150 bits 15:0) field CFC_EGR_DLY_11 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH11 */
    etime_reg_CFC_EGR_DLY_CH11_field_set( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_CFC_EGR_DLY_CH11_BIT_CFC_EGR_DLY_11_MSK,
                                          ETIME120_REG_CFC_EGR_DLY_CH11_BIT_CFC_EGR_DLY_11_OFF,
                                          value);
}

static INLINE UINT32 etime_field_CFC_EGR_DLY_11_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_EGR_DLY_11_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000150 bits 15:0) field CFC_EGR_DLY_11 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH11 */
    reg_value = etime_reg_CFC_EGR_DLY_CH11_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CFC_EGR_DLY_CH11_BIT_CFC_EGR_DLY_11_MSK) >> ETIME120_REG_CFC_EGR_DLY_CH11_BIT_CFC_EGR_DLY_11_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_EGR_DLY_11_get", value );

    return value;
}
static INLINE void etime_field_range_CFC_EGR_DLY_11_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CFC_EGR_DLY_11_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_EGR_DLY_11_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_EGR_DLY_11_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_EGR_DLY_11_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000150 bits 15:0) field CFC_EGR_DLY_11 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH11 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000150 bits 15:0) field CFC_EGR_DLY_11 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH11 */
        etime_reg_CFC_EGR_DLY_CH11_field_set( b_ptr,
                                              h_ptr,
                                              subfield_mask << (ETIME120_REG_CFC_EGR_DLY_CH11_BIT_CFC_EGR_DLY_11_OFF + subfield_offset),
                                              ETIME120_REG_CFC_EGR_DLY_CH11_BIT_CFC_EGR_DLY_11_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CFC_EGR_DLY_11_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_EGR_DLY_11_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_EGR_DLY_11_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_EGR_DLY_11_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000150 bits 15:0) field CFC_EGR_DLY_11 of register PMC_ETIME120_REG_CFC_EGR_DLY_CH11 */
    reg_value = etime_reg_CFC_EGR_DLY_CH11_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_EGR_DLY_CH11_BIT_CFC_EGR_DLY_11_MSK)
                  >> ETIME120_REG_CFC_EGR_DLY_CH11_BIT_CFC_EGR_DLY_11_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_EGR_DLY_CH11_BIT_CFC_EGR_DLY_11_MSK, ETIME120_REG_CFC_EGR_DLY_CH11_BIT_CFC_EGR_DLY_11_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_EGR_DLY_11_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TS_ZERO_STRAP_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TS_ZERO_STRAP_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TS_ZERO_STRAP_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_TS_ZERO_STRAP_set", value );

    /* (0x00000154 bits 10) field TS_ZERO_STRAP of register PMC_ETIME120_REG_TS_CNTR_CFG */
    etime_reg_TS_CNTR_CFG_field_set( b_ptr,
                                     h_ptr,
                                     ETIME120_REG_TS_CNTR_CFG_BIT_TS_ZERO_STRAP_MSK,
                                     ETIME120_REG_TS_CNTR_CFG_BIT_TS_ZERO_STRAP_OFF,
                                     value);
}

static INLINE UINT32 etime_field_TS_ZERO_STRAP_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TS_ZERO_STRAP_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000154 bits 10) field TS_ZERO_STRAP of register PMC_ETIME120_REG_TS_CNTR_CFG */
    reg_value = etime_reg_TS_CNTR_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TS_CNTR_CFG_BIT_TS_ZERO_STRAP_MSK) >> ETIME120_REG_TS_CNTR_CFG_BIT_TS_ZERO_STRAP_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TS_ZERO_STRAP_get", value );

    return value;
}
static INLINE void etime_field_B2B_SUPPRESS_ENA_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_B2B_SUPPRESS_ENA_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_B2B_SUPPRESS_ENA_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_B2B_SUPPRESS_ENA_set", value );

    /* (0x00000154 bits 9) field B2B_SUPPRESS_ENA of register PMC_ETIME120_REG_TS_CNTR_CFG */
    etime_reg_TS_CNTR_CFG_field_set( b_ptr,
                                     h_ptr,
                                     ETIME120_REG_TS_CNTR_CFG_BIT_B2B_SUPPRESS_ENA_MSK,
                                     ETIME120_REG_TS_CNTR_CFG_BIT_B2B_SUPPRESS_ENA_OFF,
                                     value);
}

static INLINE UINT32 etime_field_B2B_SUPPRESS_ENA_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_B2B_SUPPRESS_ENA_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000154 bits 9) field B2B_SUPPRESS_ENA of register PMC_ETIME120_REG_TS_CNTR_CFG */
    reg_value = etime_reg_TS_CNTR_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TS_CNTR_CFG_BIT_B2B_SUPPRESS_ENA_MSK) >> ETIME120_REG_TS_CNTR_CFG_BIT_B2B_SUPPRESS_ENA_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_B2B_SUPPRESS_ENA_get", value );

    return value;
}
static INLINE void etime_field_MAC_SYNC_DLY_set( etime_buffer_t *b_ptr,
                                                 etime_handle_t *h_ptr,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_MAC_SYNC_DLY_set( etime_buffer_t *b_ptr,
                                                 etime_handle_t *h_ptr,
                                                 UINT32 value )
{
    if (value > 3)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_MAC_SYNC_DLY_set", value, 3);
    IOLOG( "%s <= 0x%08x", "etime_field_MAC_SYNC_DLY_set", value );

    /* (0x00000154 bits 8:7) field MAC_SYNC_DLY of register PMC_ETIME120_REG_TS_CNTR_CFG */
    etime_reg_TS_CNTR_CFG_field_set( b_ptr,
                                     h_ptr,
                                     ETIME120_REG_TS_CNTR_CFG_BIT_MAC_SYNC_DLY_MSK,
                                     ETIME120_REG_TS_CNTR_CFG_BIT_MAC_SYNC_DLY_OFF,
                                     value);
}

static INLINE UINT32 etime_field_MAC_SYNC_DLY_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_MAC_SYNC_DLY_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000154 bits 8:7) field MAC_SYNC_DLY of register PMC_ETIME120_REG_TS_CNTR_CFG */
    reg_value = etime_reg_TS_CNTR_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TS_CNTR_CFG_BIT_MAC_SYNC_DLY_MSK) >> ETIME120_REG_TS_CNTR_CFG_BIT_MAC_SYNC_DLY_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_MAC_SYNC_DLY_get", value );

    return value;
}
static INLINE void etime_field_range_MAC_SYNC_DLY_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_MAC_SYNC_DLY_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_MAC_SYNC_DLY_set", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_MAC_SYNC_DLY_set", stop_bit, 1 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_MAC_SYNC_DLY_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000154 bits 8:7) field MAC_SYNC_DLY of register PMC_ETIME120_REG_TS_CNTR_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 1) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 1;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000154 bits 8:7) field MAC_SYNC_DLY of register PMC_ETIME120_REG_TS_CNTR_CFG */
        etime_reg_TS_CNTR_CFG_field_set( b_ptr,
                                         h_ptr,
                                         subfield_mask << (ETIME120_REG_TS_CNTR_CFG_BIT_MAC_SYNC_DLY_OFF + subfield_offset),
                                         ETIME120_REG_TS_CNTR_CFG_BIT_MAC_SYNC_DLY_OFF + subfield_offset,
                                         value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_MAC_SYNC_DLY_get( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_MAC_SYNC_DLY_get( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_MAC_SYNC_DLY_get", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_MAC_SYNC_DLY_get", stop_bit, 1 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 1) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 1;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000154 bits 8:7) field MAC_SYNC_DLY of register PMC_ETIME120_REG_TS_CNTR_CFG */
    reg_value = etime_reg_TS_CNTR_CFG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TS_CNTR_CFG_BIT_MAC_SYNC_DLY_MSK)
                  >> ETIME120_REG_TS_CNTR_CFG_BIT_MAC_SYNC_DLY_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TS_CNTR_CFG_BIT_MAC_SYNC_DLY_MSK, ETIME120_REG_TS_CNTR_CFG_BIT_MAC_SYNC_DLY_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_MAC_SYNC_DLY_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_IRIGO_CAPTURED_TS_SEL_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGO_CAPTURED_TS_SEL_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGO_CAPTURED_TS_SEL_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGO_CAPTURED_TS_SEL_set", value );

    /* (0x00000154 bits 6) field IRIGO_CAPTURED_TS_SEL of register PMC_ETIME120_REG_TS_CNTR_CFG */
    etime_reg_TS_CNTR_CFG_field_set( b_ptr,
                                     h_ptr,
                                     ETIME120_REG_TS_CNTR_CFG_BIT_IRIGO_CAPTURED_TS_SEL_MSK,
                                     ETIME120_REG_TS_CNTR_CFG_BIT_IRIGO_CAPTURED_TS_SEL_OFF,
                                     value);
}

static INLINE UINT32 etime_field_IRIGO_CAPTURED_TS_SEL_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGO_CAPTURED_TS_SEL_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000154 bits 6) field IRIGO_CAPTURED_TS_SEL of register PMC_ETIME120_REG_TS_CNTR_CFG */
    reg_value = etime_reg_TS_CNTR_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TS_CNTR_CFG_BIT_IRIGO_CAPTURED_TS_SEL_MSK) >> ETIME120_REG_TS_CNTR_CFG_BIT_IRIGO_CAPTURED_TS_SEL_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGO_CAPTURED_TS_SEL_get", value );

    return value;
}
static INLINE void etime_field_IRIGI_CAPTURED_TS_SEL_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGI_CAPTURED_TS_SEL_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGI_CAPTURED_TS_SEL_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGI_CAPTURED_TS_SEL_set", value );

    /* (0x00000154 bits 5) field IRIGI_CAPTURED_TS_SEL of register PMC_ETIME120_REG_TS_CNTR_CFG */
    etime_reg_TS_CNTR_CFG_field_set( b_ptr,
                                     h_ptr,
                                     ETIME120_REG_TS_CNTR_CFG_BIT_IRIGI_CAPTURED_TS_SEL_MSK,
                                     ETIME120_REG_TS_CNTR_CFG_BIT_IRIGI_CAPTURED_TS_SEL_OFF,
                                     value);
}

static INLINE UINT32 etime_field_IRIGI_CAPTURED_TS_SEL_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_CAPTURED_TS_SEL_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000154 bits 5) field IRIGI_CAPTURED_TS_SEL of register PMC_ETIME120_REG_TS_CNTR_CFG */
    reg_value = etime_reg_TS_CNTR_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TS_CNTR_CFG_BIT_IRIGI_CAPTURED_TS_SEL_MSK) >> ETIME120_REG_TS_CNTR_CFG_BIT_IRIGI_CAPTURED_TS_SEL_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_CAPTURED_TS_SEL_get", value );

    return value;
}
static INLINE void etime_field_CAPTURED_TS_SEL_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CAPTURED_TS_SEL_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CAPTURED_TS_SEL_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_CAPTURED_TS_SEL_set", value );

    /* (0x00000154 bits 4) field CAPTURED_TS_SEL of register PMC_ETIME120_REG_TS_CNTR_CFG */
    etime_reg_TS_CNTR_CFG_field_set( b_ptr,
                                     h_ptr,
                                     ETIME120_REG_TS_CNTR_CFG_BIT_CAPTURED_TS_SEL_MSK,
                                     ETIME120_REG_TS_CNTR_CFG_BIT_CAPTURED_TS_SEL_OFF,
                                     value);
}

static INLINE UINT32 etime_field_CAPTURED_TS_SEL_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CAPTURED_TS_SEL_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000154 bits 4) field CAPTURED_TS_SEL of register PMC_ETIME120_REG_TS_CNTR_CFG */
    reg_value = etime_reg_TS_CNTR_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TS_CNTR_CFG_BIT_CAPTURED_TS_SEL_MSK) >> ETIME120_REG_TS_CNTR_CFG_BIT_CAPTURED_TS_SEL_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CAPTURED_TS_SEL_get", value );

    return value;
}
static INLINE void etime_field_TS_ADV_set( etime_buffer_t *b_ptr,
                                           etime_handle_t *h_ptr,
                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TS_ADV_set( etime_buffer_t *b_ptr,
                                           etime_handle_t *h_ptr,
                                           UINT32 value )
{
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TS_ADV_set", value, 7);
    IOLOG( "%s <= 0x%08x", "etime_field_TS_ADV_set", value );

    /* (0x00000154 bits 3:1) field TS_ADV of register PMC_ETIME120_REG_TS_CNTR_CFG */
    etime_reg_TS_CNTR_CFG_field_set( b_ptr,
                                     h_ptr,
                                     ETIME120_REG_TS_CNTR_CFG_BIT_TS_ADV_MSK,
                                     ETIME120_REG_TS_CNTR_CFG_BIT_TS_ADV_OFF,
                                     value);
}

static INLINE UINT32 etime_field_TS_ADV_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TS_ADV_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000154 bits 3:1) field TS_ADV of register PMC_ETIME120_REG_TS_CNTR_CFG */
    reg_value = etime_reg_TS_CNTR_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TS_CNTR_CFG_BIT_TS_ADV_MSK) >> ETIME120_REG_TS_CNTR_CFG_BIT_TS_ADV_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TS_ADV_get", value );

    return value;
}
static INLINE void etime_field_range_TS_ADV_set( etime_buffer_t *b_ptr,
                                                 etime_handle_t *h_ptr,
                                                 UINT32 start_bit,
                                                 UINT32 stop_bit,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TS_ADV_set( etime_buffer_t *b_ptr,
                                                 etime_handle_t *h_ptr,
                                                 UINT32 start_bit,
                                                 UINT32 stop_bit,
                                                 UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TS_ADV_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TS_ADV_set", stop_bit, 2 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TS_ADV_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000154 bits 3:1) field TS_ADV of register PMC_ETIME120_REG_TS_CNTR_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000154 bits 3:1) field TS_ADV of register PMC_ETIME120_REG_TS_CNTR_CFG */
        etime_reg_TS_CNTR_CFG_field_set( b_ptr,
                                         h_ptr,
                                         subfield_mask << (ETIME120_REG_TS_CNTR_CFG_BIT_TS_ADV_OFF + subfield_offset),
                                         ETIME120_REG_TS_CNTR_CFG_BIT_TS_ADV_OFF + subfield_offset,
                                         value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TS_ADV_get( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 start_bit,
                                                   UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TS_ADV_get( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 start_bit,
                                                   UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TS_ADV_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TS_ADV_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000154 bits 3:1) field TS_ADV of register PMC_ETIME120_REG_TS_CNTR_CFG */
    reg_value = etime_reg_TS_CNTR_CFG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TS_CNTR_CFG_BIT_TS_ADV_MSK)
                  >> ETIME120_REG_TS_CNTR_CFG_BIT_TS_ADV_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TS_CNTR_CFG_BIT_TS_ADV_MSK, ETIME120_REG_TS_CNTR_CFG_BIT_TS_ADV_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TS_ADV_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TS_CNTR_EN_set( etime_buffer_t *b_ptr,
                                               etime_handle_t *h_ptr,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TS_CNTR_EN_set( etime_buffer_t *b_ptr,
                                               etime_handle_t *h_ptr,
                                               UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TS_CNTR_EN_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_TS_CNTR_EN_set", value );

    /* (0x00000154 bits 0) field TS_CNTR_EN of register PMC_ETIME120_REG_TS_CNTR_CFG */
    etime_reg_TS_CNTR_CFG_field_set( b_ptr,
                                     h_ptr,
                                     ETIME120_REG_TS_CNTR_CFG_BIT_TS_CNTR_EN_MSK,
                                     ETIME120_REG_TS_CNTR_CFG_BIT_TS_CNTR_EN_OFF,
                                     value);
}

static INLINE UINT32 etime_field_TS_CNTR_EN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TS_CNTR_EN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000154 bits 0) field TS_CNTR_EN of register PMC_ETIME120_REG_TS_CNTR_CFG */
    reg_value = etime_reg_TS_CNTR_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TS_CNTR_CFG_BIT_TS_CNTR_EN_MSK) >> ETIME120_REG_TS_CNTR_CFG_BIT_TS_CNTR_EN_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TS_CNTR_EN_get", value );

    return value;
}
static INLINE void etime_field_OFFS_UPD_TIME_SEC_HI_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_OFFS_UPD_TIME_SEC_HI_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_OFFS_UPD_TIME_SEC_HI_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_OFFS_UPD_TIME_SEC_HI_set", value );

    /* (0x00000158 bits 15:0) field OFFS_UPD_TIME_SEC_HI of register PMC_ETIME120_REG_OFFS_UPD_TIME_SEC_HI_REG */
    etime_reg_OFFS_UPD_TIME_SEC_HI_REG_field_set( b_ptr,
                                                  h_ptr,
                                                  ETIME120_REG_OFFS_UPD_TIME_SEC_HI_REG_BIT_OFFS_UPD_TIME_SEC_HI_MSK,
                                                  ETIME120_REG_OFFS_UPD_TIME_SEC_HI_REG_BIT_OFFS_UPD_TIME_SEC_HI_OFF,
                                                  value);
}

static INLINE UINT32 etime_field_OFFS_UPD_TIME_SEC_HI_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_OFFS_UPD_TIME_SEC_HI_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000158 bits 15:0) field OFFS_UPD_TIME_SEC_HI of register PMC_ETIME120_REG_OFFS_UPD_TIME_SEC_HI_REG */
    reg_value = etime_reg_OFFS_UPD_TIME_SEC_HI_REG_read( b_ptr,
                                                         h_ptr);
    value = (reg_value & ETIME120_REG_OFFS_UPD_TIME_SEC_HI_REG_BIT_OFFS_UPD_TIME_SEC_HI_MSK) >> ETIME120_REG_OFFS_UPD_TIME_SEC_HI_REG_BIT_OFFS_UPD_TIME_SEC_HI_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_OFFS_UPD_TIME_SEC_HI_get", value );

    return value;
}
static INLINE void etime_field_range_OFFS_UPD_TIME_SEC_HI_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_OFFS_UPD_TIME_SEC_HI_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_OFFS_UPD_TIME_SEC_HI_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_OFFS_UPD_TIME_SEC_HI_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_OFFS_UPD_TIME_SEC_HI_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000158 bits 15:0) field OFFS_UPD_TIME_SEC_HI of register PMC_ETIME120_REG_OFFS_UPD_TIME_SEC_HI_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000158 bits 15:0) field OFFS_UPD_TIME_SEC_HI of register PMC_ETIME120_REG_OFFS_UPD_TIME_SEC_HI_REG */
        etime_reg_OFFS_UPD_TIME_SEC_HI_REG_field_set( b_ptr,
                                                      h_ptr,
                                                      subfield_mask << (ETIME120_REG_OFFS_UPD_TIME_SEC_HI_REG_BIT_OFFS_UPD_TIME_SEC_HI_OFF + subfield_offset),
                                                      ETIME120_REG_OFFS_UPD_TIME_SEC_HI_REG_BIT_OFFS_UPD_TIME_SEC_HI_OFF + subfield_offset,
                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_OFFS_UPD_TIME_SEC_HI_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_OFFS_UPD_TIME_SEC_HI_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_OFFS_UPD_TIME_SEC_HI_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_OFFS_UPD_TIME_SEC_HI_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000158 bits 15:0) field OFFS_UPD_TIME_SEC_HI of register PMC_ETIME120_REG_OFFS_UPD_TIME_SEC_HI_REG */
    reg_value = etime_reg_OFFS_UPD_TIME_SEC_HI_REG_read( b_ptr,
                                                         h_ptr);
    field_value = (reg_value & ETIME120_REG_OFFS_UPD_TIME_SEC_HI_REG_BIT_OFFS_UPD_TIME_SEC_HI_MSK)
                  >> ETIME120_REG_OFFS_UPD_TIME_SEC_HI_REG_BIT_OFFS_UPD_TIME_SEC_HI_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_OFFS_UPD_TIME_SEC_HI_REG_BIT_OFFS_UPD_TIME_SEC_HI_MSK, ETIME120_REG_OFFS_UPD_TIME_SEC_HI_REG_BIT_OFFS_UPD_TIME_SEC_HI_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_OFFS_UPD_TIME_SEC_HI_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_OFFS_UPD_TIME_SEC_LO_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_OFFS_UPD_TIME_SEC_LO_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value )
{
    IOLOG( "%s <= 0x%08x", "etime_field_OFFS_UPD_TIME_SEC_LO_set", value );

    /* (0x0000015c bits 31:0) field OFFS_UPD_TIME_SEC_LO of register PMC_ETIME120_REG_OFFS_UPD_TIME_SEC_LO_REG */
    etime_reg_OFFS_UPD_TIME_SEC_LO_REG_field_set( b_ptr,
                                                  h_ptr,
                                                  ETIME120_REG_OFFS_UPD_TIME_SEC_LO_REG_BIT_OFFS_UPD_TIME_SEC_LO_MSK,
                                                  ETIME120_REG_OFFS_UPD_TIME_SEC_LO_REG_BIT_OFFS_UPD_TIME_SEC_LO_OFF,
                                                  value);
}

static INLINE UINT32 etime_field_OFFS_UPD_TIME_SEC_LO_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_OFFS_UPD_TIME_SEC_LO_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000015c bits 31:0) field OFFS_UPD_TIME_SEC_LO of register PMC_ETIME120_REG_OFFS_UPD_TIME_SEC_LO_REG */
    reg_value = etime_reg_OFFS_UPD_TIME_SEC_LO_REG_read( b_ptr,
                                                         h_ptr);
    value = (reg_value & ETIME120_REG_OFFS_UPD_TIME_SEC_LO_REG_BIT_OFFS_UPD_TIME_SEC_LO_MSK) >> ETIME120_REG_OFFS_UPD_TIME_SEC_LO_REG_BIT_OFFS_UPD_TIME_SEC_LO_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_OFFS_UPD_TIME_SEC_LO_get", value );

    return value;
}
static INLINE void etime_field_range_OFFS_UPD_TIME_SEC_LO_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_OFFS_UPD_TIME_SEC_LO_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_OFFS_UPD_TIME_SEC_LO_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_OFFS_UPD_TIME_SEC_LO_set", stop_bit, 31 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_OFFS_UPD_TIME_SEC_LO_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000015c bits 31:0) field OFFS_UPD_TIME_SEC_LO of register PMC_ETIME120_REG_OFFS_UPD_TIME_SEC_LO_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000015c bits 31:0) field OFFS_UPD_TIME_SEC_LO of register PMC_ETIME120_REG_OFFS_UPD_TIME_SEC_LO_REG */
        etime_reg_OFFS_UPD_TIME_SEC_LO_REG_field_set( b_ptr,
                                                      h_ptr,
                                                      subfield_mask << (ETIME120_REG_OFFS_UPD_TIME_SEC_LO_REG_BIT_OFFS_UPD_TIME_SEC_LO_OFF + subfield_offset),
                                                      ETIME120_REG_OFFS_UPD_TIME_SEC_LO_REG_BIT_OFFS_UPD_TIME_SEC_LO_OFF + subfield_offset,
                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_OFFS_UPD_TIME_SEC_LO_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_OFFS_UPD_TIME_SEC_LO_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_OFFS_UPD_TIME_SEC_LO_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_OFFS_UPD_TIME_SEC_LO_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000015c bits 31:0) field OFFS_UPD_TIME_SEC_LO of register PMC_ETIME120_REG_OFFS_UPD_TIME_SEC_LO_REG */
    reg_value = etime_reg_OFFS_UPD_TIME_SEC_LO_REG_read( b_ptr,
                                                         h_ptr);
    field_value = (reg_value & ETIME120_REG_OFFS_UPD_TIME_SEC_LO_REG_BIT_OFFS_UPD_TIME_SEC_LO_MSK)
                  >> ETIME120_REG_OFFS_UPD_TIME_SEC_LO_REG_BIT_OFFS_UPD_TIME_SEC_LO_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_OFFS_UPD_TIME_SEC_LO_REG_BIT_OFFS_UPD_TIME_SEC_LO_MSK, ETIME120_REG_OFFS_UPD_TIME_SEC_LO_REG_BIT_OFFS_UPD_TIME_SEC_LO_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_OFFS_UPD_TIME_SEC_LO_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_OFFS_UPD_TIME_NSEC_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_OFFS_UPD_TIME_NSEC_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value )
{
    IOLOG( "%s <= 0x%08x", "etime_field_OFFS_UPD_TIME_NSEC_set", value );

    /* (0x00000160 bits 31:0) field OFFS_UPD_TIME_NSEC of register PMC_ETIME120_REG_OFFS_UPD_TIME_NSEC_REG */
    etime_reg_OFFS_UPD_TIME_NSEC_REG_field_set( b_ptr,
                                                h_ptr,
                                                ETIME120_REG_OFFS_UPD_TIME_NSEC_REG_BIT_OFFS_UPD_TIME_NSEC_MSK,
                                                ETIME120_REG_OFFS_UPD_TIME_NSEC_REG_BIT_OFFS_UPD_TIME_NSEC_OFF,
                                                value);
}

static INLINE UINT32 etime_field_OFFS_UPD_TIME_NSEC_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_OFFS_UPD_TIME_NSEC_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000160 bits 31:0) field OFFS_UPD_TIME_NSEC of register PMC_ETIME120_REG_OFFS_UPD_TIME_NSEC_REG */
    reg_value = etime_reg_OFFS_UPD_TIME_NSEC_REG_read( b_ptr,
                                                       h_ptr);
    value = (reg_value & ETIME120_REG_OFFS_UPD_TIME_NSEC_REG_BIT_OFFS_UPD_TIME_NSEC_MSK) >> ETIME120_REG_OFFS_UPD_TIME_NSEC_REG_BIT_OFFS_UPD_TIME_NSEC_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_OFFS_UPD_TIME_NSEC_get", value );

    return value;
}
static INLINE void etime_field_range_OFFS_UPD_TIME_NSEC_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_OFFS_UPD_TIME_NSEC_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit,
                                                             UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_OFFS_UPD_TIME_NSEC_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_OFFS_UPD_TIME_NSEC_set", stop_bit, 31 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_OFFS_UPD_TIME_NSEC_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000160 bits 31:0) field OFFS_UPD_TIME_NSEC of register PMC_ETIME120_REG_OFFS_UPD_TIME_NSEC_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000160 bits 31:0) field OFFS_UPD_TIME_NSEC of register PMC_ETIME120_REG_OFFS_UPD_TIME_NSEC_REG */
        etime_reg_OFFS_UPD_TIME_NSEC_REG_field_set( b_ptr,
                                                    h_ptr,
                                                    subfield_mask << (ETIME120_REG_OFFS_UPD_TIME_NSEC_REG_BIT_OFFS_UPD_TIME_NSEC_OFF + subfield_offset),
                                                    ETIME120_REG_OFFS_UPD_TIME_NSEC_REG_BIT_OFFS_UPD_TIME_NSEC_OFF + subfield_offset,
                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_OFFS_UPD_TIME_NSEC_get( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_OFFS_UPD_TIME_NSEC_get( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_OFFS_UPD_TIME_NSEC_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_OFFS_UPD_TIME_NSEC_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000160 bits 31:0) field OFFS_UPD_TIME_NSEC of register PMC_ETIME120_REG_OFFS_UPD_TIME_NSEC_REG */
    reg_value = etime_reg_OFFS_UPD_TIME_NSEC_REG_read( b_ptr,
                                                       h_ptr);
    field_value = (reg_value & ETIME120_REG_OFFS_UPD_TIME_NSEC_REG_BIT_OFFS_UPD_TIME_NSEC_MSK)
                  >> ETIME120_REG_OFFS_UPD_TIME_NSEC_REG_BIT_OFFS_UPD_TIME_NSEC_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_OFFS_UPD_TIME_NSEC_REG_BIT_OFFS_UPD_TIME_NSEC_MSK, ETIME120_REG_OFFS_UPD_TIME_NSEC_REG_BIT_OFFS_UPD_TIME_NSEC_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_OFFS_UPD_TIME_NSEC_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_PTP_CLK_PER_INT_HI_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_PTP_CLK_PER_INT_HI_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value )
{
    IOLOG( "%s <= 0x%08x", "etime_field_PTP_CLK_PER_INT_HI_set", value );

    /* (0x00000164 bits 31:0) field PTP_CLK_PER_INT_HI of register PMC_ETIME120_REG_PTP_CLK_PER_INT_HI_REG */
    etime_reg_PTP_CLK_PER_INT_HI_REG_field_set( b_ptr,
                                                h_ptr,
                                                ETIME120_REG_PTP_CLK_PER_INT_HI_REG_BIT_PTP_CLK_PER_INT_HI_MSK,
                                                ETIME120_REG_PTP_CLK_PER_INT_HI_REG_BIT_PTP_CLK_PER_INT_HI_OFF,
                                                value);
}

static INLINE UINT32 etime_field_PTP_CLK_PER_INT_HI_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_PTP_CLK_PER_INT_HI_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000164 bits 31:0) field PTP_CLK_PER_INT_HI of register PMC_ETIME120_REG_PTP_CLK_PER_INT_HI_REG */
    reg_value = etime_reg_PTP_CLK_PER_INT_HI_REG_read( b_ptr,
                                                       h_ptr);
    value = (reg_value & ETIME120_REG_PTP_CLK_PER_INT_HI_REG_BIT_PTP_CLK_PER_INT_HI_MSK) >> ETIME120_REG_PTP_CLK_PER_INT_HI_REG_BIT_PTP_CLK_PER_INT_HI_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_PTP_CLK_PER_INT_HI_get", value );

    return value;
}
static INLINE void etime_field_range_PTP_CLK_PER_INT_HI_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_PTP_CLK_PER_INT_HI_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit,
                                                             UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_PTP_CLK_PER_INT_HI_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_PTP_CLK_PER_INT_HI_set", stop_bit, 31 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_PTP_CLK_PER_INT_HI_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000164 bits 31:0) field PTP_CLK_PER_INT_HI of register PMC_ETIME120_REG_PTP_CLK_PER_INT_HI_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000164 bits 31:0) field PTP_CLK_PER_INT_HI of register PMC_ETIME120_REG_PTP_CLK_PER_INT_HI_REG */
        etime_reg_PTP_CLK_PER_INT_HI_REG_field_set( b_ptr,
                                                    h_ptr,
                                                    subfield_mask << (ETIME120_REG_PTP_CLK_PER_INT_HI_REG_BIT_PTP_CLK_PER_INT_HI_OFF + subfield_offset),
                                                    ETIME120_REG_PTP_CLK_PER_INT_HI_REG_BIT_PTP_CLK_PER_INT_HI_OFF + subfield_offset,
                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_PTP_CLK_PER_INT_HI_get( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_PTP_CLK_PER_INT_HI_get( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_PTP_CLK_PER_INT_HI_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_PTP_CLK_PER_INT_HI_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000164 bits 31:0) field PTP_CLK_PER_INT_HI of register PMC_ETIME120_REG_PTP_CLK_PER_INT_HI_REG */
    reg_value = etime_reg_PTP_CLK_PER_INT_HI_REG_read( b_ptr,
                                                       h_ptr);
    field_value = (reg_value & ETIME120_REG_PTP_CLK_PER_INT_HI_REG_BIT_PTP_CLK_PER_INT_HI_MSK)
                  >> ETIME120_REG_PTP_CLK_PER_INT_HI_REG_BIT_PTP_CLK_PER_INT_HI_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_PTP_CLK_PER_INT_HI_REG_BIT_PTP_CLK_PER_INT_HI_MSK, ETIME120_REG_PTP_CLK_PER_INT_HI_REG_BIT_PTP_CLK_PER_INT_HI_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_PTP_CLK_PER_INT_HI_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_PTP_CLK_PER_INT_LO_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_PTP_CLK_PER_INT_LO_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value )
{
    IOLOG( "%s <= 0x%08x", "etime_field_PTP_CLK_PER_INT_LO_set", value );

    /* (0x00000168 bits 31:0) field PTP_CLK_PER_INT_LO of register PMC_ETIME120_REG_PTP_CLK_PER_INT_LO_REG */
    etime_reg_PTP_CLK_PER_INT_LO_REG_field_set( b_ptr,
                                                h_ptr,
                                                ETIME120_REG_PTP_CLK_PER_INT_LO_REG_BIT_PTP_CLK_PER_INT_LO_MSK,
                                                ETIME120_REG_PTP_CLK_PER_INT_LO_REG_BIT_PTP_CLK_PER_INT_LO_OFF,
                                                value);
}

static INLINE UINT32 etime_field_PTP_CLK_PER_INT_LO_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_PTP_CLK_PER_INT_LO_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000168 bits 31:0) field PTP_CLK_PER_INT_LO of register PMC_ETIME120_REG_PTP_CLK_PER_INT_LO_REG */
    reg_value = etime_reg_PTP_CLK_PER_INT_LO_REG_read( b_ptr,
                                                       h_ptr);
    value = (reg_value & ETIME120_REG_PTP_CLK_PER_INT_LO_REG_BIT_PTP_CLK_PER_INT_LO_MSK) >> ETIME120_REG_PTP_CLK_PER_INT_LO_REG_BIT_PTP_CLK_PER_INT_LO_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_PTP_CLK_PER_INT_LO_get", value );

    return value;
}
static INLINE void etime_field_range_PTP_CLK_PER_INT_LO_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_PTP_CLK_PER_INT_LO_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit,
                                                             UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_PTP_CLK_PER_INT_LO_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_PTP_CLK_PER_INT_LO_set", stop_bit, 31 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_PTP_CLK_PER_INT_LO_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000168 bits 31:0) field PTP_CLK_PER_INT_LO of register PMC_ETIME120_REG_PTP_CLK_PER_INT_LO_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000168 bits 31:0) field PTP_CLK_PER_INT_LO of register PMC_ETIME120_REG_PTP_CLK_PER_INT_LO_REG */
        etime_reg_PTP_CLK_PER_INT_LO_REG_field_set( b_ptr,
                                                    h_ptr,
                                                    subfield_mask << (ETIME120_REG_PTP_CLK_PER_INT_LO_REG_BIT_PTP_CLK_PER_INT_LO_OFF + subfield_offset),
                                                    ETIME120_REG_PTP_CLK_PER_INT_LO_REG_BIT_PTP_CLK_PER_INT_LO_OFF + subfield_offset,
                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_PTP_CLK_PER_INT_LO_get( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_PTP_CLK_PER_INT_LO_get( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_PTP_CLK_PER_INT_LO_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_PTP_CLK_PER_INT_LO_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000168 bits 31:0) field PTP_CLK_PER_INT_LO of register PMC_ETIME120_REG_PTP_CLK_PER_INT_LO_REG */
    reg_value = etime_reg_PTP_CLK_PER_INT_LO_REG_read( b_ptr,
                                                       h_ptr);
    field_value = (reg_value & ETIME120_REG_PTP_CLK_PER_INT_LO_REG_BIT_PTP_CLK_PER_INT_LO_MSK)
                  >> ETIME120_REG_PTP_CLK_PER_INT_LO_REG_BIT_PTP_CLK_PER_INT_LO_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_PTP_CLK_PER_INT_LO_REG_BIT_PTP_CLK_PER_INT_LO_MSK, ETIME120_REG_PTP_CLK_PER_INT_LO_REG_BIT_PTP_CLK_PER_INT_LO_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_PTP_CLK_PER_INT_LO_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_PTP_CLK_PER_NUM_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_PTP_CLK_PER_NUM_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <= 0x%08x", "etime_field_PTP_CLK_PER_NUM_set", value );

    /* (0x0000016c bits 31:0) field PTP_CLK_PER_NUM of register PMC_ETIME120_REG_PTP_CLK_PER_NUM_REG */
    etime_reg_PTP_CLK_PER_NUM_REG_field_set( b_ptr,
                                             h_ptr,
                                             ETIME120_REG_PTP_CLK_PER_NUM_REG_BIT_PTP_CLK_PER_NUM_MSK,
                                             ETIME120_REG_PTP_CLK_PER_NUM_REG_BIT_PTP_CLK_PER_NUM_OFF,
                                             value);
}

static INLINE UINT32 etime_field_PTP_CLK_PER_NUM_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_PTP_CLK_PER_NUM_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000016c bits 31:0) field PTP_CLK_PER_NUM of register PMC_ETIME120_REG_PTP_CLK_PER_NUM_REG */
    reg_value = etime_reg_PTP_CLK_PER_NUM_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_PTP_CLK_PER_NUM_REG_BIT_PTP_CLK_PER_NUM_MSK) >> ETIME120_REG_PTP_CLK_PER_NUM_REG_BIT_PTP_CLK_PER_NUM_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_PTP_CLK_PER_NUM_get", value );

    return value;
}
static INLINE void etime_field_range_PTP_CLK_PER_NUM_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_PTP_CLK_PER_NUM_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_PTP_CLK_PER_NUM_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_PTP_CLK_PER_NUM_set", stop_bit, 31 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_PTP_CLK_PER_NUM_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000016c bits 31:0) field PTP_CLK_PER_NUM of register PMC_ETIME120_REG_PTP_CLK_PER_NUM_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000016c bits 31:0) field PTP_CLK_PER_NUM of register PMC_ETIME120_REG_PTP_CLK_PER_NUM_REG */
        etime_reg_PTP_CLK_PER_NUM_REG_field_set( b_ptr,
                                                 h_ptr,
                                                 subfield_mask << (ETIME120_REG_PTP_CLK_PER_NUM_REG_BIT_PTP_CLK_PER_NUM_OFF + subfield_offset),
                                                 ETIME120_REG_PTP_CLK_PER_NUM_REG_BIT_PTP_CLK_PER_NUM_OFF + subfield_offset,
                                                 value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_PTP_CLK_PER_NUM_get( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_PTP_CLK_PER_NUM_get( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_PTP_CLK_PER_NUM_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_PTP_CLK_PER_NUM_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000016c bits 31:0) field PTP_CLK_PER_NUM of register PMC_ETIME120_REG_PTP_CLK_PER_NUM_REG */
    reg_value = etime_reg_PTP_CLK_PER_NUM_REG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_PTP_CLK_PER_NUM_REG_BIT_PTP_CLK_PER_NUM_MSK)
                  >> ETIME120_REG_PTP_CLK_PER_NUM_REG_BIT_PTP_CLK_PER_NUM_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_PTP_CLK_PER_NUM_REG_BIT_PTP_CLK_PER_NUM_MSK, ETIME120_REG_PTP_CLK_PER_NUM_REG_BIT_PTP_CLK_PER_NUM_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_PTP_CLK_PER_NUM_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_PTP_CLK_PER_DEN_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_PTP_CLK_PER_DEN_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    IOLOG( "%s <= 0x%08x", "etime_field_PTP_CLK_PER_DEN_set", value );

    /* (0x00000170 bits 31:0) field PTP_CLK_PER_DEN of register PMC_ETIME120_REG_PTP_CLK_PER_DEN_REG */
    etime_reg_PTP_CLK_PER_DEN_REG_field_set( b_ptr,
                                             h_ptr,
                                             ETIME120_REG_PTP_CLK_PER_DEN_REG_BIT_PTP_CLK_PER_DEN_MSK,
                                             ETIME120_REG_PTP_CLK_PER_DEN_REG_BIT_PTP_CLK_PER_DEN_OFF,
                                             value);
}

static INLINE UINT32 etime_field_PTP_CLK_PER_DEN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_PTP_CLK_PER_DEN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000170 bits 31:0) field PTP_CLK_PER_DEN of register PMC_ETIME120_REG_PTP_CLK_PER_DEN_REG */
    reg_value = etime_reg_PTP_CLK_PER_DEN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_PTP_CLK_PER_DEN_REG_BIT_PTP_CLK_PER_DEN_MSK) >> ETIME120_REG_PTP_CLK_PER_DEN_REG_BIT_PTP_CLK_PER_DEN_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_PTP_CLK_PER_DEN_get", value );

    return value;
}
static INLINE void etime_field_range_PTP_CLK_PER_DEN_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_PTP_CLK_PER_DEN_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_PTP_CLK_PER_DEN_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_PTP_CLK_PER_DEN_set", stop_bit, 31 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_PTP_CLK_PER_DEN_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000170 bits 31:0) field PTP_CLK_PER_DEN of register PMC_ETIME120_REG_PTP_CLK_PER_DEN_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000170 bits 31:0) field PTP_CLK_PER_DEN of register PMC_ETIME120_REG_PTP_CLK_PER_DEN_REG */
        etime_reg_PTP_CLK_PER_DEN_REG_field_set( b_ptr,
                                                 h_ptr,
                                                 subfield_mask << (ETIME120_REG_PTP_CLK_PER_DEN_REG_BIT_PTP_CLK_PER_DEN_OFF + subfield_offset),
                                                 ETIME120_REG_PTP_CLK_PER_DEN_REG_BIT_PTP_CLK_PER_DEN_OFF + subfield_offset,
                                                 value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_PTP_CLK_PER_DEN_get( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_PTP_CLK_PER_DEN_get( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_PTP_CLK_PER_DEN_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_PTP_CLK_PER_DEN_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000170 bits 31:0) field PTP_CLK_PER_DEN of register PMC_ETIME120_REG_PTP_CLK_PER_DEN_REG */
    reg_value = etime_reg_PTP_CLK_PER_DEN_REG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_PTP_CLK_PER_DEN_REG_BIT_PTP_CLK_PER_DEN_MSK)
                  >> ETIME120_REG_PTP_CLK_PER_DEN_REG_BIT_PTP_CLK_PER_DEN_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_PTP_CLK_PER_DEN_REG_BIT_PTP_CLK_PER_DEN_MSK, ETIME120_REG_PTP_CLK_PER_DEN_REG_BIT_PTP_CLK_PER_DEN_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_PTP_CLK_PER_DEN_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_OFFSET_UPD_QUANTA_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_OFFSET_UPD_QUANTA_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value )
{
    if (value > 1073741823)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_OFFSET_UPD_QUANTA_set", value, 1073741823);
    IOLOG( "%s <= 0x%08x", "etime_field_OFFSET_UPD_QUANTA_set", value );

    /* (0x00000174 bits 29:0) field OFFSET_UPD_QUANTA of register PMC_ETIME120_REG_OFFSET_UPD_QUANTA_REG */
    etime_reg_OFFSET_UPD_QUANTA_REG_field_set( b_ptr,
                                               h_ptr,
                                               ETIME120_REG_OFFSET_UPD_QUANTA_REG_BIT_OFFSET_UPD_QUANTA_MSK,
                                               ETIME120_REG_OFFSET_UPD_QUANTA_REG_BIT_OFFSET_UPD_QUANTA_OFF,
                                               value);
}

static INLINE UINT32 etime_field_OFFSET_UPD_QUANTA_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_OFFSET_UPD_QUANTA_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000174 bits 29:0) field OFFSET_UPD_QUANTA of register PMC_ETIME120_REG_OFFSET_UPD_QUANTA_REG */
    reg_value = etime_reg_OFFSET_UPD_QUANTA_REG_read( b_ptr,
                                                      h_ptr);
    value = (reg_value & ETIME120_REG_OFFSET_UPD_QUANTA_REG_BIT_OFFSET_UPD_QUANTA_MSK) >> ETIME120_REG_OFFSET_UPD_QUANTA_REG_BIT_OFFSET_UPD_QUANTA_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_OFFSET_UPD_QUANTA_get", value );

    return value;
}
static INLINE void etime_field_range_OFFSET_UPD_QUANTA_set( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_OFFSET_UPD_QUANTA_set( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit,
                                                            UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_OFFSET_UPD_QUANTA_set", stop_bit, start_bit );
    if (stop_bit > 29) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_OFFSET_UPD_QUANTA_set", stop_bit, 29 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_OFFSET_UPD_QUANTA_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000174 bits 29:0) field OFFSET_UPD_QUANTA of register PMC_ETIME120_REG_OFFSET_UPD_QUANTA_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 29) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 29;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000174 bits 29:0) field OFFSET_UPD_QUANTA of register PMC_ETIME120_REG_OFFSET_UPD_QUANTA_REG */
        etime_reg_OFFSET_UPD_QUANTA_REG_field_set( b_ptr,
                                                   h_ptr,
                                                   subfield_mask << (ETIME120_REG_OFFSET_UPD_QUANTA_REG_BIT_OFFSET_UPD_QUANTA_OFF + subfield_offset),
                                                   ETIME120_REG_OFFSET_UPD_QUANTA_REG_BIT_OFFSET_UPD_QUANTA_OFF + subfield_offset,
                                                   value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_OFFSET_UPD_QUANTA_get( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_OFFSET_UPD_QUANTA_get( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_OFFSET_UPD_QUANTA_get", stop_bit, start_bit );
    if (stop_bit > 29) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_OFFSET_UPD_QUANTA_get", stop_bit, 29 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 29) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 29;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000174 bits 29:0) field OFFSET_UPD_QUANTA of register PMC_ETIME120_REG_OFFSET_UPD_QUANTA_REG */
    reg_value = etime_reg_OFFSET_UPD_QUANTA_REG_read( b_ptr,
                                                      h_ptr);
    field_value = (reg_value & ETIME120_REG_OFFSET_UPD_QUANTA_REG_BIT_OFFSET_UPD_QUANTA_MSK)
                  >> ETIME120_REG_OFFSET_UPD_QUANTA_REG_BIT_OFFSET_UPD_QUANTA_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_OFFSET_UPD_QUANTA_REG_BIT_OFFSET_UPD_QUANTA_MSK, ETIME120_REG_OFFSET_UPD_QUANTA_REG_BIT_OFFSET_UPD_QUANTA_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_OFFSET_UPD_QUANTA_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_LINE_CLK_PER_INT_HI_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_LINE_CLK_PER_INT_HI_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value )
{
    IOLOG( "%s <= 0x%08x", "etime_field_LINE_CLK_PER_INT_HI_set", value );

    /* (0x00000178 bits 31:0) field LINE_CLK_PER_INT_HI of register PMC_ETIME120_REG_LINE_CLK_PER_INT_HI_REG */
    etime_reg_LINE_CLK_PER_INT_HI_REG_field_set( b_ptr,
                                                 h_ptr,
                                                 ETIME120_REG_LINE_CLK_PER_INT_HI_REG_BIT_LINE_CLK_PER_INT_HI_MSK,
                                                 ETIME120_REG_LINE_CLK_PER_INT_HI_REG_BIT_LINE_CLK_PER_INT_HI_OFF,
                                                 value);
}

static INLINE UINT32 etime_field_LINE_CLK_PER_INT_HI_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_LINE_CLK_PER_INT_HI_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000178 bits 31:0) field LINE_CLK_PER_INT_HI of register PMC_ETIME120_REG_LINE_CLK_PER_INT_HI_REG */
    reg_value = etime_reg_LINE_CLK_PER_INT_HI_REG_read( b_ptr,
                                                        h_ptr);
    value = (reg_value & ETIME120_REG_LINE_CLK_PER_INT_HI_REG_BIT_LINE_CLK_PER_INT_HI_MSK) >> ETIME120_REG_LINE_CLK_PER_INT_HI_REG_BIT_LINE_CLK_PER_INT_HI_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_LINE_CLK_PER_INT_HI_get", value );

    return value;
}
static INLINE void etime_field_range_LINE_CLK_PER_INT_HI_set( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_LINE_CLK_PER_INT_HI_set( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit,
                                                              UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_LINE_CLK_PER_INT_HI_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_LINE_CLK_PER_INT_HI_set", stop_bit, 31 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_LINE_CLK_PER_INT_HI_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000178 bits 31:0) field LINE_CLK_PER_INT_HI of register PMC_ETIME120_REG_LINE_CLK_PER_INT_HI_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000178 bits 31:0) field LINE_CLK_PER_INT_HI of register PMC_ETIME120_REG_LINE_CLK_PER_INT_HI_REG */
        etime_reg_LINE_CLK_PER_INT_HI_REG_field_set( b_ptr,
                                                     h_ptr,
                                                     subfield_mask << (ETIME120_REG_LINE_CLK_PER_INT_HI_REG_BIT_LINE_CLK_PER_INT_HI_OFF + subfield_offset),
                                                     ETIME120_REG_LINE_CLK_PER_INT_HI_REG_BIT_LINE_CLK_PER_INT_HI_OFF + subfield_offset,
                                                     value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_LINE_CLK_PER_INT_HI_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_LINE_CLK_PER_INT_HI_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_LINE_CLK_PER_INT_HI_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_LINE_CLK_PER_INT_HI_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000178 bits 31:0) field LINE_CLK_PER_INT_HI of register PMC_ETIME120_REG_LINE_CLK_PER_INT_HI_REG */
    reg_value = etime_reg_LINE_CLK_PER_INT_HI_REG_read( b_ptr,
                                                        h_ptr);
    field_value = (reg_value & ETIME120_REG_LINE_CLK_PER_INT_HI_REG_BIT_LINE_CLK_PER_INT_HI_MSK)
                  >> ETIME120_REG_LINE_CLK_PER_INT_HI_REG_BIT_LINE_CLK_PER_INT_HI_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_LINE_CLK_PER_INT_HI_REG_BIT_LINE_CLK_PER_INT_HI_MSK, ETIME120_REG_LINE_CLK_PER_INT_HI_REG_BIT_LINE_CLK_PER_INT_HI_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_LINE_CLK_PER_INT_HI_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_LINE_CLK_PER_INT_LO_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_LINE_CLK_PER_INT_LO_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value )
{
    IOLOG( "%s <= 0x%08x", "etime_field_LINE_CLK_PER_INT_LO_set", value );

    /* (0x0000017c bits 31:0) field LINE_CLK_PER_INT_LO of register PMC_ETIME120_REG_LINE_CLK_PER_INT_LO_REG */
    etime_reg_LINE_CLK_PER_INT_LO_REG_field_set( b_ptr,
                                                 h_ptr,
                                                 ETIME120_REG_LINE_CLK_PER_INT_LO_REG_BIT_LINE_CLK_PER_INT_LO_MSK,
                                                 ETIME120_REG_LINE_CLK_PER_INT_LO_REG_BIT_LINE_CLK_PER_INT_LO_OFF,
                                                 value);
}

static INLINE UINT32 etime_field_LINE_CLK_PER_INT_LO_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_LINE_CLK_PER_INT_LO_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000017c bits 31:0) field LINE_CLK_PER_INT_LO of register PMC_ETIME120_REG_LINE_CLK_PER_INT_LO_REG */
    reg_value = etime_reg_LINE_CLK_PER_INT_LO_REG_read( b_ptr,
                                                        h_ptr);
    value = (reg_value & ETIME120_REG_LINE_CLK_PER_INT_LO_REG_BIT_LINE_CLK_PER_INT_LO_MSK) >> ETIME120_REG_LINE_CLK_PER_INT_LO_REG_BIT_LINE_CLK_PER_INT_LO_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_LINE_CLK_PER_INT_LO_get", value );

    return value;
}
static INLINE void etime_field_range_LINE_CLK_PER_INT_LO_set( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_LINE_CLK_PER_INT_LO_set( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit,
                                                              UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_LINE_CLK_PER_INT_LO_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_LINE_CLK_PER_INT_LO_set", stop_bit, 31 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_LINE_CLK_PER_INT_LO_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000017c bits 31:0) field LINE_CLK_PER_INT_LO of register PMC_ETIME120_REG_LINE_CLK_PER_INT_LO_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000017c bits 31:0) field LINE_CLK_PER_INT_LO of register PMC_ETIME120_REG_LINE_CLK_PER_INT_LO_REG */
        etime_reg_LINE_CLK_PER_INT_LO_REG_field_set( b_ptr,
                                                     h_ptr,
                                                     subfield_mask << (ETIME120_REG_LINE_CLK_PER_INT_LO_REG_BIT_LINE_CLK_PER_INT_LO_OFF + subfield_offset),
                                                     ETIME120_REG_LINE_CLK_PER_INT_LO_REG_BIT_LINE_CLK_PER_INT_LO_OFF + subfield_offset,
                                                     value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_LINE_CLK_PER_INT_LO_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_LINE_CLK_PER_INT_LO_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_LINE_CLK_PER_INT_LO_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_LINE_CLK_PER_INT_LO_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000017c bits 31:0) field LINE_CLK_PER_INT_LO of register PMC_ETIME120_REG_LINE_CLK_PER_INT_LO_REG */
    reg_value = etime_reg_LINE_CLK_PER_INT_LO_REG_read( b_ptr,
                                                        h_ptr);
    field_value = (reg_value & ETIME120_REG_LINE_CLK_PER_INT_LO_REG_BIT_LINE_CLK_PER_INT_LO_MSK)
                  >> ETIME120_REG_LINE_CLK_PER_INT_LO_REG_BIT_LINE_CLK_PER_INT_LO_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_LINE_CLK_PER_INT_LO_REG_BIT_LINE_CLK_PER_INT_LO_MSK, ETIME120_REG_LINE_CLK_PER_INT_LO_REG_BIT_LINE_CLK_PER_INT_LO_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_LINE_CLK_PER_INT_LO_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_LINE_CLK_PER_NUM_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_LINE_CLK_PER_NUM_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    IOLOG( "%s <= 0x%08x", "etime_field_LINE_CLK_PER_NUM_set", value );

    /* (0x00000180 bits 31:0) field LINE_CLK_PER_NUM of register PMC_ETIME120_REG_LINE_CLK_PER_NUM_REG */
    etime_reg_LINE_CLK_PER_NUM_REG_field_set( b_ptr,
                                              h_ptr,
                                              ETIME120_REG_LINE_CLK_PER_NUM_REG_BIT_LINE_CLK_PER_NUM_MSK,
                                              ETIME120_REG_LINE_CLK_PER_NUM_REG_BIT_LINE_CLK_PER_NUM_OFF,
                                              value);
}

static INLINE UINT32 etime_field_LINE_CLK_PER_NUM_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_LINE_CLK_PER_NUM_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000180 bits 31:0) field LINE_CLK_PER_NUM of register PMC_ETIME120_REG_LINE_CLK_PER_NUM_REG */
    reg_value = etime_reg_LINE_CLK_PER_NUM_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_LINE_CLK_PER_NUM_REG_BIT_LINE_CLK_PER_NUM_MSK) >> ETIME120_REG_LINE_CLK_PER_NUM_REG_BIT_LINE_CLK_PER_NUM_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_LINE_CLK_PER_NUM_get", value );

    return value;
}
static INLINE void etime_field_range_LINE_CLK_PER_NUM_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_LINE_CLK_PER_NUM_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit,
                                                           UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_LINE_CLK_PER_NUM_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_LINE_CLK_PER_NUM_set", stop_bit, 31 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_LINE_CLK_PER_NUM_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000180 bits 31:0) field LINE_CLK_PER_NUM of register PMC_ETIME120_REG_LINE_CLK_PER_NUM_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000180 bits 31:0) field LINE_CLK_PER_NUM of register PMC_ETIME120_REG_LINE_CLK_PER_NUM_REG */
        etime_reg_LINE_CLK_PER_NUM_REG_field_set( b_ptr,
                                                  h_ptr,
                                                  subfield_mask << (ETIME120_REG_LINE_CLK_PER_NUM_REG_BIT_LINE_CLK_PER_NUM_OFF + subfield_offset),
                                                  ETIME120_REG_LINE_CLK_PER_NUM_REG_BIT_LINE_CLK_PER_NUM_OFF + subfield_offset,
                                                  value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_LINE_CLK_PER_NUM_get( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_LINE_CLK_PER_NUM_get( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_LINE_CLK_PER_NUM_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_LINE_CLK_PER_NUM_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000180 bits 31:0) field LINE_CLK_PER_NUM of register PMC_ETIME120_REG_LINE_CLK_PER_NUM_REG */
    reg_value = etime_reg_LINE_CLK_PER_NUM_REG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_LINE_CLK_PER_NUM_REG_BIT_LINE_CLK_PER_NUM_MSK)
                  >> ETIME120_REG_LINE_CLK_PER_NUM_REG_BIT_LINE_CLK_PER_NUM_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_LINE_CLK_PER_NUM_REG_BIT_LINE_CLK_PER_NUM_MSK, ETIME120_REG_LINE_CLK_PER_NUM_REG_BIT_LINE_CLK_PER_NUM_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_LINE_CLK_PER_NUM_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_LINE_CLK_PER_DEN_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_LINE_CLK_PER_DEN_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    IOLOG( "%s <= 0x%08x", "etime_field_LINE_CLK_PER_DEN_set", value );

    /* (0x00000184 bits 31:0) field LINE_CLK_PER_DEN of register PMC_ETIME120_REG_LINE_CLK_PER_DEN_REG */
    etime_reg_LINE_CLK_PER_DEN_REG_field_set( b_ptr,
                                              h_ptr,
                                              ETIME120_REG_LINE_CLK_PER_DEN_REG_BIT_LINE_CLK_PER_DEN_MSK,
                                              ETIME120_REG_LINE_CLK_PER_DEN_REG_BIT_LINE_CLK_PER_DEN_OFF,
                                              value);
}

static INLINE UINT32 etime_field_LINE_CLK_PER_DEN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_LINE_CLK_PER_DEN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000184 bits 31:0) field LINE_CLK_PER_DEN of register PMC_ETIME120_REG_LINE_CLK_PER_DEN_REG */
    reg_value = etime_reg_LINE_CLK_PER_DEN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_LINE_CLK_PER_DEN_REG_BIT_LINE_CLK_PER_DEN_MSK) >> ETIME120_REG_LINE_CLK_PER_DEN_REG_BIT_LINE_CLK_PER_DEN_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_LINE_CLK_PER_DEN_get", value );

    return value;
}
static INLINE void etime_field_range_LINE_CLK_PER_DEN_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_LINE_CLK_PER_DEN_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit,
                                                           UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_LINE_CLK_PER_DEN_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_LINE_CLK_PER_DEN_set", stop_bit, 31 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_LINE_CLK_PER_DEN_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000184 bits 31:0) field LINE_CLK_PER_DEN of register PMC_ETIME120_REG_LINE_CLK_PER_DEN_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000184 bits 31:0) field LINE_CLK_PER_DEN of register PMC_ETIME120_REG_LINE_CLK_PER_DEN_REG */
        etime_reg_LINE_CLK_PER_DEN_REG_field_set( b_ptr,
                                                  h_ptr,
                                                  subfield_mask << (ETIME120_REG_LINE_CLK_PER_DEN_REG_BIT_LINE_CLK_PER_DEN_OFF + subfield_offset),
                                                  ETIME120_REG_LINE_CLK_PER_DEN_REG_BIT_LINE_CLK_PER_DEN_OFF + subfield_offset,
                                                  value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_LINE_CLK_PER_DEN_get( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_LINE_CLK_PER_DEN_get( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_LINE_CLK_PER_DEN_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_LINE_CLK_PER_DEN_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000184 bits 31:0) field LINE_CLK_PER_DEN of register PMC_ETIME120_REG_LINE_CLK_PER_DEN_REG */
    reg_value = etime_reg_LINE_CLK_PER_DEN_REG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_LINE_CLK_PER_DEN_REG_BIT_LINE_CLK_PER_DEN_MSK)
                  >> ETIME120_REG_LINE_CLK_PER_DEN_REG_BIT_LINE_CLK_PER_DEN_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_LINE_CLK_PER_DEN_REG_BIT_LINE_CLK_PER_DEN_MSK, ETIME120_REG_LINE_CLK_PER_DEN_REG_BIT_LINE_CLK_PER_DEN_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_LINE_CLK_PER_DEN_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TX_VEC_IRIGO_4_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TX_VEC_IRIGO_4_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value )
{
    IOLOG( "%s <= 0x%08x", "etime_field_TX_VEC_IRIGO_4_set", value );

    /* (0x000001cc bits 31:0) field TX_VEC_IRIGO_4 of register PMC_ETIME120_REG_TX_VEC_IRIGO_4_REG */
    etime_reg_TX_VEC_IRIGO_4_REG_field_set( b_ptr,
                                            h_ptr,
                                            ETIME120_REG_TX_VEC_IRIGO_4_REG_BIT_TX_VEC_IRIGO_4_MSK,
                                            ETIME120_REG_TX_VEC_IRIGO_4_REG_BIT_TX_VEC_IRIGO_4_OFF,
                                            value);
}

static INLINE UINT32 etime_field_TX_VEC_IRIGO_4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TX_VEC_IRIGO_4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000001cc bits 31:0) field TX_VEC_IRIGO_4 of register PMC_ETIME120_REG_TX_VEC_IRIGO_4_REG */
    reg_value = etime_reg_TX_VEC_IRIGO_4_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TX_VEC_IRIGO_4_REG_BIT_TX_VEC_IRIGO_4_MSK) >> ETIME120_REG_TX_VEC_IRIGO_4_REG_BIT_TX_VEC_IRIGO_4_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TX_VEC_IRIGO_4_get", value );

    return value;
}
static INLINE void etime_field_range_TX_VEC_IRIGO_4_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TX_VEC_IRIGO_4_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TX_VEC_IRIGO_4_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TX_VEC_IRIGO_4_set", stop_bit, 31 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TX_VEC_IRIGO_4_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000001cc bits 31:0) field TX_VEC_IRIGO_4 of register PMC_ETIME120_REG_TX_VEC_IRIGO_4_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000001cc bits 31:0) field TX_VEC_IRIGO_4 of register PMC_ETIME120_REG_TX_VEC_IRIGO_4_REG */
        etime_reg_TX_VEC_IRIGO_4_REG_field_set( b_ptr,
                                                h_ptr,
                                                subfield_mask << (ETIME120_REG_TX_VEC_IRIGO_4_REG_BIT_TX_VEC_IRIGO_4_OFF + subfield_offset),
                                                ETIME120_REG_TX_VEC_IRIGO_4_REG_BIT_TX_VEC_IRIGO_4_OFF + subfield_offset,
                                                value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TX_VEC_IRIGO_4_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TX_VEC_IRIGO_4_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TX_VEC_IRIGO_4_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TX_VEC_IRIGO_4_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000001cc bits 31:0) field TX_VEC_IRIGO_4 of register PMC_ETIME120_REG_TX_VEC_IRIGO_4_REG */
    reg_value = etime_reg_TX_VEC_IRIGO_4_REG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TX_VEC_IRIGO_4_REG_BIT_TX_VEC_IRIGO_4_MSK)
                  >> ETIME120_REG_TX_VEC_IRIGO_4_REG_BIT_TX_VEC_IRIGO_4_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TX_VEC_IRIGO_4_REG_BIT_TX_VEC_IRIGO_4_MSK, ETIME120_REG_TX_VEC_IRIGO_4_REG_BIT_TX_VEC_IRIGO_4_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TX_VEC_IRIGO_4_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TX_VEC_IRIGO_3_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TX_VEC_IRIGO_3_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value )
{
    IOLOG( "%s <= 0x%08x", "etime_field_TX_VEC_IRIGO_3_set", value );

    /* (0x000001d0 bits 31:0) field TX_VEC_IRIGO_3 of register PMC_ETIME120_REG_TX_VEC_IRIGO_3_REG */
    etime_reg_TX_VEC_IRIGO_3_REG_field_set( b_ptr,
                                            h_ptr,
                                            ETIME120_REG_TX_VEC_IRIGO_3_REG_BIT_TX_VEC_IRIGO_3_MSK,
                                            ETIME120_REG_TX_VEC_IRIGO_3_REG_BIT_TX_VEC_IRIGO_3_OFF,
                                            value);
}

static INLINE UINT32 etime_field_TX_VEC_IRIGO_3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TX_VEC_IRIGO_3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000001d0 bits 31:0) field TX_VEC_IRIGO_3 of register PMC_ETIME120_REG_TX_VEC_IRIGO_3_REG */
    reg_value = etime_reg_TX_VEC_IRIGO_3_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TX_VEC_IRIGO_3_REG_BIT_TX_VEC_IRIGO_3_MSK) >> ETIME120_REG_TX_VEC_IRIGO_3_REG_BIT_TX_VEC_IRIGO_3_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TX_VEC_IRIGO_3_get", value );

    return value;
}
static INLINE void etime_field_range_TX_VEC_IRIGO_3_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TX_VEC_IRIGO_3_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TX_VEC_IRIGO_3_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TX_VEC_IRIGO_3_set", stop_bit, 31 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TX_VEC_IRIGO_3_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000001d0 bits 31:0) field TX_VEC_IRIGO_3 of register PMC_ETIME120_REG_TX_VEC_IRIGO_3_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000001d0 bits 31:0) field TX_VEC_IRIGO_3 of register PMC_ETIME120_REG_TX_VEC_IRIGO_3_REG */
        etime_reg_TX_VEC_IRIGO_3_REG_field_set( b_ptr,
                                                h_ptr,
                                                subfield_mask << (ETIME120_REG_TX_VEC_IRIGO_3_REG_BIT_TX_VEC_IRIGO_3_OFF + subfield_offset),
                                                ETIME120_REG_TX_VEC_IRIGO_3_REG_BIT_TX_VEC_IRIGO_3_OFF + subfield_offset,
                                                value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TX_VEC_IRIGO_3_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TX_VEC_IRIGO_3_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TX_VEC_IRIGO_3_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TX_VEC_IRIGO_3_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000001d0 bits 31:0) field TX_VEC_IRIGO_3 of register PMC_ETIME120_REG_TX_VEC_IRIGO_3_REG */
    reg_value = etime_reg_TX_VEC_IRIGO_3_REG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TX_VEC_IRIGO_3_REG_BIT_TX_VEC_IRIGO_3_MSK)
                  >> ETIME120_REG_TX_VEC_IRIGO_3_REG_BIT_TX_VEC_IRIGO_3_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TX_VEC_IRIGO_3_REG_BIT_TX_VEC_IRIGO_3_MSK, ETIME120_REG_TX_VEC_IRIGO_3_REG_BIT_TX_VEC_IRIGO_3_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TX_VEC_IRIGO_3_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TX_VEC_IRIGO_2_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TX_VEC_IRIGO_2_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value )
{
    IOLOG( "%s <= 0x%08x", "etime_field_TX_VEC_IRIGO_2_set", value );

    /* (0x000001d4 bits 31:0) field TX_VEC_IRIGO_2 of register PMC_ETIME120_REG_TX_VEC_IRIGO_2_REG */
    etime_reg_TX_VEC_IRIGO_2_REG_field_set( b_ptr,
                                            h_ptr,
                                            ETIME120_REG_TX_VEC_IRIGO_2_REG_BIT_TX_VEC_IRIGO_2_MSK,
                                            ETIME120_REG_TX_VEC_IRIGO_2_REG_BIT_TX_VEC_IRIGO_2_OFF,
                                            value);
}

static INLINE UINT32 etime_field_TX_VEC_IRIGO_2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TX_VEC_IRIGO_2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000001d4 bits 31:0) field TX_VEC_IRIGO_2 of register PMC_ETIME120_REG_TX_VEC_IRIGO_2_REG */
    reg_value = etime_reg_TX_VEC_IRIGO_2_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TX_VEC_IRIGO_2_REG_BIT_TX_VEC_IRIGO_2_MSK) >> ETIME120_REG_TX_VEC_IRIGO_2_REG_BIT_TX_VEC_IRIGO_2_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TX_VEC_IRIGO_2_get", value );

    return value;
}
static INLINE void etime_field_range_TX_VEC_IRIGO_2_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TX_VEC_IRIGO_2_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TX_VEC_IRIGO_2_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TX_VEC_IRIGO_2_set", stop_bit, 31 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TX_VEC_IRIGO_2_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000001d4 bits 31:0) field TX_VEC_IRIGO_2 of register PMC_ETIME120_REG_TX_VEC_IRIGO_2_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000001d4 bits 31:0) field TX_VEC_IRIGO_2 of register PMC_ETIME120_REG_TX_VEC_IRIGO_2_REG */
        etime_reg_TX_VEC_IRIGO_2_REG_field_set( b_ptr,
                                                h_ptr,
                                                subfield_mask << (ETIME120_REG_TX_VEC_IRIGO_2_REG_BIT_TX_VEC_IRIGO_2_OFF + subfield_offset),
                                                ETIME120_REG_TX_VEC_IRIGO_2_REG_BIT_TX_VEC_IRIGO_2_OFF + subfield_offset,
                                                value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TX_VEC_IRIGO_2_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TX_VEC_IRIGO_2_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TX_VEC_IRIGO_2_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TX_VEC_IRIGO_2_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000001d4 bits 31:0) field TX_VEC_IRIGO_2 of register PMC_ETIME120_REG_TX_VEC_IRIGO_2_REG */
    reg_value = etime_reg_TX_VEC_IRIGO_2_REG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TX_VEC_IRIGO_2_REG_BIT_TX_VEC_IRIGO_2_MSK)
                  >> ETIME120_REG_TX_VEC_IRIGO_2_REG_BIT_TX_VEC_IRIGO_2_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TX_VEC_IRIGO_2_REG_BIT_TX_VEC_IRIGO_2_MSK, ETIME120_REG_TX_VEC_IRIGO_2_REG_BIT_TX_VEC_IRIGO_2_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TX_VEC_IRIGO_2_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TX_VEC_IRIGO_1_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TX_VEC_IRIGO_1_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value )
{
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TX_VEC_IRIGO_1_set", value, 15);
    IOLOG( "%s <= 0x%08x", "etime_field_TX_VEC_IRIGO_1_set", value );

    /* (0x000001d8 bits 3:0) field TX_VEC_IRIGO_1 of register PMC_ETIME120_REG_TX_VEC_IRIGO_1_REG */
    etime_reg_TX_VEC_IRIGO_1_REG_field_set( b_ptr,
                                            h_ptr,
                                            ETIME120_REG_TX_VEC_IRIGO_1_REG_BIT_TX_VEC_IRIGO_1_MSK,
                                            ETIME120_REG_TX_VEC_IRIGO_1_REG_BIT_TX_VEC_IRIGO_1_OFF,
                                            value);
}

static INLINE UINT32 etime_field_TX_VEC_IRIGO_1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TX_VEC_IRIGO_1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000001d8 bits 3:0) field TX_VEC_IRIGO_1 of register PMC_ETIME120_REG_TX_VEC_IRIGO_1_REG */
    reg_value = etime_reg_TX_VEC_IRIGO_1_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TX_VEC_IRIGO_1_REG_BIT_TX_VEC_IRIGO_1_MSK) >> ETIME120_REG_TX_VEC_IRIGO_1_REG_BIT_TX_VEC_IRIGO_1_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TX_VEC_IRIGO_1_get", value );

    return value;
}
static INLINE void etime_field_range_TX_VEC_IRIGO_1_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TX_VEC_IRIGO_1_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TX_VEC_IRIGO_1_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TX_VEC_IRIGO_1_set", stop_bit, 3 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TX_VEC_IRIGO_1_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000001d8 bits 3:0) field TX_VEC_IRIGO_1 of register PMC_ETIME120_REG_TX_VEC_IRIGO_1_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000001d8 bits 3:0) field TX_VEC_IRIGO_1 of register PMC_ETIME120_REG_TX_VEC_IRIGO_1_REG */
        etime_reg_TX_VEC_IRIGO_1_REG_field_set( b_ptr,
                                                h_ptr,
                                                subfield_mask << (ETIME120_REG_TX_VEC_IRIGO_1_REG_BIT_TX_VEC_IRIGO_1_OFF + subfield_offset),
                                                ETIME120_REG_TX_VEC_IRIGO_1_REG_BIT_TX_VEC_IRIGO_1_OFF + subfield_offset,
                                                value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TX_VEC_IRIGO_1_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TX_VEC_IRIGO_1_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TX_VEC_IRIGO_1_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TX_VEC_IRIGO_1_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000001d8 bits 3:0) field TX_VEC_IRIGO_1 of register PMC_ETIME120_REG_TX_VEC_IRIGO_1_REG */
    reg_value = etime_reg_TX_VEC_IRIGO_1_REG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TX_VEC_IRIGO_1_REG_BIT_TX_VEC_IRIGO_1_MSK)
                  >> ETIME120_REG_TX_VEC_IRIGO_1_REG_BIT_TX_VEC_IRIGO_1_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TX_VEC_IRIGO_1_REG_BIT_TX_VEC_IRIGO_1_MSK, ETIME120_REG_TX_VEC_IRIGO_1_REG_BIT_TX_VEC_IRIGO_1_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TX_VEC_IRIGO_1_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_IRIGI_1PPS_DET_MODE_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGI_1PPS_DET_MODE_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGI_1PPS_DET_MODE_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGI_1PPS_DET_MODE_set", value );

    /* (0x000001ec bits 3) field IRIGI_1PPS_DET_MODE of register PMC_ETIME120_REG_IRIGI_CFG */
    etime_reg_IRIGI_CFG_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_IRIGI_CFG_BIT_IRIGI_1PPS_DET_MODE_MSK,
                                   ETIME120_REG_IRIGI_CFG_BIT_IRIGI_1PPS_DET_MODE_OFF,
                                   value);
}

static INLINE UINT32 etime_field_IRIGI_1PPS_DET_MODE_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_1PPS_DET_MODE_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000001ec bits 3) field IRIGI_1PPS_DET_MODE of register PMC_ETIME120_REG_IRIGI_CFG */
    reg_value = etime_reg_IRIGI_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_IRIGI_CFG_BIT_IRIGI_1PPS_DET_MODE_MSK) >> ETIME120_REG_IRIGI_CFG_BIT_IRIGI_1PPS_DET_MODE_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_1PPS_DET_MODE_get", value );

    return value;
}
static INLINE void etime_field_IRIGI_MODE_set( etime_buffer_t *b_ptr,
                                               etime_handle_t *h_ptr,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGI_MODE_set( etime_buffer_t *b_ptr,
                                               etime_handle_t *h_ptr,
                                               UINT32 value )
{
    if (value > 3)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGI_MODE_set", value, 3);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGI_MODE_set", value );

    /* (0x000001ec bits 2:1) field IRIGI_MODE of register PMC_ETIME120_REG_IRIGI_CFG */
    etime_reg_IRIGI_CFG_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_IRIGI_CFG_BIT_IRIGI_MODE_MSK,
                                   ETIME120_REG_IRIGI_CFG_BIT_IRIGI_MODE_OFF,
                                   value);
}

static INLINE UINT32 etime_field_IRIGI_MODE_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_MODE_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000001ec bits 2:1) field IRIGI_MODE of register PMC_ETIME120_REG_IRIGI_CFG */
    reg_value = etime_reg_IRIGI_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_IRIGI_CFG_BIT_IRIGI_MODE_MSK) >> ETIME120_REG_IRIGI_CFG_BIT_IRIGI_MODE_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_MODE_get", value );

    return value;
}
static INLINE void etime_field_range_IRIGI_MODE_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 start_bit,
                                                     UINT32 stop_bit,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_IRIGI_MODE_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 start_bit,
                                                     UINT32 stop_bit,
                                                     UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGI_MODE_set", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGI_MODE_set", stop_bit, 1 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGI_MODE_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000001ec bits 2:1) field IRIGI_MODE of register PMC_ETIME120_REG_IRIGI_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 1) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 1;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000001ec bits 2:1) field IRIGI_MODE of register PMC_ETIME120_REG_IRIGI_CFG */
        etime_reg_IRIGI_CFG_field_set( b_ptr,
                                       h_ptr,
                                       subfield_mask << (ETIME120_REG_IRIGI_CFG_BIT_IRIGI_MODE_OFF + subfield_offset),
                                       ETIME120_REG_IRIGI_CFG_BIT_IRIGI_MODE_OFF + subfield_offset,
                                       value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_IRIGI_MODE_get( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_IRIGI_MODE_get( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGI_MODE_get", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGI_MODE_get", stop_bit, 1 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 1) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 1;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000001ec bits 2:1) field IRIGI_MODE of register PMC_ETIME120_REG_IRIGI_CFG */
    reg_value = etime_reg_IRIGI_CFG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_IRIGI_CFG_BIT_IRIGI_MODE_MSK)
                  >> ETIME120_REG_IRIGI_CFG_BIT_IRIGI_MODE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_IRIGI_CFG_BIT_IRIGI_MODE_MSK, ETIME120_REG_IRIGI_CFG_BIT_IRIGI_MODE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGI_MODE_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_IRIGI_ENA_set( etime_buffer_t *b_ptr,
                                              etime_handle_t *h_ptr,
                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGI_ENA_set( etime_buffer_t *b_ptr,
                                              etime_handle_t *h_ptr,
                                              UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGI_ENA_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGI_ENA_set", value );

    /* (0x000001ec bits 0) field IRIGI_ENA of register PMC_ETIME120_REG_IRIGI_CFG */
    etime_reg_IRIGI_CFG_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_IRIGI_CFG_BIT_IRIGI_ENA_MSK,
                                   ETIME120_REG_IRIGI_CFG_BIT_IRIGI_ENA_OFF,
                                   value);
}

static INLINE UINT32 etime_field_IRIGI_ENA_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_ENA_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000001ec bits 0) field IRIGI_ENA of register PMC_ETIME120_REG_IRIGI_CFG */
    reg_value = etime_reg_IRIGI_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_IRIGI_CFG_BIT_IRIGI_ENA_MSK) >> ETIME120_REG_IRIGI_CFG_BIT_IRIGI_ENA_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_ENA_get", value );

    return value;
}
static INLINE void etime_field_IRIGI_PWM_WIDTH_ZERO_CFG_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGI_PWM_WIDTH_ZERO_CFG_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value )
{
    if (value > 4194303)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGI_PWM_WIDTH_ZERO_CFG_set", value, 4194303);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGI_PWM_WIDTH_ZERO_CFG_set", value );

    /* (0x000001f0 bits 21:0) field IRIGI_PWM_WIDTH_ZERO_CFG of register PMC_ETIME120_REG_IRIGI_PWM_ZERO_REG */
    etime_reg_IRIGI_PWM_ZERO_REG_field_set( b_ptr,
                                            h_ptr,
                                            ETIME120_REG_IRIGI_PWM_ZERO_REG_BIT_IRIGI_PWM_WIDTH_ZERO_CFG_MSK,
                                            ETIME120_REG_IRIGI_PWM_ZERO_REG_BIT_IRIGI_PWM_WIDTH_ZERO_CFG_OFF,
                                            value);
}

static INLINE UINT32 etime_field_IRIGI_PWM_WIDTH_ZERO_CFG_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_PWM_WIDTH_ZERO_CFG_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000001f0 bits 21:0) field IRIGI_PWM_WIDTH_ZERO_CFG of register PMC_ETIME120_REG_IRIGI_PWM_ZERO_REG */
    reg_value = etime_reg_IRIGI_PWM_ZERO_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_IRIGI_PWM_ZERO_REG_BIT_IRIGI_PWM_WIDTH_ZERO_CFG_MSK) >> ETIME120_REG_IRIGI_PWM_ZERO_REG_BIT_IRIGI_PWM_WIDTH_ZERO_CFG_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_PWM_WIDTH_ZERO_CFG_get", value );

    return value;
}
static INLINE void etime_field_range_IRIGI_PWM_WIDTH_ZERO_CFG_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_IRIGI_PWM_WIDTH_ZERO_CFG_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGI_PWM_WIDTH_ZERO_CFG_set", stop_bit, start_bit );
    if (stop_bit > 21) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGI_PWM_WIDTH_ZERO_CFG_set", stop_bit, 21 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGI_PWM_WIDTH_ZERO_CFG_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000001f0 bits 21:0) field IRIGI_PWM_WIDTH_ZERO_CFG of register PMC_ETIME120_REG_IRIGI_PWM_ZERO_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 21) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 21;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000001f0 bits 21:0) field IRIGI_PWM_WIDTH_ZERO_CFG of register PMC_ETIME120_REG_IRIGI_PWM_ZERO_REG */
        etime_reg_IRIGI_PWM_ZERO_REG_field_set( b_ptr,
                                                h_ptr,
                                                subfield_mask << (ETIME120_REG_IRIGI_PWM_ZERO_REG_BIT_IRIGI_PWM_WIDTH_ZERO_CFG_OFF + subfield_offset),
                                                ETIME120_REG_IRIGI_PWM_ZERO_REG_BIT_IRIGI_PWM_WIDTH_ZERO_CFG_OFF + subfield_offset,
                                                value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_IRIGI_PWM_WIDTH_ZERO_CFG_get( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_IRIGI_PWM_WIDTH_ZERO_CFG_get( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGI_PWM_WIDTH_ZERO_CFG_get", stop_bit, start_bit );
    if (stop_bit > 21) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGI_PWM_WIDTH_ZERO_CFG_get", stop_bit, 21 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 21) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 21;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000001f0 bits 21:0) field IRIGI_PWM_WIDTH_ZERO_CFG of register PMC_ETIME120_REG_IRIGI_PWM_ZERO_REG */
    reg_value = etime_reg_IRIGI_PWM_ZERO_REG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_IRIGI_PWM_ZERO_REG_BIT_IRIGI_PWM_WIDTH_ZERO_CFG_MSK)
                  >> ETIME120_REG_IRIGI_PWM_ZERO_REG_BIT_IRIGI_PWM_WIDTH_ZERO_CFG_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_IRIGI_PWM_ZERO_REG_BIT_IRIGI_PWM_WIDTH_ZERO_CFG_MSK, ETIME120_REG_IRIGI_PWM_ZERO_REG_BIT_IRIGI_PWM_WIDTH_ZERO_CFG_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGI_PWM_WIDTH_ZERO_CFG_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_IRIGI_PWM_WIDTH_ONE_CFG_set( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGI_PWM_WIDTH_ONE_CFG_set( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 value )
{
    if (value > 4194303)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGI_PWM_WIDTH_ONE_CFG_set", value, 4194303);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGI_PWM_WIDTH_ONE_CFG_set", value );

    /* (0x000001f4 bits 21:0) field IRIGI_PWM_WIDTH_ONE_CFG of register PMC_ETIME120_REG_IRIGI_PWM_ONE_REG */
    etime_reg_IRIGI_PWM_ONE_REG_field_set( b_ptr,
                                           h_ptr,
                                           ETIME120_REG_IRIGI_PWM_ONE_REG_BIT_IRIGI_PWM_WIDTH_ONE_CFG_MSK,
                                           ETIME120_REG_IRIGI_PWM_ONE_REG_BIT_IRIGI_PWM_WIDTH_ONE_CFG_OFF,
                                           value);
}

static INLINE UINT32 etime_field_IRIGI_PWM_WIDTH_ONE_CFG_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_PWM_WIDTH_ONE_CFG_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000001f4 bits 21:0) field IRIGI_PWM_WIDTH_ONE_CFG of register PMC_ETIME120_REG_IRIGI_PWM_ONE_REG */
    reg_value = etime_reg_IRIGI_PWM_ONE_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_IRIGI_PWM_ONE_REG_BIT_IRIGI_PWM_WIDTH_ONE_CFG_MSK) >> ETIME120_REG_IRIGI_PWM_ONE_REG_BIT_IRIGI_PWM_WIDTH_ONE_CFG_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_PWM_WIDTH_ONE_CFG_get", value );

    return value;
}
static INLINE void etime_field_range_IRIGI_PWM_WIDTH_ONE_CFG_set( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_IRIGI_PWM_WIDTH_ONE_CFG_set( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGI_PWM_WIDTH_ONE_CFG_set", stop_bit, start_bit );
    if (stop_bit > 21) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGI_PWM_WIDTH_ONE_CFG_set", stop_bit, 21 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGI_PWM_WIDTH_ONE_CFG_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000001f4 bits 21:0) field IRIGI_PWM_WIDTH_ONE_CFG of register PMC_ETIME120_REG_IRIGI_PWM_ONE_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 21) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 21;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000001f4 bits 21:0) field IRIGI_PWM_WIDTH_ONE_CFG of register PMC_ETIME120_REG_IRIGI_PWM_ONE_REG */
        etime_reg_IRIGI_PWM_ONE_REG_field_set( b_ptr,
                                               h_ptr,
                                               subfield_mask << (ETIME120_REG_IRIGI_PWM_ONE_REG_BIT_IRIGI_PWM_WIDTH_ONE_CFG_OFF + subfield_offset),
                                               ETIME120_REG_IRIGI_PWM_ONE_REG_BIT_IRIGI_PWM_WIDTH_ONE_CFG_OFF + subfield_offset,
                                               value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_IRIGI_PWM_WIDTH_ONE_CFG_get( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_IRIGI_PWM_WIDTH_ONE_CFG_get( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGI_PWM_WIDTH_ONE_CFG_get", stop_bit, start_bit );
    if (stop_bit > 21) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGI_PWM_WIDTH_ONE_CFG_get", stop_bit, 21 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 21) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 21;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000001f4 bits 21:0) field IRIGI_PWM_WIDTH_ONE_CFG of register PMC_ETIME120_REG_IRIGI_PWM_ONE_REG */
    reg_value = etime_reg_IRIGI_PWM_ONE_REG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_IRIGI_PWM_ONE_REG_BIT_IRIGI_PWM_WIDTH_ONE_CFG_MSK)
                  >> ETIME120_REG_IRIGI_PWM_ONE_REG_BIT_IRIGI_PWM_WIDTH_ONE_CFG_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_IRIGI_PWM_ONE_REG_BIT_IRIGI_PWM_WIDTH_ONE_CFG_MSK, ETIME120_REG_IRIGI_PWM_ONE_REG_BIT_IRIGI_PWM_WIDTH_ONE_CFG_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGI_PWM_WIDTH_ONE_CFG_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_IRIGI_PWM_WIDTH_PX_CFG_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGI_PWM_WIDTH_PX_CFG_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value )
{
    if (value > 4194303)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGI_PWM_WIDTH_PX_CFG_set", value, 4194303);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGI_PWM_WIDTH_PX_CFG_set", value );

    /* (0x000001f8 bits 21:0) field IRIGI_PWM_WIDTH_PX_CFG of register PMC_ETIME120_REG_IRIGI_PWM_WIDTH_PX_REG */
    etime_reg_IRIGI_PWM_WIDTH_PX_REG_field_set( b_ptr,
                                                h_ptr,
                                                ETIME120_REG_IRIGI_PWM_WIDTH_PX_REG_BIT_IRIGI_PWM_WIDTH_PX_CFG_MSK,
                                                ETIME120_REG_IRIGI_PWM_WIDTH_PX_REG_BIT_IRIGI_PWM_WIDTH_PX_CFG_OFF,
                                                value);
}

static INLINE UINT32 etime_field_IRIGI_PWM_WIDTH_PX_CFG_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_PWM_WIDTH_PX_CFG_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000001f8 bits 21:0) field IRIGI_PWM_WIDTH_PX_CFG of register PMC_ETIME120_REG_IRIGI_PWM_WIDTH_PX_REG */
    reg_value = etime_reg_IRIGI_PWM_WIDTH_PX_REG_read( b_ptr,
                                                       h_ptr);
    value = (reg_value & ETIME120_REG_IRIGI_PWM_WIDTH_PX_REG_BIT_IRIGI_PWM_WIDTH_PX_CFG_MSK) >> ETIME120_REG_IRIGI_PWM_WIDTH_PX_REG_BIT_IRIGI_PWM_WIDTH_PX_CFG_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_PWM_WIDTH_PX_CFG_get", value );

    return value;
}
static INLINE void etime_field_range_IRIGI_PWM_WIDTH_PX_CFG_set( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_IRIGI_PWM_WIDTH_PX_CFG_set( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGI_PWM_WIDTH_PX_CFG_set", stop_bit, start_bit );
    if (stop_bit > 21) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGI_PWM_WIDTH_PX_CFG_set", stop_bit, 21 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGI_PWM_WIDTH_PX_CFG_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000001f8 bits 21:0) field IRIGI_PWM_WIDTH_PX_CFG of register PMC_ETIME120_REG_IRIGI_PWM_WIDTH_PX_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 21) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 21;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000001f8 bits 21:0) field IRIGI_PWM_WIDTH_PX_CFG of register PMC_ETIME120_REG_IRIGI_PWM_WIDTH_PX_REG */
        etime_reg_IRIGI_PWM_WIDTH_PX_REG_field_set( b_ptr,
                                                    h_ptr,
                                                    subfield_mask << (ETIME120_REG_IRIGI_PWM_WIDTH_PX_REG_BIT_IRIGI_PWM_WIDTH_PX_CFG_OFF + subfield_offset),
                                                    ETIME120_REG_IRIGI_PWM_WIDTH_PX_REG_BIT_IRIGI_PWM_WIDTH_PX_CFG_OFF + subfield_offset,
                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_IRIGI_PWM_WIDTH_PX_CFG_get( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_IRIGI_PWM_WIDTH_PX_CFG_get( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGI_PWM_WIDTH_PX_CFG_get", stop_bit, start_bit );
    if (stop_bit > 21) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGI_PWM_WIDTH_PX_CFG_get", stop_bit, 21 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 21) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 21;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000001f8 bits 21:0) field IRIGI_PWM_WIDTH_PX_CFG of register PMC_ETIME120_REG_IRIGI_PWM_WIDTH_PX_REG */
    reg_value = etime_reg_IRIGI_PWM_WIDTH_PX_REG_read( b_ptr,
                                                       h_ptr);
    field_value = (reg_value & ETIME120_REG_IRIGI_PWM_WIDTH_PX_REG_BIT_IRIGI_PWM_WIDTH_PX_CFG_MSK)
                  >> ETIME120_REG_IRIGI_PWM_WIDTH_PX_REG_BIT_IRIGI_PWM_WIDTH_PX_CFG_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_IRIGI_PWM_WIDTH_PX_REG_BIT_IRIGI_PWM_WIDTH_PX_CFG_MSK, ETIME120_REG_IRIGI_PWM_WIDTH_PX_REG_BIT_IRIGI_PWM_WIDTH_PX_CFG_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGI_PWM_WIDTH_PX_CFG_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_IRIGI_PWM_MIN_DIFF_CFG_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGI_PWM_MIN_DIFF_CFG_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value )
{
    if (value > 2097151)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGI_PWM_MIN_DIFF_CFG_set", value, 2097151);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGI_PWM_MIN_DIFF_CFG_set", value );

    /* (0x000001fc bits 20:0) field IRIGI_PWM_MIN_DIFF_CFG of register PMC_ETIME120_REG_IRIGI_PWM_MIN_DIFF_CFG_REG */
    etime_reg_IRIGI_PWM_MIN_DIFF_CFG_REG_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_IRIGI_PWM_MIN_DIFF_CFG_REG_BIT_IRIGI_PWM_MIN_DIFF_CFG_MSK,
                                                    ETIME120_REG_IRIGI_PWM_MIN_DIFF_CFG_REG_BIT_IRIGI_PWM_MIN_DIFF_CFG_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_IRIGI_PWM_MIN_DIFF_CFG_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_PWM_MIN_DIFF_CFG_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000001fc bits 20:0) field IRIGI_PWM_MIN_DIFF_CFG of register PMC_ETIME120_REG_IRIGI_PWM_MIN_DIFF_CFG_REG */
    reg_value = etime_reg_IRIGI_PWM_MIN_DIFF_CFG_REG_read( b_ptr,
                                                           h_ptr);
    value = (reg_value & ETIME120_REG_IRIGI_PWM_MIN_DIFF_CFG_REG_BIT_IRIGI_PWM_MIN_DIFF_CFG_MSK) >> ETIME120_REG_IRIGI_PWM_MIN_DIFF_CFG_REG_BIT_IRIGI_PWM_MIN_DIFF_CFG_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_PWM_MIN_DIFF_CFG_get", value );

    return value;
}
static INLINE void etime_field_range_IRIGI_PWM_MIN_DIFF_CFG_set( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_IRIGI_PWM_MIN_DIFF_CFG_set( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGI_PWM_MIN_DIFF_CFG_set", stop_bit, start_bit );
    if (stop_bit > 20) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGI_PWM_MIN_DIFF_CFG_set", stop_bit, 20 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGI_PWM_MIN_DIFF_CFG_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000001fc bits 20:0) field IRIGI_PWM_MIN_DIFF_CFG of register PMC_ETIME120_REG_IRIGI_PWM_MIN_DIFF_CFG_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 20) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 20;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000001fc bits 20:0) field IRIGI_PWM_MIN_DIFF_CFG of register PMC_ETIME120_REG_IRIGI_PWM_MIN_DIFF_CFG_REG */
        etime_reg_IRIGI_PWM_MIN_DIFF_CFG_REG_field_set( b_ptr,
                                                        h_ptr,
                                                        subfield_mask << (ETIME120_REG_IRIGI_PWM_MIN_DIFF_CFG_REG_BIT_IRIGI_PWM_MIN_DIFF_CFG_OFF + subfield_offset),
                                                        ETIME120_REG_IRIGI_PWM_MIN_DIFF_CFG_REG_BIT_IRIGI_PWM_MIN_DIFF_CFG_OFF + subfield_offset,
                                                        value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_IRIGI_PWM_MIN_DIFF_CFG_get( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_IRIGI_PWM_MIN_DIFF_CFG_get( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGI_PWM_MIN_DIFF_CFG_get", stop_bit, start_bit );
    if (stop_bit > 20) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGI_PWM_MIN_DIFF_CFG_get", stop_bit, 20 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 20) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 20;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000001fc bits 20:0) field IRIGI_PWM_MIN_DIFF_CFG of register PMC_ETIME120_REG_IRIGI_PWM_MIN_DIFF_CFG_REG */
    reg_value = etime_reg_IRIGI_PWM_MIN_DIFF_CFG_REG_read( b_ptr,
                                                           h_ptr);
    field_value = (reg_value & ETIME120_REG_IRIGI_PWM_MIN_DIFF_CFG_REG_BIT_IRIGI_PWM_MIN_DIFF_CFG_MSK)
                  >> ETIME120_REG_IRIGI_PWM_MIN_DIFF_CFG_REG_BIT_IRIGI_PWM_MIN_DIFF_CFG_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_IRIGI_PWM_MIN_DIFF_CFG_REG_BIT_IRIGI_PWM_MIN_DIFF_CFG_MSK, ETIME120_REG_IRIGI_PWM_MIN_DIFF_CFG_REG_BIT_IRIGI_PWM_MIN_DIFF_CFG_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGI_PWM_MIN_DIFF_CFG_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_IRIGI_PWM_MAX_DIFF_CFG_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGI_PWM_MAX_DIFF_CFG_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value )
{
    if (value > 2097151)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGI_PWM_MAX_DIFF_CFG_set", value, 2097151);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGI_PWM_MAX_DIFF_CFG_set", value );

    /* (0x00000200 bits 20:0) field IRIGI_PWM_MAX_DIFF_CFG of register PMC_ETIME120_REG_IRIGI_PWM_MAX_DIFF_CFG_REG */
    etime_reg_IRIGI_PWM_MAX_DIFF_CFG_REG_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_IRIGI_PWM_MAX_DIFF_CFG_REG_BIT_IRIGI_PWM_MAX_DIFF_CFG_MSK,
                                                    ETIME120_REG_IRIGI_PWM_MAX_DIFF_CFG_REG_BIT_IRIGI_PWM_MAX_DIFF_CFG_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_IRIGI_PWM_MAX_DIFF_CFG_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_PWM_MAX_DIFF_CFG_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000200 bits 20:0) field IRIGI_PWM_MAX_DIFF_CFG of register PMC_ETIME120_REG_IRIGI_PWM_MAX_DIFF_CFG_REG */
    reg_value = etime_reg_IRIGI_PWM_MAX_DIFF_CFG_REG_read( b_ptr,
                                                           h_ptr);
    value = (reg_value & ETIME120_REG_IRIGI_PWM_MAX_DIFF_CFG_REG_BIT_IRIGI_PWM_MAX_DIFF_CFG_MSK) >> ETIME120_REG_IRIGI_PWM_MAX_DIFF_CFG_REG_BIT_IRIGI_PWM_MAX_DIFF_CFG_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_PWM_MAX_DIFF_CFG_get", value );

    return value;
}
static INLINE void etime_field_range_IRIGI_PWM_MAX_DIFF_CFG_set( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_IRIGI_PWM_MAX_DIFF_CFG_set( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGI_PWM_MAX_DIFF_CFG_set", stop_bit, start_bit );
    if (stop_bit > 20) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGI_PWM_MAX_DIFF_CFG_set", stop_bit, 20 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGI_PWM_MAX_DIFF_CFG_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000200 bits 20:0) field IRIGI_PWM_MAX_DIFF_CFG of register PMC_ETIME120_REG_IRIGI_PWM_MAX_DIFF_CFG_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 20) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 20;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000200 bits 20:0) field IRIGI_PWM_MAX_DIFF_CFG of register PMC_ETIME120_REG_IRIGI_PWM_MAX_DIFF_CFG_REG */
        etime_reg_IRIGI_PWM_MAX_DIFF_CFG_REG_field_set( b_ptr,
                                                        h_ptr,
                                                        subfield_mask << (ETIME120_REG_IRIGI_PWM_MAX_DIFF_CFG_REG_BIT_IRIGI_PWM_MAX_DIFF_CFG_OFF + subfield_offset),
                                                        ETIME120_REG_IRIGI_PWM_MAX_DIFF_CFG_REG_BIT_IRIGI_PWM_MAX_DIFF_CFG_OFF + subfield_offset,
                                                        value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_IRIGI_PWM_MAX_DIFF_CFG_get( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_IRIGI_PWM_MAX_DIFF_CFG_get( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGI_PWM_MAX_DIFF_CFG_get", stop_bit, start_bit );
    if (stop_bit > 20) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGI_PWM_MAX_DIFF_CFG_get", stop_bit, 20 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 20) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 20;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000200 bits 20:0) field IRIGI_PWM_MAX_DIFF_CFG of register PMC_ETIME120_REG_IRIGI_PWM_MAX_DIFF_CFG_REG */
    reg_value = etime_reg_IRIGI_PWM_MAX_DIFF_CFG_REG_read( b_ptr,
                                                           h_ptr);
    field_value = (reg_value & ETIME120_REG_IRIGI_PWM_MAX_DIFF_CFG_REG_BIT_IRIGI_PWM_MAX_DIFF_CFG_MSK)
                  >> ETIME120_REG_IRIGI_PWM_MAX_DIFF_CFG_REG_BIT_IRIGI_PWM_MAX_DIFF_CFG_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_IRIGI_PWM_MAX_DIFF_CFG_REG_BIT_IRIGI_PWM_MAX_DIFF_CFG_MSK, ETIME120_REG_IRIGI_PWM_MAX_DIFF_CFG_REG_BIT_IRIGI_PWM_MAX_DIFF_CFG_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGI_PWM_MAX_DIFF_CFG_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_IRIGI_DATI_IDLE_DURATION_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGI_DATI_IDLE_DURATION_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value )
{
    if (value > 268435455)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGI_DATI_IDLE_DURATION_set", value, 268435455);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGI_DATI_IDLE_DURATION_set", value );

    /* (0x00000204 bits 27:0) field IRIGI_DATI_IDLE_DURATION of register PMC_ETIME120_REG_IRIGI_DATI_IDLE_DURATION */
    etime_reg_IRIGI_DATI_IDLE_DURATION_field_set( b_ptr,
                                                  h_ptr,
                                                  ETIME120_REG_IRIGI_DATI_IDLE_DURATION_BIT_IRIGI_DATI_IDLE_DURATION_MSK,
                                                  ETIME120_REG_IRIGI_DATI_IDLE_DURATION_BIT_IRIGI_DATI_IDLE_DURATION_OFF,
                                                  value);
}

static INLINE UINT32 etime_field_IRIGI_DATI_IDLE_DURATION_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_DATI_IDLE_DURATION_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000204 bits 27:0) field IRIGI_DATI_IDLE_DURATION of register PMC_ETIME120_REG_IRIGI_DATI_IDLE_DURATION */
    reg_value = etime_reg_IRIGI_DATI_IDLE_DURATION_read( b_ptr,
                                                         h_ptr);
    value = (reg_value & ETIME120_REG_IRIGI_DATI_IDLE_DURATION_BIT_IRIGI_DATI_IDLE_DURATION_MSK) >> ETIME120_REG_IRIGI_DATI_IDLE_DURATION_BIT_IRIGI_DATI_IDLE_DURATION_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_DATI_IDLE_DURATION_get", value );

    return value;
}
static INLINE void etime_field_range_IRIGI_DATI_IDLE_DURATION_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_IRIGI_DATI_IDLE_DURATION_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGI_DATI_IDLE_DURATION_set", stop_bit, start_bit );
    if (stop_bit > 27) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGI_DATI_IDLE_DURATION_set", stop_bit, 27 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGI_DATI_IDLE_DURATION_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000204 bits 27:0) field IRIGI_DATI_IDLE_DURATION of register PMC_ETIME120_REG_IRIGI_DATI_IDLE_DURATION */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 27) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 27;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000204 bits 27:0) field IRIGI_DATI_IDLE_DURATION of register PMC_ETIME120_REG_IRIGI_DATI_IDLE_DURATION */
        etime_reg_IRIGI_DATI_IDLE_DURATION_field_set( b_ptr,
                                                      h_ptr,
                                                      subfield_mask << (ETIME120_REG_IRIGI_DATI_IDLE_DURATION_BIT_IRIGI_DATI_IDLE_DURATION_OFF + subfield_offset),
                                                      ETIME120_REG_IRIGI_DATI_IDLE_DURATION_BIT_IRIGI_DATI_IDLE_DURATION_OFF + subfield_offset,
                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_IRIGI_DATI_IDLE_DURATION_get( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_IRIGI_DATI_IDLE_DURATION_get( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGI_DATI_IDLE_DURATION_get", stop_bit, start_bit );
    if (stop_bit > 27) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGI_DATI_IDLE_DURATION_get", stop_bit, 27 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 27) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 27;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000204 bits 27:0) field IRIGI_DATI_IDLE_DURATION of register PMC_ETIME120_REG_IRIGI_DATI_IDLE_DURATION */
    reg_value = etime_reg_IRIGI_DATI_IDLE_DURATION_read( b_ptr,
                                                         h_ptr);
    field_value = (reg_value & ETIME120_REG_IRIGI_DATI_IDLE_DURATION_BIT_IRIGI_DATI_IDLE_DURATION_MSK)
                  >> ETIME120_REG_IRIGI_DATI_IDLE_DURATION_BIT_IRIGI_DATI_IDLE_DURATION_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_IRIGI_DATI_IDLE_DURATION_BIT_IRIGI_DATI_IDLE_DURATION_MSK, ETIME120_REG_IRIGI_DATI_IDLE_DURATION_BIT_IRIGI_DATI_IDLE_DURATION_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGI_DATI_IDLE_DURATION_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_IRIGO_P0PR_ONLY_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGO_P0PR_ONLY_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGO_P0PR_ONLY_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGO_P0PR_ONLY_set", value );

    /* (0x00000208 bits 3) field IRIGO_P0PR_ONLY of register PMC_ETIME120_REG_IRIGO_CFG */
    etime_reg_IRIGO_CFG_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_IRIGO_CFG_BIT_IRIGO_P0PR_ONLY_MSK,
                                   ETIME120_REG_IRIGO_CFG_BIT_IRIGO_P0PR_ONLY_OFF,
                                   value);
}

static INLINE UINT32 etime_field_IRIGO_P0PR_ONLY_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGO_P0PR_ONLY_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000208 bits 3) field IRIGO_P0PR_ONLY of register PMC_ETIME120_REG_IRIGO_CFG */
    reg_value = etime_reg_IRIGO_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_IRIGO_CFG_BIT_IRIGO_P0PR_ONLY_MSK) >> ETIME120_REG_IRIGO_CFG_BIT_IRIGO_P0PR_ONLY_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGO_P0PR_ONLY_get", value );

    return value;
}
static INLINE void etime_field_IRIGO_MODE_set( etime_buffer_t *b_ptr,
                                               etime_handle_t *h_ptr,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGO_MODE_set( etime_buffer_t *b_ptr,
                                               etime_handle_t *h_ptr,
                                               UINT32 value )
{
    if (value > 3)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGO_MODE_set", value, 3);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGO_MODE_set", value );

    /* (0x00000208 bits 2:1) field IRIGO_MODE of register PMC_ETIME120_REG_IRIGO_CFG */
    etime_reg_IRIGO_CFG_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_IRIGO_CFG_BIT_IRIGO_MODE_MSK,
                                   ETIME120_REG_IRIGO_CFG_BIT_IRIGO_MODE_OFF,
                                   value);
}

static INLINE UINT32 etime_field_IRIGO_MODE_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGO_MODE_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000208 bits 2:1) field IRIGO_MODE of register PMC_ETIME120_REG_IRIGO_CFG */
    reg_value = etime_reg_IRIGO_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_IRIGO_CFG_BIT_IRIGO_MODE_MSK) >> ETIME120_REG_IRIGO_CFG_BIT_IRIGO_MODE_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGO_MODE_get", value );

    return value;
}
static INLINE void etime_field_range_IRIGO_MODE_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 start_bit,
                                                     UINT32 stop_bit,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_IRIGO_MODE_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 start_bit,
                                                     UINT32 stop_bit,
                                                     UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGO_MODE_set", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGO_MODE_set", stop_bit, 1 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGO_MODE_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000208 bits 2:1) field IRIGO_MODE of register PMC_ETIME120_REG_IRIGO_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 1) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 1;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000208 bits 2:1) field IRIGO_MODE of register PMC_ETIME120_REG_IRIGO_CFG */
        etime_reg_IRIGO_CFG_field_set( b_ptr,
                                       h_ptr,
                                       subfield_mask << (ETIME120_REG_IRIGO_CFG_BIT_IRIGO_MODE_OFF + subfield_offset),
                                       ETIME120_REG_IRIGO_CFG_BIT_IRIGO_MODE_OFF + subfield_offset,
                                       value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_IRIGO_MODE_get( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_IRIGO_MODE_get( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGO_MODE_get", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGO_MODE_get", stop_bit, 1 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 1) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 1;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000208 bits 2:1) field IRIGO_MODE of register PMC_ETIME120_REG_IRIGO_CFG */
    reg_value = etime_reg_IRIGO_CFG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_IRIGO_CFG_BIT_IRIGO_MODE_MSK)
                  >> ETIME120_REG_IRIGO_CFG_BIT_IRIGO_MODE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_IRIGO_CFG_BIT_IRIGO_MODE_MSK, ETIME120_REG_IRIGO_CFG_BIT_IRIGO_MODE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGO_MODE_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_IRIGO_ENA_set( etime_buffer_t *b_ptr,
                                              etime_handle_t *h_ptr,
                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGO_ENA_set( etime_buffer_t *b_ptr,
                                              etime_handle_t *h_ptr,
                                              UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGO_ENA_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGO_ENA_set", value );

    /* (0x00000208 bits 0) field IRIGO_ENA of register PMC_ETIME120_REG_IRIGO_CFG */
    etime_reg_IRIGO_CFG_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_IRIGO_CFG_BIT_IRIGO_ENA_MSK,
                                   ETIME120_REG_IRIGO_CFG_BIT_IRIGO_ENA_OFF,
                                   value);
}

static INLINE UINT32 etime_field_IRIGO_ENA_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGO_ENA_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000208 bits 0) field IRIGO_ENA of register PMC_ETIME120_REG_IRIGO_CFG */
    reg_value = etime_reg_IRIGO_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_IRIGO_CFG_BIT_IRIGO_ENA_MSK) >> ETIME120_REG_IRIGO_CFG_BIT_IRIGO_ENA_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGO_ENA_get", value );

    return value;
}
static INLINE void etime_field_IRIGO_PWM_NOM_PER_CFG_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGO_PWM_NOM_PER_CFG_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 value )
{
    if (value > 4194303)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGO_PWM_NOM_PER_CFG_set", value, 4194303);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGO_PWM_NOM_PER_CFG_set", value );

    /* (0x0000020c bits 21:0) field IRIGO_PWM_NOM_PER_CFG of register PMC_ETIME120_REG_IRIGO_PWM_NOM_PER_CFG_REG */
    etime_reg_IRIGO_PWM_NOM_PER_CFG_REG_field_set( b_ptr,
                                                   h_ptr,
                                                   ETIME120_REG_IRIGO_PWM_NOM_PER_CFG_REG_BIT_IRIGO_PWM_NOM_PER_CFG_MSK,
                                                   ETIME120_REG_IRIGO_PWM_NOM_PER_CFG_REG_BIT_IRIGO_PWM_NOM_PER_CFG_OFF,
                                                   value);
}

static INLINE UINT32 etime_field_IRIGO_PWM_NOM_PER_CFG_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGO_PWM_NOM_PER_CFG_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000020c bits 21:0) field IRIGO_PWM_NOM_PER_CFG of register PMC_ETIME120_REG_IRIGO_PWM_NOM_PER_CFG_REG */
    reg_value = etime_reg_IRIGO_PWM_NOM_PER_CFG_REG_read( b_ptr,
                                                          h_ptr);
    value = (reg_value & ETIME120_REG_IRIGO_PWM_NOM_PER_CFG_REG_BIT_IRIGO_PWM_NOM_PER_CFG_MSK) >> ETIME120_REG_IRIGO_PWM_NOM_PER_CFG_REG_BIT_IRIGO_PWM_NOM_PER_CFG_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGO_PWM_NOM_PER_CFG_get", value );

    return value;
}
static INLINE void etime_field_range_IRIGO_PWM_NOM_PER_CFG_set( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit,
                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_IRIGO_PWM_NOM_PER_CFG_set( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit,
                                                                UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGO_PWM_NOM_PER_CFG_set", stop_bit, start_bit );
    if (stop_bit > 21) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGO_PWM_NOM_PER_CFG_set", stop_bit, 21 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGO_PWM_NOM_PER_CFG_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000020c bits 21:0) field IRIGO_PWM_NOM_PER_CFG of register PMC_ETIME120_REG_IRIGO_PWM_NOM_PER_CFG_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 21) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 21;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000020c bits 21:0) field IRIGO_PWM_NOM_PER_CFG of register PMC_ETIME120_REG_IRIGO_PWM_NOM_PER_CFG_REG */
        etime_reg_IRIGO_PWM_NOM_PER_CFG_REG_field_set( b_ptr,
                                                       h_ptr,
                                                       subfield_mask << (ETIME120_REG_IRIGO_PWM_NOM_PER_CFG_REG_BIT_IRIGO_PWM_NOM_PER_CFG_OFF + subfield_offset),
                                                       ETIME120_REG_IRIGO_PWM_NOM_PER_CFG_REG_BIT_IRIGO_PWM_NOM_PER_CFG_OFF + subfield_offset,
                                                       value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_IRIGO_PWM_NOM_PER_CFG_get( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_IRIGO_PWM_NOM_PER_CFG_get( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGO_PWM_NOM_PER_CFG_get", stop_bit, start_bit );
    if (stop_bit > 21) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGO_PWM_NOM_PER_CFG_get", stop_bit, 21 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 21) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 21;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000020c bits 21:0) field IRIGO_PWM_NOM_PER_CFG of register PMC_ETIME120_REG_IRIGO_PWM_NOM_PER_CFG_REG */
    reg_value = etime_reg_IRIGO_PWM_NOM_PER_CFG_REG_read( b_ptr,
                                                          h_ptr);
    field_value = (reg_value & ETIME120_REG_IRIGO_PWM_NOM_PER_CFG_REG_BIT_IRIGO_PWM_NOM_PER_CFG_MSK)
                  >> ETIME120_REG_IRIGO_PWM_NOM_PER_CFG_REG_BIT_IRIGO_PWM_NOM_PER_CFG_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_IRIGO_PWM_NOM_PER_CFG_REG_BIT_IRIGO_PWM_NOM_PER_CFG_MSK, ETIME120_REG_IRIGO_PWM_NOM_PER_CFG_REG_BIT_IRIGO_PWM_NOM_PER_CFG_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGO_PWM_NOM_PER_CFG_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_IRIGO_PWM_WIDTH_ONE_CFG_set( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGO_PWM_WIDTH_ONE_CFG_set( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 value )
{
    if (value > 4194303)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGO_PWM_WIDTH_ONE_CFG_set", value, 4194303);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGO_PWM_WIDTH_ONE_CFG_set", value );

    /* (0x00000210 bits 21:0) field IRIGO_PWM_WIDTH_ONE_CFG of register PMC_ETIME120_REG_IRIGO_PWM_ONE_REG */
    etime_reg_IRIGO_PWM_ONE_REG_field_set( b_ptr,
                                           h_ptr,
                                           ETIME120_REG_IRIGO_PWM_ONE_REG_BIT_IRIGO_PWM_WIDTH_ONE_CFG_MSK,
                                           ETIME120_REG_IRIGO_PWM_ONE_REG_BIT_IRIGO_PWM_WIDTH_ONE_CFG_OFF,
                                           value);
}

static INLINE UINT32 etime_field_IRIGO_PWM_WIDTH_ONE_CFG_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGO_PWM_WIDTH_ONE_CFG_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000210 bits 21:0) field IRIGO_PWM_WIDTH_ONE_CFG of register PMC_ETIME120_REG_IRIGO_PWM_ONE_REG */
    reg_value = etime_reg_IRIGO_PWM_ONE_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_IRIGO_PWM_ONE_REG_BIT_IRIGO_PWM_WIDTH_ONE_CFG_MSK) >> ETIME120_REG_IRIGO_PWM_ONE_REG_BIT_IRIGO_PWM_WIDTH_ONE_CFG_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGO_PWM_WIDTH_ONE_CFG_get", value );

    return value;
}
static INLINE void etime_field_range_IRIGO_PWM_WIDTH_ONE_CFG_set( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_IRIGO_PWM_WIDTH_ONE_CFG_set( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGO_PWM_WIDTH_ONE_CFG_set", stop_bit, start_bit );
    if (stop_bit > 21) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGO_PWM_WIDTH_ONE_CFG_set", stop_bit, 21 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGO_PWM_WIDTH_ONE_CFG_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000210 bits 21:0) field IRIGO_PWM_WIDTH_ONE_CFG of register PMC_ETIME120_REG_IRIGO_PWM_ONE_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 21) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 21;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000210 bits 21:0) field IRIGO_PWM_WIDTH_ONE_CFG of register PMC_ETIME120_REG_IRIGO_PWM_ONE_REG */
        etime_reg_IRIGO_PWM_ONE_REG_field_set( b_ptr,
                                               h_ptr,
                                               subfield_mask << (ETIME120_REG_IRIGO_PWM_ONE_REG_BIT_IRIGO_PWM_WIDTH_ONE_CFG_OFF + subfield_offset),
                                               ETIME120_REG_IRIGO_PWM_ONE_REG_BIT_IRIGO_PWM_WIDTH_ONE_CFG_OFF + subfield_offset,
                                               value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_IRIGO_PWM_WIDTH_ONE_CFG_get( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_IRIGO_PWM_WIDTH_ONE_CFG_get( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGO_PWM_WIDTH_ONE_CFG_get", stop_bit, start_bit );
    if (stop_bit > 21) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGO_PWM_WIDTH_ONE_CFG_get", stop_bit, 21 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 21) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 21;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000210 bits 21:0) field IRIGO_PWM_WIDTH_ONE_CFG of register PMC_ETIME120_REG_IRIGO_PWM_ONE_REG */
    reg_value = etime_reg_IRIGO_PWM_ONE_REG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_IRIGO_PWM_ONE_REG_BIT_IRIGO_PWM_WIDTH_ONE_CFG_MSK)
                  >> ETIME120_REG_IRIGO_PWM_ONE_REG_BIT_IRIGO_PWM_WIDTH_ONE_CFG_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_IRIGO_PWM_ONE_REG_BIT_IRIGO_PWM_WIDTH_ONE_CFG_MSK, ETIME120_REG_IRIGO_PWM_ONE_REG_BIT_IRIGO_PWM_WIDTH_ONE_CFG_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGO_PWM_WIDTH_ONE_CFG_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_IRIGO_PWM_WIDTH_ZERO_CFG_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGO_PWM_WIDTH_ZERO_CFG_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value )
{
    if (value > 4194303)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGO_PWM_WIDTH_ZERO_CFG_set", value, 4194303);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGO_PWM_WIDTH_ZERO_CFG_set", value );

    /* (0x00000214 bits 21:0) field IRIGO_PWM_WIDTH_ZERO_CFG of register PMC_ETIME120_REG_IRIGO_PWM_ZERO_REG */
    etime_reg_IRIGO_PWM_ZERO_REG_field_set( b_ptr,
                                            h_ptr,
                                            ETIME120_REG_IRIGO_PWM_ZERO_REG_BIT_IRIGO_PWM_WIDTH_ZERO_CFG_MSK,
                                            ETIME120_REG_IRIGO_PWM_ZERO_REG_BIT_IRIGO_PWM_WIDTH_ZERO_CFG_OFF,
                                            value);
}

static INLINE UINT32 etime_field_IRIGO_PWM_WIDTH_ZERO_CFG_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGO_PWM_WIDTH_ZERO_CFG_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000214 bits 21:0) field IRIGO_PWM_WIDTH_ZERO_CFG of register PMC_ETIME120_REG_IRIGO_PWM_ZERO_REG */
    reg_value = etime_reg_IRIGO_PWM_ZERO_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_IRIGO_PWM_ZERO_REG_BIT_IRIGO_PWM_WIDTH_ZERO_CFG_MSK) >> ETIME120_REG_IRIGO_PWM_ZERO_REG_BIT_IRIGO_PWM_WIDTH_ZERO_CFG_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGO_PWM_WIDTH_ZERO_CFG_get", value );

    return value;
}
static INLINE void etime_field_range_IRIGO_PWM_WIDTH_ZERO_CFG_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_IRIGO_PWM_WIDTH_ZERO_CFG_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGO_PWM_WIDTH_ZERO_CFG_set", stop_bit, start_bit );
    if (stop_bit > 21) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGO_PWM_WIDTH_ZERO_CFG_set", stop_bit, 21 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGO_PWM_WIDTH_ZERO_CFG_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000214 bits 21:0) field IRIGO_PWM_WIDTH_ZERO_CFG of register PMC_ETIME120_REG_IRIGO_PWM_ZERO_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 21) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 21;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000214 bits 21:0) field IRIGO_PWM_WIDTH_ZERO_CFG of register PMC_ETIME120_REG_IRIGO_PWM_ZERO_REG */
        etime_reg_IRIGO_PWM_ZERO_REG_field_set( b_ptr,
                                                h_ptr,
                                                subfield_mask << (ETIME120_REG_IRIGO_PWM_ZERO_REG_BIT_IRIGO_PWM_WIDTH_ZERO_CFG_OFF + subfield_offset),
                                                ETIME120_REG_IRIGO_PWM_ZERO_REG_BIT_IRIGO_PWM_WIDTH_ZERO_CFG_OFF + subfield_offset,
                                                value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_IRIGO_PWM_WIDTH_ZERO_CFG_get( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_IRIGO_PWM_WIDTH_ZERO_CFG_get( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGO_PWM_WIDTH_ZERO_CFG_get", stop_bit, start_bit );
    if (stop_bit > 21) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGO_PWM_WIDTH_ZERO_CFG_get", stop_bit, 21 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 21) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 21;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000214 bits 21:0) field IRIGO_PWM_WIDTH_ZERO_CFG of register PMC_ETIME120_REG_IRIGO_PWM_ZERO_REG */
    reg_value = etime_reg_IRIGO_PWM_ZERO_REG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_IRIGO_PWM_ZERO_REG_BIT_IRIGO_PWM_WIDTH_ZERO_CFG_MSK)
                  >> ETIME120_REG_IRIGO_PWM_ZERO_REG_BIT_IRIGO_PWM_WIDTH_ZERO_CFG_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_IRIGO_PWM_ZERO_REG_BIT_IRIGO_PWM_WIDTH_ZERO_CFG_MSK, ETIME120_REG_IRIGO_PWM_ZERO_REG_BIT_IRIGO_PWM_WIDTH_ZERO_CFG_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGO_PWM_WIDTH_ZERO_CFG_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_IRIGO_PWM_WIDTH_PX_CFG_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGO_PWM_WIDTH_PX_CFG_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value )
{
    if (value > 4194303)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGO_PWM_WIDTH_PX_CFG_set", value, 4194303);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGO_PWM_WIDTH_PX_CFG_set", value );

    /* (0x00000218 bits 21:0) field IRIGO_PWM_WIDTH_PX_CFG of register PMC_ETIME120_REG_IRIGO_PWM_WIDTH_PX_REG */
    etime_reg_IRIGO_PWM_WIDTH_PX_REG_field_set( b_ptr,
                                                h_ptr,
                                                ETIME120_REG_IRIGO_PWM_WIDTH_PX_REG_BIT_IRIGO_PWM_WIDTH_PX_CFG_MSK,
                                                ETIME120_REG_IRIGO_PWM_WIDTH_PX_REG_BIT_IRIGO_PWM_WIDTH_PX_CFG_OFF,
                                                value);
}

static INLINE UINT32 etime_field_IRIGO_PWM_WIDTH_PX_CFG_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGO_PWM_WIDTH_PX_CFG_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000218 bits 21:0) field IRIGO_PWM_WIDTH_PX_CFG of register PMC_ETIME120_REG_IRIGO_PWM_WIDTH_PX_REG */
    reg_value = etime_reg_IRIGO_PWM_WIDTH_PX_REG_read( b_ptr,
                                                       h_ptr);
    value = (reg_value & ETIME120_REG_IRIGO_PWM_WIDTH_PX_REG_BIT_IRIGO_PWM_WIDTH_PX_CFG_MSK) >> ETIME120_REG_IRIGO_PWM_WIDTH_PX_REG_BIT_IRIGO_PWM_WIDTH_PX_CFG_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGO_PWM_WIDTH_PX_CFG_get", value );

    return value;
}
static INLINE void etime_field_range_IRIGO_PWM_WIDTH_PX_CFG_set( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_IRIGO_PWM_WIDTH_PX_CFG_set( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGO_PWM_WIDTH_PX_CFG_set", stop_bit, start_bit );
    if (stop_bit > 21) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGO_PWM_WIDTH_PX_CFG_set", stop_bit, 21 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGO_PWM_WIDTH_PX_CFG_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000218 bits 21:0) field IRIGO_PWM_WIDTH_PX_CFG of register PMC_ETIME120_REG_IRIGO_PWM_WIDTH_PX_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 21) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 21;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000218 bits 21:0) field IRIGO_PWM_WIDTH_PX_CFG of register PMC_ETIME120_REG_IRIGO_PWM_WIDTH_PX_REG */
        etime_reg_IRIGO_PWM_WIDTH_PX_REG_field_set( b_ptr,
                                                    h_ptr,
                                                    subfield_mask << (ETIME120_REG_IRIGO_PWM_WIDTH_PX_REG_BIT_IRIGO_PWM_WIDTH_PX_CFG_OFF + subfield_offset),
                                                    ETIME120_REG_IRIGO_PWM_WIDTH_PX_REG_BIT_IRIGO_PWM_WIDTH_PX_CFG_OFF + subfield_offset,
                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_IRIGO_PWM_WIDTH_PX_CFG_get( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_IRIGO_PWM_WIDTH_PX_CFG_get( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGO_PWM_WIDTH_PX_CFG_get", stop_bit, start_bit );
    if (stop_bit > 21) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGO_PWM_WIDTH_PX_CFG_get", stop_bit, 21 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 21) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 21;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000218 bits 21:0) field IRIGO_PWM_WIDTH_PX_CFG of register PMC_ETIME120_REG_IRIGO_PWM_WIDTH_PX_REG */
    reg_value = etime_reg_IRIGO_PWM_WIDTH_PX_REG_read( b_ptr,
                                                       h_ptr);
    field_value = (reg_value & ETIME120_REG_IRIGO_PWM_WIDTH_PX_REG_BIT_IRIGO_PWM_WIDTH_PX_CFG_MSK)
                  >> ETIME120_REG_IRIGO_PWM_WIDTH_PX_REG_BIT_IRIGO_PWM_WIDTH_PX_CFG_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_IRIGO_PWM_WIDTH_PX_REG_BIT_IRIGO_PWM_WIDTH_PX_CFG_MSK, ETIME120_REG_IRIGO_PWM_WIDTH_PX_REG_BIT_IRIGO_PWM_WIDTH_PX_CFG_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGO_PWM_WIDTH_PX_CFG_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_IRIGO_PWM_1PPS_WIDTH_CFG_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGO_PWM_1PPS_WIDTH_CFG_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value )
{
    if (value > 33554431)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGO_PWM_1PPS_WIDTH_CFG_set", value, 33554431);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGO_PWM_1PPS_WIDTH_CFG_set", value );

    /* (0x0000021c bits 24:0) field IRIGO_PWM_1PPS_WIDTH_CFG of register PMC_ETIME120_REG_IRIGO_PWM_1PPS_WIDTH_REG */
    etime_reg_IRIGO_PWM_1PPS_WIDTH_REG_field_set( b_ptr,
                                                  h_ptr,
                                                  ETIME120_REG_IRIGO_PWM_1PPS_WIDTH_REG_BIT_IRIGO_PWM_1PPS_WIDTH_CFG_MSK,
                                                  ETIME120_REG_IRIGO_PWM_1PPS_WIDTH_REG_BIT_IRIGO_PWM_1PPS_WIDTH_CFG_OFF,
                                                  value);
}

static INLINE UINT32 etime_field_IRIGO_PWM_1PPS_WIDTH_CFG_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGO_PWM_1PPS_WIDTH_CFG_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000021c bits 24:0) field IRIGO_PWM_1PPS_WIDTH_CFG of register PMC_ETIME120_REG_IRIGO_PWM_1PPS_WIDTH_REG */
    reg_value = etime_reg_IRIGO_PWM_1PPS_WIDTH_REG_read( b_ptr,
                                                         h_ptr);
    value = (reg_value & ETIME120_REG_IRIGO_PWM_1PPS_WIDTH_REG_BIT_IRIGO_PWM_1PPS_WIDTH_CFG_MSK) >> ETIME120_REG_IRIGO_PWM_1PPS_WIDTH_REG_BIT_IRIGO_PWM_1PPS_WIDTH_CFG_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGO_PWM_1PPS_WIDTH_CFG_get", value );

    return value;
}
static INLINE void etime_field_range_IRIGO_PWM_1PPS_WIDTH_CFG_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_IRIGO_PWM_1PPS_WIDTH_CFG_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGO_PWM_1PPS_WIDTH_CFG_set", stop_bit, start_bit );
    if (stop_bit > 24) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGO_PWM_1PPS_WIDTH_CFG_set", stop_bit, 24 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGO_PWM_1PPS_WIDTH_CFG_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000021c bits 24:0) field IRIGO_PWM_1PPS_WIDTH_CFG of register PMC_ETIME120_REG_IRIGO_PWM_1PPS_WIDTH_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 24) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 24;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000021c bits 24:0) field IRIGO_PWM_1PPS_WIDTH_CFG of register PMC_ETIME120_REG_IRIGO_PWM_1PPS_WIDTH_REG */
        etime_reg_IRIGO_PWM_1PPS_WIDTH_REG_field_set( b_ptr,
                                                      h_ptr,
                                                      subfield_mask << (ETIME120_REG_IRIGO_PWM_1PPS_WIDTH_REG_BIT_IRIGO_PWM_1PPS_WIDTH_CFG_OFF + subfield_offset),
                                                      ETIME120_REG_IRIGO_PWM_1PPS_WIDTH_REG_BIT_IRIGO_PWM_1PPS_WIDTH_CFG_OFF + subfield_offset,
                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_IRIGO_PWM_1PPS_WIDTH_CFG_get( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_IRIGO_PWM_1PPS_WIDTH_CFG_get( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGO_PWM_1PPS_WIDTH_CFG_get", stop_bit, start_bit );
    if (stop_bit > 24) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGO_PWM_1PPS_WIDTH_CFG_get", stop_bit, 24 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 24) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 24;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000021c bits 24:0) field IRIGO_PWM_1PPS_WIDTH_CFG of register PMC_ETIME120_REG_IRIGO_PWM_1PPS_WIDTH_REG */
    reg_value = etime_reg_IRIGO_PWM_1PPS_WIDTH_REG_read( b_ptr,
                                                         h_ptr);
    field_value = (reg_value & ETIME120_REG_IRIGO_PWM_1PPS_WIDTH_REG_BIT_IRIGO_PWM_1PPS_WIDTH_CFG_MSK)
                  >> ETIME120_REG_IRIGO_PWM_1PPS_WIDTH_REG_BIT_IRIGO_PWM_1PPS_WIDTH_CFG_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_IRIGO_PWM_1PPS_WIDTH_REG_BIT_IRIGO_PWM_1PPS_WIDTH_CFG_MSK, ETIME120_REG_IRIGO_PWM_1PPS_WIDTH_REG_BIT_IRIGO_PWM_1PPS_WIDTH_CFG_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGO_PWM_1PPS_WIDTH_CFG_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CC_INT_4_RAND_EN_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CC_INT_4_RAND_EN_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CC_INT_4_RAND_EN_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_CC_INT_4_RAND_EN_set", value );

    /* (0x00000220 bits 11) field CC_INT_4_RAND_EN of register PMC_ETIME120_REG_INT_GEN_CFG */
    etime_reg_INT_GEN_CFG_field_set( b_ptr,
                                     h_ptr,
                                     ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_4_RAND_EN_MSK,
                                     ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_4_RAND_EN_OFF,
                                     value);
}

static INLINE UINT32 etime_field_CC_INT_4_RAND_EN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CC_INT_4_RAND_EN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000220 bits 11) field CC_INT_4_RAND_EN of register PMC_ETIME120_REG_INT_GEN_CFG */
    reg_value = etime_reg_INT_GEN_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_4_RAND_EN_MSK) >> ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_4_RAND_EN_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CC_INT_4_RAND_EN_get", value );

    return value;
}
static INLINE void etime_field_CC_INT_3_RAND_EN_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CC_INT_3_RAND_EN_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CC_INT_3_RAND_EN_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_CC_INT_3_RAND_EN_set", value );

    /* (0x00000220 bits 10) field CC_INT_3_RAND_EN of register PMC_ETIME120_REG_INT_GEN_CFG */
    etime_reg_INT_GEN_CFG_field_set( b_ptr,
                                     h_ptr,
                                     ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_3_RAND_EN_MSK,
                                     ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_3_RAND_EN_OFF,
                                     value);
}

static INLINE UINT32 etime_field_CC_INT_3_RAND_EN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CC_INT_3_RAND_EN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000220 bits 10) field CC_INT_3_RAND_EN of register PMC_ETIME120_REG_INT_GEN_CFG */
    reg_value = etime_reg_INT_GEN_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_3_RAND_EN_MSK) >> ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_3_RAND_EN_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CC_INT_3_RAND_EN_get", value );

    return value;
}
static INLINE void etime_field_CC_INT_2_RAND_EN_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CC_INT_2_RAND_EN_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CC_INT_2_RAND_EN_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_CC_INT_2_RAND_EN_set", value );

    /* (0x00000220 bits 9) field CC_INT_2_RAND_EN of register PMC_ETIME120_REG_INT_GEN_CFG */
    etime_reg_INT_GEN_CFG_field_set( b_ptr,
                                     h_ptr,
                                     ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_2_RAND_EN_MSK,
                                     ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_2_RAND_EN_OFF,
                                     value);
}

static INLINE UINT32 etime_field_CC_INT_2_RAND_EN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CC_INT_2_RAND_EN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000220 bits 9) field CC_INT_2_RAND_EN of register PMC_ETIME120_REG_INT_GEN_CFG */
    reg_value = etime_reg_INT_GEN_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_2_RAND_EN_MSK) >> ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_2_RAND_EN_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CC_INT_2_RAND_EN_get", value );

    return value;
}
static INLINE void etime_field_CC_INT_1_RAND_EN_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CC_INT_1_RAND_EN_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CC_INT_1_RAND_EN_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_CC_INT_1_RAND_EN_set", value );

    /* (0x00000220 bits 8) field CC_INT_1_RAND_EN of register PMC_ETIME120_REG_INT_GEN_CFG */
    etime_reg_INT_GEN_CFG_field_set( b_ptr,
                                     h_ptr,
                                     ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_1_RAND_EN_MSK,
                                     ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_1_RAND_EN_OFF,
                                     value);
}

static INLINE UINT32 etime_field_CC_INT_1_RAND_EN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CC_INT_1_RAND_EN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000220 bits 8) field CC_INT_1_RAND_EN of register PMC_ETIME120_REG_INT_GEN_CFG */
    reg_value = etime_reg_INT_GEN_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_1_RAND_EN_MSK) >> ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_1_RAND_EN_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CC_INT_1_RAND_EN_get", value );

    return value;
}
static INLINE void etime_field_CC_INT_4_EN_set( etime_buffer_t *b_ptr,
                                                etime_handle_t *h_ptr,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CC_INT_4_EN_set( etime_buffer_t *b_ptr,
                                                etime_handle_t *h_ptr,
                                                UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CC_INT_4_EN_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_CC_INT_4_EN_set", value );

    /* (0x00000220 bits 7) field CC_INT_4_EN of register PMC_ETIME120_REG_INT_GEN_CFG */
    etime_reg_INT_GEN_CFG_field_set( b_ptr,
                                     h_ptr,
                                     ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_4_EN_MSK,
                                     ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_4_EN_OFF,
                                     value);
}

static INLINE UINT32 etime_field_CC_INT_4_EN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CC_INT_4_EN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000220 bits 7) field CC_INT_4_EN of register PMC_ETIME120_REG_INT_GEN_CFG */
    reg_value = etime_reg_INT_GEN_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_4_EN_MSK) >> ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_4_EN_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CC_INT_4_EN_get", value );

    return value;
}
static INLINE void etime_field_CC_INT_3_EN_set( etime_buffer_t *b_ptr,
                                                etime_handle_t *h_ptr,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CC_INT_3_EN_set( etime_buffer_t *b_ptr,
                                                etime_handle_t *h_ptr,
                                                UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CC_INT_3_EN_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_CC_INT_3_EN_set", value );

    /* (0x00000220 bits 6) field CC_INT_3_EN of register PMC_ETIME120_REG_INT_GEN_CFG */
    etime_reg_INT_GEN_CFG_field_set( b_ptr,
                                     h_ptr,
                                     ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_3_EN_MSK,
                                     ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_3_EN_OFF,
                                     value);
}

static INLINE UINT32 etime_field_CC_INT_3_EN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CC_INT_3_EN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000220 bits 6) field CC_INT_3_EN of register PMC_ETIME120_REG_INT_GEN_CFG */
    reg_value = etime_reg_INT_GEN_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_3_EN_MSK) >> ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_3_EN_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CC_INT_3_EN_get", value );

    return value;
}
static INLINE void etime_field_CC_INT_2_EN_set( etime_buffer_t *b_ptr,
                                                etime_handle_t *h_ptr,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CC_INT_2_EN_set( etime_buffer_t *b_ptr,
                                                etime_handle_t *h_ptr,
                                                UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CC_INT_2_EN_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_CC_INT_2_EN_set", value );

    /* (0x00000220 bits 5) field CC_INT_2_EN of register PMC_ETIME120_REG_INT_GEN_CFG */
    etime_reg_INT_GEN_CFG_field_set( b_ptr,
                                     h_ptr,
                                     ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_2_EN_MSK,
                                     ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_2_EN_OFF,
                                     value);
}

static INLINE UINT32 etime_field_CC_INT_2_EN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CC_INT_2_EN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000220 bits 5) field CC_INT_2_EN of register PMC_ETIME120_REG_INT_GEN_CFG */
    reg_value = etime_reg_INT_GEN_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_2_EN_MSK) >> ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_2_EN_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CC_INT_2_EN_get", value );

    return value;
}
static INLINE void etime_field_CC_INT_1_EN_set( etime_buffer_t *b_ptr,
                                                etime_handle_t *h_ptr,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CC_INT_1_EN_set( etime_buffer_t *b_ptr,
                                                etime_handle_t *h_ptr,
                                                UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CC_INT_1_EN_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_CC_INT_1_EN_set", value );

    /* (0x00000220 bits 4) field CC_INT_1_EN of register PMC_ETIME120_REG_INT_GEN_CFG */
    etime_reg_INT_GEN_CFG_field_set( b_ptr,
                                     h_ptr,
                                     ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_1_EN_MSK,
                                     ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_1_EN_OFF,
                                     value);
}

static INLINE UINT32 etime_field_CC_INT_1_EN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CC_INT_1_EN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000220 bits 4) field CC_INT_1_EN of register PMC_ETIME120_REG_INT_GEN_CFG */
    reg_value = etime_reg_INT_GEN_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_1_EN_MSK) >> ETIME120_REG_INT_GEN_CFG_BIT_CC_INT_1_EN_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CC_INT_1_EN_get", value );

    return value;
}
static INLINE void etime_field_TOD_INT_2_EN_set( etime_buffer_t *b_ptr,
                                                 etime_handle_t *h_ptr,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_INT_2_EN_set( etime_buffer_t *b_ptr,
                                                 etime_handle_t *h_ptr,
                                                 UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_INT_2_EN_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_INT_2_EN_set", value );

    /* (0x00000220 bits 3) field TOD_INT_2_EN of register PMC_ETIME120_REG_INT_GEN_CFG */
    etime_reg_INT_GEN_CFG_field_set( b_ptr,
                                     h_ptr,
                                     ETIME120_REG_INT_GEN_CFG_BIT_TOD_INT_2_EN_MSK,
                                     ETIME120_REG_INT_GEN_CFG_BIT_TOD_INT_2_EN_OFF,
                                     value);
}

static INLINE UINT32 etime_field_TOD_INT_2_EN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_INT_2_EN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000220 bits 3) field TOD_INT_2_EN of register PMC_ETIME120_REG_INT_GEN_CFG */
    reg_value = etime_reg_INT_GEN_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_INT_GEN_CFG_BIT_TOD_INT_2_EN_MSK) >> ETIME120_REG_INT_GEN_CFG_BIT_TOD_INT_2_EN_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_INT_2_EN_get", value );

    return value;
}
static INLINE void etime_field_TOD_INT_1_EN_set( etime_buffer_t *b_ptr,
                                                 etime_handle_t *h_ptr,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_INT_1_EN_set( etime_buffer_t *b_ptr,
                                                 etime_handle_t *h_ptr,
                                                 UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_INT_1_EN_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_INT_1_EN_set", value );

    /* (0x00000220 bits 2) field TOD_INT_1_EN of register PMC_ETIME120_REG_INT_GEN_CFG */
    etime_reg_INT_GEN_CFG_field_set( b_ptr,
                                     h_ptr,
                                     ETIME120_REG_INT_GEN_CFG_BIT_TOD_INT_1_EN_MSK,
                                     ETIME120_REG_INT_GEN_CFG_BIT_TOD_INT_1_EN_OFF,
                                     value);
}

static INLINE UINT32 etime_field_TOD_INT_1_EN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_INT_1_EN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000220 bits 2) field TOD_INT_1_EN of register PMC_ETIME120_REG_INT_GEN_CFG */
    reg_value = etime_reg_INT_GEN_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_INT_GEN_CFG_BIT_TOD_INT_1_EN_MSK) >> ETIME120_REG_INT_GEN_CFG_BIT_TOD_INT_1_EN_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_INT_1_EN_get", value );

    return value;
}
static INLINE void etime_field_FREE_RUN_INT_2_EN_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_FREE_RUN_INT_2_EN_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_FREE_RUN_INT_2_EN_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_FREE_RUN_INT_2_EN_set", value );

    /* (0x00000220 bits 1) field FREE_RUN_INT_2_EN of register PMC_ETIME120_REG_INT_GEN_CFG */
    etime_reg_INT_GEN_CFG_field_set( b_ptr,
                                     h_ptr,
                                     ETIME120_REG_INT_GEN_CFG_BIT_FREE_RUN_INT_2_EN_MSK,
                                     ETIME120_REG_INT_GEN_CFG_BIT_FREE_RUN_INT_2_EN_OFF,
                                     value);
}

static INLINE UINT32 etime_field_FREE_RUN_INT_2_EN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_FREE_RUN_INT_2_EN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000220 bits 1) field FREE_RUN_INT_2_EN of register PMC_ETIME120_REG_INT_GEN_CFG */
    reg_value = etime_reg_INT_GEN_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_INT_GEN_CFG_BIT_FREE_RUN_INT_2_EN_MSK) >> ETIME120_REG_INT_GEN_CFG_BIT_FREE_RUN_INT_2_EN_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_FREE_RUN_INT_2_EN_get", value );

    return value;
}
static INLINE void etime_field_FREE_RUN_INT_1_EN_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_FREE_RUN_INT_1_EN_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_FREE_RUN_INT_1_EN_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_FREE_RUN_INT_1_EN_set", value );

    /* (0x00000220 bits 0) field FREE_RUN_INT_1_EN of register PMC_ETIME120_REG_INT_GEN_CFG */
    etime_reg_INT_GEN_CFG_field_set( b_ptr,
                                     h_ptr,
                                     ETIME120_REG_INT_GEN_CFG_BIT_FREE_RUN_INT_1_EN_MSK,
                                     ETIME120_REG_INT_GEN_CFG_BIT_FREE_RUN_INT_1_EN_OFF,
                                     value);
}

static INLINE UINT32 etime_field_FREE_RUN_INT_1_EN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_FREE_RUN_INT_1_EN_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000220 bits 0) field FREE_RUN_INT_1_EN of register PMC_ETIME120_REG_INT_GEN_CFG */
    reg_value = etime_reg_INT_GEN_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_INT_GEN_CFG_BIT_FREE_RUN_INT_1_EN_MSK) >> ETIME120_REG_INT_GEN_CFG_BIT_FREE_RUN_INT_1_EN_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_FREE_RUN_INT_1_EN_get", value );

    return value;
}
static INLINE void etime_field_TOD_INT_PER_2_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_INT_PER_2_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 255)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_INT_PER_2_set", value, 255);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_INT_PER_2_set", value );

    /* (0x00000224 bits 31:24) field TOD_INT_PER_2 of register PMC_ETIME120_REG_INT_PER_CFG */
    etime_reg_INT_PER_CFG_field_set( b_ptr,
                                     h_ptr,
                                     ETIME120_REG_INT_PER_CFG_BIT_TOD_INT_PER_2_MSK,
                                     ETIME120_REG_INT_PER_CFG_BIT_TOD_INT_PER_2_OFF,
                                     value);
}

static INLINE UINT32 etime_field_TOD_INT_PER_2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_INT_PER_2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000224 bits 31:24) field TOD_INT_PER_2 of register PMC_ETIME120_REG_INT_PER_CFG */
    reg_value = etime_reg_INT_PER_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_INT_PER_CFG_BIT_TOD_INT_PER_2_MSK) >> ETIME120_REG_INT_PER_CFG_BIT_TOD_INT_PER_2_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_INT_PER_2_get", value );

    return value;
}
static INLINE void etime_field_range_TOD_INT_PER_2_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TOD_INT_PER_2_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_INT_PER_2_set", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_INT_PER_2_set", stop_bit, 7 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_INT_PER_2_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000224 bits 31:24) field TOD_INT_PER_2 of register PMC_ETIME120_REG_INT_PER_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 7) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 7;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000224 bits 31:24) field TOD_INT_PER_2 of register PMC_ETIME120_REG_INT_PER_CFG */
        etime_reg_INT_PER_CFG_field_set( b_ptr,
                                         h_ptr,
                                         subfield_mask << (ETIME120_REG_INT_PER_CFG_BIT_TOD_INT_PER_2_OFF + subfield_offset),
                                         ETIME120_REG_INT_PER_CFG_BIT_TOD_INT_PER_2_OFF + subfield_offset,
                                         value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TOD_INT_PER_2_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_INT_PER_2_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_INT_PER_2_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_INT_PER_2_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000224 bits 31:24) field TOD_INT_PER_2 of register PMC_ETIME120_REG_INT_PER_CFG */
    reg_value = etime_reg_INT_PER_CFG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_INT_PER_CFG_BIT_TOD_INT_PER_2_MSK)
                  >> ETIME120_REG_INT_PER_CFG_BIT_TOD_INT_PER_2_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_INT_PER_CFG_BIT_TOD_INT_PER_2_MSK, ETIME120_REG_INT_PER_CFG_BIT_TOD_INT_PER_2_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_INT_PER_2_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TOD_INT_PER_1_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_INT_PER_1_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 255)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_INT_PER_1_set", value, 255);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_INT_PER_1_set", value );

    /* (0x00000224 bits 23:16) field TOD_INT_PER_1 of register PMC_ETIME120_REG_INT_PER_CFG */
    etime_reg_INT_PER_CFG_field_set( b_ptr,
                                     h_ptr,
                                     ETIME120_REG_INT_PER_CFG_BIT_TOD_INT_PER_1_MSK,
                                     ETIME120_REG_INT_PER_CFG_BIT_TOD_INT_PER_1_OFF,
                                     value);
}

static INLINE UINT32 etime_field_TOD_INT_PER_1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_INT_PER_1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000224 bits 23:16) field TOD_INT_PER_1 of register PMC_ETIME120_REG_INT_PER_CFG */
    reg_value = etime_reg_INT_PER_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_INT_PER_CFG_BIT_TOD_INT_PER_1_MSK) >> ETIME120_REG_INT_PER_CFG_BIT_TOD_INT_PER_1_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_INT_PER_1_get", value );

    return value;
}
static INLINE void etime_field_range_TOD_INT_PER_1_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TOD_INT_PER_1_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_INT_PER_1_set", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_INT_PER_1_set", stop_bit, 7 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_INT_PER_1_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000224 bits 23:16) field TOD_INT_PER_1 of register PMC_ETIME120_REG_INT_PER_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 7) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 7;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000224 bits 23:16) field TOD_INT_PER_1 of register PMC_ETIME120_REG_INT_PER_CFG */
        etime_reg_INT_PER_CFG_field_set( b_ptr,
                                         h_ptr,
                                         subfield_mask << (ETIME120_REG_INT_PER_CFG_BIT_TOD_INT_PER_1_OFF + subfield_offset),
                                         ETIME120_REG_INT_PER_CFG_BIT_TOD_INT_PER_1_OFF + subfield_offset,
                                         value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TOD_INT_PER_1_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_INT_PER_1_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_INT_PER_1_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_INT_PER_1_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000224 bits 23:16) field TOD_INT_PER_1 of register PMC_ETIME120_REG_INT_PER_CFG */
    reg_value = etime_reg_INT_PER_CFG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_INT_PER_CFG_BIT_TOD_INT_PER_1_MSK)
                  >> ETIME120_REG_INT_PER_CFG_BIT_TOD_INT_PER_1_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_INT_PER_CFG_BIT_TOD_INT_PER_1_MSK, ETIME120_REG_INT_PER_CFG_BIT_TOD_INT_PER_1_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_INT_PER_1_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_FREE_RUN_INT_PER_2_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_FREE_RUN_INT_PER_2_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value )
{
    if (value > 255)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_FREE_RUN_INT_PER_2_set", value, 255);
    IOLOG( "%s <= 0x%08x", "etime_field_FREE_RUN_INT_PER_2_set", value );

    /* (0x00000224 bits 15:8) field FREE_RUN_INT_PER_2 of register PMC_ETIME120_REG_INT_PER_CFG */
    etime_reg_INT_PER_CFG_field_set( b_ptr,
                                     h_ptr,
                                     ETIME120_REG_INT_PER_CFG_BIT_FREE_RUN_INT_PER_2_MSK,
                                     ETIME120_REG_INT_PER_CFG_BIT_FREE_RUN_INT_PER_2_OFF,
                                     value);
}

static INLINE UINT32 etime_field_FREE_RUN_INT_PER_2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_FREE_RUN_INT_PER_2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000224 bits 15:8) field FREE_RUN_INT_PER_2 of register PMC_ETIME120_REG_INT_PER_CFG */
    reg_value = etime_reg_INT_PER_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_INT_PER_CFG_BIT_FREE_RUN_INT_PER_2_MSK) >> ETIME120_REG_INT_PER_CFG_BIT_FREE_RUN_INT_PER_2_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_FREE_RUN_INT_PER_2_get", value );

    return value;
}
static INLINE void etime_field_range_FREE_RUN_INT_PER_2_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_FREE_RUN_INT_PER_2_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit,
                                                             UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_FREE_RUN_INT_PER_2_set", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_FREE_RUN_INT_PER_2_set", stop_bit, 7 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_FREE_RUN_INT_PER_2_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000224 bits 15:8) field FREE_RUN_INT_PER_2 of register PMC_ETIME120_REG_INT_PER_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 7) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 7;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000224 bits 15:8) field FREE_RUN_INT_PER_2 of register PMC_ETIME120_REG_INT_PER_CFG */
        etime_reg_INT_PER_CFG_field_set( b_ptr,
                                         h_ptr,
                                         subfield_mask << (ETIME120_REG_INT_PER_CFG_BIT_FREE_RUN_INT_PER_2_OFF + subfield_offset),
                                         ETIME120_REG_INT_PER_CFG_BIT_FREE_RUN_INT_PER_2_OFF + subfield_offset,
                                         value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_FREE_RUN_INT_PER_2_get( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_FREE_RUN_INT_PER_2_get( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_FREE_RUN_INT_PER_2_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_FREE_RUN_INT_PER_2_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000224 bits 15:8) field FREE_RUN_INT_PER_2 of register PMC_ETIME120_REG_INT_PER_CFG */
    reg_value = etime_reg_INT_PER_CFG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_INT_PER_CFG_BIT_FREE_RUN_INT_PER_2_MSK)
                  >> ETIME120_REG_INT_PER_CFG_BIT_FREE_RUN_INT_PER_2_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_INT_PER_CFG_BIT_FREE_RUN_INT_PER_2_MSK, ETIME120_REG_INT_PER_CFG_BIT_FREE_RUN_INT_PER_2_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_FREE_RUN_INT_PER_2_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_FREE_RUN_INT_PER_1_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_FREE_RUN_INT_PER_1_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value )
{
    if (value > 255)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_FREE_RUN_INT_PER_1_set", value, 255);
    IOLOG( "%s <= 0x%08x", "etime_field_FREE_RUN_INT_PER_1_set", value );

    /* (0x00000224 bits 7:0) field FREE_RUN_INT_PER_1 of register PMC_ETIME120_REG_INT_PER_CFG */
    etime_reg_INT_PER_CFG_field_set( b_ptr,
                                     h_ptr,
                                     ETIME120_REG_INT_PER_CFG_BIT_FREE_RUN_INT_PER_1_MSK,
                                     ETIME120_REG_INT_PER_CFG_BIT_FREE_RUN_INT_PER_1_OFF,
                                     value);
}

static INLINE UINT32 etime_field_FREE_RUN_INT_PER_1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_FREE_RUN_INT_PER_1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000224 bits 7:0) field FREE_RUN_INT_PER_1 of register PMC_ETIME120_REG_INT_PER_CFG */
    reg_value = etime_reg_INT_PER_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_INT_PER_CFG_BIT_FREE_RUN_INT_PER_1_MSK) >> ETIME120_REG_INT_PER_CFG_BIT_FREE_RUN_INT_PER_1_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_FREE_RUN_INT_PER_1_get", value );

    return value;
}
static INLINE void etime_field_range_FREE_RUN_INT_PER_1_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_FREE_RUN_INT_PER_1_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit,
                                                             UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_FREE_RUN_INT_PER_1_set", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_FREE_RUN_INT_PER_1_set", stop_bit, 7 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_FREE_RUN_INT_PER_1_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000224 bits 7:0) field FREE_RUN_INT_PER_1 of register PMC_ETIME120_REG_INT_PER_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 7) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 7;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000224 bits 7:0) field FREE_RUN_INT_PER_1 of register PMC_ETIME120_REG_INT_PER_CFG */
        etime_reg_INT_PER_CFG_field_set( b_ptr,
                                         h_ptr,
                                         subfield_mask << (ETIME120_REG_INT_PER_CFG_BIT_FREE_RUN_INT_PER_1_OFF + subfield_offset),
                                         ETIME120_REG_INT_PER_CFG_BIT_FREE_RUN_INT_PER_1_OFF + subfield_offset,
                                         value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_FREE_RUN_INT_PER_1_get( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_FREE_RUN_INT_PER_1_get( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_FREE_RUN_INT_PER_1_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_FREE_RUN_INT_PER_1_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000224 bits 7:0) field FREE_RUN_INT_PER_1 of register PMC_ETIME120_REG_INT_PER_CFG */
    reg_value = etime_reg_INT_PER_CFG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_INT_PER_CFG_BIT_FREE_RUN_INT_PER_1_MSK)
                  >> ETIME120_REG_INT_PER_CFG_BIT_FREE_RUN_INT_PER_1_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_INT_PER_CFG_BIT_FREE_RUN_INT_PER_1_MSK, ETIME120_REG_INT_PER_CFG_BIT_FREE_RUN_INT_PER_1_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_FREE_RUN_INT_PER_1_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CC_MAX_RAND_INT_PER_HI_4_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CC_MAX_RAND_INT_PER_HI_4_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value )
{
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CC_MAX_RAND_INT_PER_HI_4_set", value, 15);
    IOLOG( "%s <= 0x%08x", "etime_field_CC_MAX_RAND_INT_PER_HI_4_set", value );

    /* (0x00000228 bits 3:0) field CC_MAX_RAND_INT_PER_HI_4 of register PMC_ETIME120_REG_CC_INT_PER_HI_4_CFG */
    etime_reg_CC_INT_PER_HI_4_CFG_field_set( b_ptr,
                                             h_ptr,
                                             ETIME120_REG_CC_INT_PER_HI_4_CFG_BIT_CC_MAX_RAND_INT_PER_HI_4_MSK,
                                             ETIME120_REG_CC_INT_PER_HI_4_CFG_BIT_CC_MAX_RAND_INT_PER_HI_4_OFF,
                                             value);
}

static INLINE UINT32 etime_field_CC_MAX_RAND_INT_PER_HI_4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CC_MAX_RAND_INT_PER_HI_4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000228 bits 3:0) field CC_MAX_RAND_INT_PER_HI_4 of register PMC_ETIME120_REG_CC_INT_PER_HI_4_CFG */
    reg_value = etime_reg_CC_INT_PER_HI_4_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CC_INT_PER_HI_4_CFG_BIT_CC_MAX_RAND_INT_PER_HI_4_MSK) >> ETIME120_REG_CC_INT_PER_HI_4_CFG_BIT_CC_MAX_RAND_INT_PER_HI_4_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CC_MAX_RAND_INT_PER_HI_4_get", value );

    return value;
}
static INLINE void etime_field_range_CC_MAX_RAND_INT_PER_HI_4_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CC_MAX_RAND_INT_PER_HI_4_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CC_MAX_RAND_INT_PER_HI_4_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CC_MAX_RAND_INT_PER_HI_4_set", stop_bit, 3 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CC_MAX_RAND_INT_PER_HI_4_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000228 bits 3:0) field CC_MAX_RAND_INT_PER_HI_4 of register PMC_ETIME120_REG_CC_INT_PER_HI_4_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000228 bits 3:0) field CC_MAX_RAND_INT_PER_HI_4 of register PMC_ETIME120_REG_CC_INT_PER_HI_4_CFG */
        etime_reg_CC_INT_PER_HI_4_CFG_field_set( b_ptr,
                                                 h_ptr,
                                                 subfield_mask << (ETIME120_REG_CC_INT_PER_HI_4_CFG_BIT_CC_MAX_RAND_INT_PER_HI_4_OFF + subfield_offset),
                                                 ETIME120_REG_CC_INT_PER_HI_4_CFG_BIT_CC_MAX_RAND_INT_PER_HI_4_OFF + subfield_offset,
                                                 value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CC_MAX_RAND_INT_PER_HI_4_get( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CC_MAX_RAND_INT_PER_HI_4_get( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CC_MAX_RAND_INT_PER_HI_4_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CC_MAX_RAND_INT_PER_HI_4_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000228 bits 3:0) field CC_MAX_RAND_INT_PER_HI_4 of register PMC_ETIME120_REG_CC_INT_PER_HI_4_CFG */
    reg_value = etime_reg_CC_INT_PER_HI_4_CFG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CC_INT_PER_HI_4_CFG_BIT_CC_MAX_RAND_INT_PER_HI_4_MSK)
                  >> ETIME120_REG_CC_INT_PER_HI_4_CFG_BIT_CC_MAX_RAND_INT_PER_HI_4_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CC_INT_PER_HI_4_CFG_BIT_CC_MAX_RAND_INT_PER_HI_4_MSK, ETIME120_REG_CC_INT_PER_HI_4_CFG_BIT_CC_MAX_RAND_INT_PER_HI_4_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CC_MAX_RAND_INT_PER_HI_4_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CC_MAX_RAND_INT_PER_HI_3_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CC_MAX_RAND_INT_PER_HI_3_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value )
{
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CC_MAX_RAND_INT_PER_HI_3_set", value, 15);
    IOLOG( "%s <= 0x%08x", "etime_field_CC_MAX_RAND_INT_PER_HI_3_set", value );

    /* (0x0000022c bits 3:0) field CC_MAX_RAND_INT_PER_HI_3 of register PMC_ETIME120_REG_CC_INT_PER_HI_3_CFG */
    etime_reg_CC_INT_PER_HI_3_CFG_field_set( b_ptr,
                                             h_ptr,
                                             ETIME120_REG_CC_INT_PER_HI_3_CFG_BIT_CC_MAX_RAND_INT_PER_HI_3_MSK,
                                             ETIME120_REG_CC_INT_PER_HI_3_CFG_BIT_CC_MAX_RAND_INT_PER_HI_3_OFF,
                                             value);
}

static INLINE UINT32 etime_field_CC_MAX_RAND_INT_PER_HI_3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CC_MAX_RAND_INT_PER_HI_3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000022c bits 3:0) field CC_MAX_RAND_INT_PER_HI_3 of register PMC_ETIME120_REG_CC_INT_PER_HI_3_CFG */
    reg_value = etime_reg_CC_INT_PER_HI_3_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CC_INT_PER_HI_3_CFG_BIT_CC_MAX_RAND_INT_PER_HI_3_MSK) >> ETIME120_REG_CC_INT_PER_HI_3_CFG_BIT_CC_MAX_RAND_INT_PER_HI_3_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CC_MAX_RAND_INT_PER_HI_3_get", value );

    return value;
}
static INLINE void etime_field_range_CC_MAX_RAND_INT_PER_HI_3_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CC_MAX_RAND_INT_PER_HI_3_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CC_MAX_RAND_INT_PER_HI_3_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CC_MAX_RAND_INT_PER_HI_3_set", stop_bit, 3 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CC_MAX_RAND_INT_PER_HI_3_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000022c bits 3:0) field CC_MAX_RAND_INT_PER_HI_3 of register PMC_ETIME120_REG_CC_INT_PER_HI_3_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000022c bits 3:0) field CC_MAX_RAND_INT_PER_HI_3 of register PMC_ETIME120_REG_CC_INT_PER_HI_3_CFG */
        etime_reg_CC_INT_PER_HI_3_CFG_field_set( b_ptr,
                                                 h_ptr,
                                                 subfield_mask << (ETIME120_REG_CC_INT_PER_HI_3_CFG_BIT_CC_MAX_RAND_INT_PER_HI_3_OFF + subfield_offset),
                                                 ETIME120_REG_CC_INT_PER_HI_3_CFG_BIT_CC_MAX_RAND_INT_PER_HI_3_OFF + subfield_offset,
                                                 value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CC_MAX_RAND_INT_PER_HI_3_get( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CC_MAX_RAND_INT_PER_HI_3_get( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CC_MAX_RAND_INT_PER_HI_3_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CC_MAX_RAND_INT_PER_HI_3_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000022c bits 3:0) field CC_MAX_RAND_INT_PER_HI_3 of register PMC_ETIME120_REG_CC_INT_PER_HI_3_CFG */
    reg_value = etime_reg_CC_INT_PER_HI_3_CFG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CC_INT_PER_HI_3_CFG_BIT_CC_MAX_RAND_INT_PER_HI_3_MSK)
                  >> ETIME120_REG_CC_INT_PER_HI_3_CFG_BIT_CC_MAX_RAND_INT_PER_HI_3_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CC_INT_PER_HI_3_CFG_BIT_CC_MAX_RAND_INT_PER_HI_3_MSK, ETIME120_REG_CC_INT_PER_HI_3_CFG_BIT_CC_MAX_RAND_INT_PER_HI_3_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CC_MAX_RAND_INT_PER_HI_3_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CC_MAX_RAND_INT_PER_HI_2_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CC_MAX_RAND_INT_PER_HI_2_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value )
{
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CC_MAX_RAND_INT_PER_HI_2_set", value, 15);
    IOLOG( "%s <= 0x%08x", "etime_field_CC_MAX_RAND_INT_PER_HI_2_set", value );

    /* (0x00000230 bits 3:0) field CC_MAX_RAND_INT_PER_HI_2 of register PMC_ETIME120_REG_CC_INT_PER_HI_2_CFG */
    etime_reg_CC_INT_PER_HI_2_CFG_field_set( b_ptr,
                                             h_ptr,
                                             ETIME120_REG_CC_INT_PER_HI_2_CFG_BIT_CC_MAX_RAND_INT_PER_HI_2_MSK,
                                             ETIME120_REG_CC_INT_PER_HI_2_CFG_BIT_CC_MAX_RAND_INT_PER_HI_2_OFF,
                                             value);
}

static INLINE UINT32 etime_field_CC_MAX_RAND_INT_PER_HI_2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CC_MAX_RAND_INT_PER_HI_2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000230 bits 3:0) field CC_MAX_RAND_INT_PER_HI_2 of register PMC_ETIME120_REG_CC_INT_PER_HI_2_CFG */
    reg_value = etime_reg_CC_INT_PER_HI_2_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CC_INT_PER_HI_2_CFG_BIT_CC_MAX_RAND_INT_PER_HI_2_MSK) >> ETIME120_REG_CC_INT_PER_HI_2_CFG_BIT_CC_MAX_RAND_INT_PER_HI_2_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CC_MAX_RAND_INT_PER_HI_2_get", value );

    return value;
}
static INLINE void etime_field_range_CC_MAX_RAND_INT_PER_HI_2_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CC_MAX_RAND_INT_PER_HI_2_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CC_MAX_RAND_INT_PER_HI_2_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CC_MAX_RAND_INT_PER_HI_2_set", stop_bit, 3 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CC_MAX_RAND_INT_PER_HI_2_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000230 bits 3:0) field CC_MAX_RAND_INT_PER_HI_2 of register PMC_ETIME120_REG_CC_INT_PER_HI_2_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000230 bits 3:0) field CC_MAX_RAND_INT_PER_HI_2 of register PMC_ETIME120_REG_CC_INT_PER_HI_2_CFG */
        etime_reg_CC_INT_PER_HI_2_CFG_field_set( b_ptr,
                                                 h_ptr,
                                                 subfield_mask << (ETIME120_REG_CC_INT_PER_HI_2_CFG_BIT_CC_MAX_RAND_INT_PER_HI_2_OFF + subfield_offset),
                                                 ETIME120_REG_CC_INT_PER_HI_2_CFG_BIT_CC_MAX_RAND_INT_PER_HI_2_OFF + subfield_offset,
                                                 value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CC_MAX_RAND_INT_PER_HI_2_get( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CC_MAX_RAND_INT_PER_HI_2_get( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CC_MAX_RAND_INT_PER_HI_2_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CC_MAX_RAND_INT_PER_HI_2_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000230 bits 3:0) field CC_MAX_RAND_INT_PER_HI_2 of register PMC_ETIME120_REG_CC_INT_PER_HI_2_CFG */
    reg_value = etime_reg_CC_INT_PER_HI_2_CFG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CC_INT_PER_HI_2_CFG_BIT_CC_MAX_RAND_INT_PER_HI_2_MSK)
                  >> ETIME120_REG_CC_INT_PER_HI_2_CFG_BIT_CC_MAX_RAND_INT_PER_HI_2_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CC_INT_PER_HI_2_CFG_BIT_CC_MAX_RAND_INT_PER_HI_2_MSK, ETIME120_REG_CC_INT_PER_HI_2_CFG_BIT_CC_MAX_RAND_INT_PER_HI_2_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CC_MAX_RAND_INT_PER_HI_2_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CC_MAX_RAND_INT_PER_HI_1_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CC_MAX_RAND_INT_PER_HI_1_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value )
{
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CC_MAX_RAND_INT_PER_HI_1_set", value, 15);
    IOLOG( "%s <= 0x%08x", "etime_field_CC_MAX_RAND_INT_PER_HI_1_set", value );

    /* (0x00000234 bits 3:0) field CC_MAX_RAND_INT_PER_HI_1 of register PMC_ETIME120_REG_CC_INT_PER_HI_1_CFG */
    etime_reg_CC_INT_PER_HI_1_CFG_field_set( b_ptr,
                                             h_ptr,
                                             ETIME120_REG_CC_INT_PER_HI_1_CFG_BIT_CC_MAX_RAND_INT_PER_HI_1_MSK,
                                             ETIME120_REG_CC_INT_PER_HI_1_CFG_BIT_CC_MAX_RAND_INT_PER_HI_1_OFF,
                                             value);
}

static INLINE UINT32 etime_field_CC_MAX_RAND_INT_PER_HI_1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CC_MAX_RAND_INT_PER_HI_1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000234 bits 3:0) field CC_MAX_RAND_INT_PER_HI_1 of register PMC_ETIME120_REG_CC_INT_PER_HI_1_CFG */
    reg_value = etime_reg_CC_INT_PER_HI_1_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CC_INT_PER_HI_1_CFG_BIT_CC_MAX_RAND_INT_PER_HI_1_MSK) >> ETIME120_REG_CC_INT_PER_HI_1_CFG_BIT_CC_MAX_RAND_INT_PER_HI_1_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CC_MAX_RAND_INT_PER_HI_1_get", value );

    return value;
}
static INLINE void etime_field_range_CC_MAX_RAND_INT_PER_HI_1_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CC_MAX_RAND_INT_PER_HI_1_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CC_MAX_RAND_INT_PER_HI_1_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CC_MAX_RAND_INT_PER_HI_1_set", stop_bit, 3 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CC_MAX_RAND_INT_PER_HI_1_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000234 bits 3:0) field CC_MAX_RAND_INT_PER_HI_1 of register PMC_ETIME120_REG_CC_INT_PER_HI_1_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000234 bits 3:0) field CC_MAX_RAND_INT_PER_HI_1 of register PMC_ETIME120_REG_CC_INT_PER_HI_1_CFG */
        etime_reg_CC_INT_PER_HI_1_CFG_field_set( b_ptr,
                                                 h_ptr,
                                                 subfield_mask << (ETIME120_REG_CC_INT_PER_HI_1_CFG_BIT_CC_MAX_RAND_INT_PER_HI_1_OFF + subfield_offset),
                                                 ETIME120_REG_CC_INT_PER_HI_1_CFG_BIT_CC_MAX_RAND_INT_PER_HI_1_OFF + subfield_offset,
                                                 value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CC_MAX_RAND_INT_PER_HI_1_get( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CC_MAX_RAND_INT_PER_HI_1_get( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CC_MAX_RAND_INT_PER_HI_1_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CC_MAX_RAND_INT_PER_HI_1_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000234 bits 3:0) field CC_MAX_RAND_INT_PER_HI_1 of register PMC_ETIME120_REG_CC_INT_PER_HI_1_CFG */
    reg_value = etime_reg_CC_INT_PER_HI_1_CFG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CC_INT_PER_HI_1_CFG_BIT_CC_MAX_RAND_INT_PER_HI_1_MSK)
                  >> ETIME120_REG_CC_INT_PER_HI_1_CFG_BIT_CC_MAX_RAND_INT_PER_HI_1_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CC_INT_PER_HI_1_CFG_BIT_CC_MAX_RAND_INT_PER_HI_1_MSK, ETIME120_REG_CC_INT_PER_HI_1_CFG_BIT_CC_MAX_RAND_INT_PER_HI_1_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CC_MAX_RAND_INT_PER_HI_1_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CC_MAX_RAND_INT_PER_LO_4_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CC_MAX_RAND_INT_PER_LO_4_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value )
{
    IOLOG( "%s <= 0x%08x", "etime_field_CC_MAX_RAND_INT_PER_LO_4_set", value );

    /* (0x00000238 bits 31:0) field CC_MAX_RAND_INT_PER_LO_4 of register PMC_ETIME120_REG_CC_INT_PER_4_CFG */
    etime_reg_CC_INT_PER_4_CFG_field_set( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_CC_INT_PER_4_CFG_BIT_CC_MAX_RAND_INT_PER_LO_4_MSK,
                                          ETIME120_REG_CC_INT_PER_4_CFG_BIT_CC_MAX_RAND_INT_PER_LO_4_OFF,
                                          value);
}

static INLINE UINT32 etime_field_CC_MAX_RAND_INT_PER_LO_4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CC_MAX_RAND_INT_PER_LO_4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000238 bits 31:0) field CC_MAX_RAND_INT_PER_LO_4 of register PMC_ETIME120_REG_CC_INT_PER_4_CFG */
    reg_value = etime_reg_CC_INT_PER_4_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CC_INT_PER_4_CFG_BIT_CC_MAX_RAND_INT_PER_LO_4_MSK) >> ETIME120_REG_CC_INT_PER_4_CFG_BIT_CC_MAX_RAND_INT_PER_LO_4_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CC_MAX_RAND_INT_PER_LO_4_get", value );

    return value;
}
static INLINE void etime_field_range_CC_MAX_RAND_INT_PER_LO_4_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CC_MAX_RAND_INT_PER_LO_4_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CC_MAX_RAND_INT_PER_LO_4_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CC_MAX_RAND_INT_PER_LO_4_set", stop_bit, 31 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CC_MAX_RAND_INT_PER_LO_4_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000238 bits 31:0) field CC_MAX_RAND_INT_PER_LO_4 of register PMC_ETIME120_REG_CC_INT_PER_4_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000238 bits 31:0) field CC_MAX_RAND_INT_PER_LO_4 of register PMC_ETIME120_REG_CC_INT_PER_4_CFG */
        etime_reg_CC_INT_PER_4_CFG_field_set( b_ptr,
                                              h_ptr,
                                              subfield_mask << (ETIME120_REG_CC_INT_PER_4_CFG_BIT_CC_MAX_RAND_INT_PER_LO_4_OFF + subfield_offset),
                                              ETIME120_REG_CC_INT_PER_4_CFG_BIT_CC_MAX_RAND_INT_PER_LO_4_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CC_MAX_RAND_INT_PER_LO_4_get( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CC_MAX_RAND_INT_PER_LO_4_get( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CC_MAX_RAND_INT_PER_LO_4_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CC_MAX_RAND_INT_PER_LO_4_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000238 bits 31:0) field CC_MAX_RAND_INT_PER_LO_4 of register PMC_ETIME120_REG_CC_INT_PER_4_CFG */
    reg_value = etime_reg_CC_INT_PER_4_CFG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CC_INT_PER_4_CFG_BIT_CC_MAX_RAND_INT_PER_LO_4_MSK)
                  >> ETIME120_REG_CC_INT_PER_4_CFG_BIT_CC_MAX_RAND_INT_PER_LO_4_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CC_INT_PER_4_CFG_BIT_CC_MAX_RAND_INT_PER_LO_4_MSK, ETIME120_REG_CC_INT_PER_4_CFG_BIT_CC_MAX_RAND_INT_PER_LO_4_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CC_MAX_RAND_INT_PER_LO_4_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CC_MAX_RAND_INT_PER_LO_3_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CC_MAX_RAND_INT_PER_LO_3_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value )
{
    IOLOG( "%s <= 0x%08x", "etime_field_CC_MAX_RAND_INT_PER_LO_3_set", value );

    /* (0x0000023c bits 31:0) field CC_MAX_RAND_INT_PER_LO_3 of register PMC_ETIME120_REG_CC_INT_PER_3_CFG */
    etime_reg_CC_INT_PER_3_CFG_field_set( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_CC_INT_PER_3_CFG_BIT_CC_MAX_RAND_INT_PER_LO_3_MSK,
                                          ETIME120_REG_CC_INT_PER_3_CFG_BIT_CC_MAX_RAND_INT_PER_LO_3_OFF,
                                          value);
}

static INLINE UINT32 etime_field_CC_MAX_RAND_INT_PER_LO_3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CC_MAX_RAND_INT_PER_LO_3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000023c bits 31:0) field CC_MAX_RAND_INT_PER_LO_3 of register PMC_ETIME120_REG_CC_INT_PER_3_CFG */
    reg_value = etime_reg_CC_INT_PER_3_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CC_INT_PER_3_CFG_BIT_CC_MAX_RAND_INT_PER_LO_3_MSK) >> ETIME120_REG_CC_INT_PER_3_CFG_BIT_CC_MAX_RAND_INT_PER_LO_3_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CC_MAX_RAND_INT_PER_LO_3_get", value );

    return value;
}
static INLINE void etime_field_range_CC_MAX_RAND_INT_PER_LO_3_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CC_MAX_RAND_INT_PER_LO_3_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CC_MAX_RAND_INT_PER_LO_3_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CC_MAX_RAND_INT_PER_LO_3_set", stop_bit, 31 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CC_MAX_RAND_INT_PER_LO_3_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000023c bits 31:0) field CC_MAX_RAND_INT_PER_LO_3 of register PMC_ETIME120_REG_CC_INT_PER_3_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000023c bits 31:0) field CC_MAX_RAND_INT_PER_LO_3 of register PMC_ETIME120_REG_CC_INT_PER_3_CFG */
        etime_reg_CC_INT_PER_3_CFG_field_set( b_ptr,
                                              h_ptr,
                                              subfield_mask << (ETIME120_REG_CC_INT_PER_3_CFG_BIT_CC_MAX_RAND_INT_PER_LO_3_OFF + subfield_offset),
                                              ETIME120_REG_CC_INT_PER_3_CFG_BIT_CC_MAX_RAND_INT_PER_LO_3_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CC_MAX_RAND_INT_PER_LO_3_get( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CC_MAX_RAND_INT_PER_LO_3_get( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CC_MAX_RAND_INT_PER_LO_3_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CC_MAX_RAND_INT_PER_LO_3_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000023c bits 31:0) field CC_MAX_RAND_INT_PER_LO_3 of register PMC_ETIME120_REG_CC_INT_PER_3_CFG */
    reg_value = etime_reg_CC_INT_PER_3_CFG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CC_INT_PER_3_CFG_BIT_CC_MAX_RAND_INT_PER_LO_3_MSK)
                  >> ETIME120_REG_CC_INT_PER_3_CFG_BIT_CC_MAX_RAND_INT_PER_LO_3_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CC_INT_PER_3_CFG_BIT_CC_MAX_RAND_INT_PER_LO_3_MSK, ETIME120_REG_CC_INT_PER_3_CFG_BIT_CC_MAX_RAND_INT_PER_LO_3_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CC_MAX_RAND_INT_PER_LO_3_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CC_MAX_RAND_INT_PER_LO_2_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CC_MAX_RAND_INT_PER_LO_2_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value )
{
    IOLOG( "%s <= 0x%08x", "etime_field_CC_MAX_RAND_INT_PER_LO_2_set", value );

    /* (0x00000240 bits 31:0) field CC_MAX_RAND_INT_PER_LO_2 of register PMC_ETIME120_REG_CC_INT_PER_2_CFG */
    etime_reg_CC_INT_PER_2_CFG_field_set( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_CC_INT_PER_2_CFG_BIT_CC_MAX_RAND_INT_PER_LO_2_MSK,
                                          ETIME120_REG_CC_INT_PER_2_CFG_BIT_CC_MAX_RAND_INT_PER_LO_2_OFF,
                                          value);
}

static INLINE UINT32 etime_field_CC_MAX_RAND_INT_PER_LO_2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CC_MAX_RAND_INT_PER_LO_2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000240 bits 31:0) field CC_MAX_RAND_INT_PER_LO_2 of register PMC_ETIME120_REG_CC_INT_PER_2_CFG */
    reg_value = etime_reg_CC_INT_PER_2_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CC_INT_PER_2_CFG_BIT_CC_MAX_RAND_INT_PER_LO_2_MSK) >> ETIME120_REG_CC_INT_PER_2_CFG_BIT_CC_MAX_RAND_INT_PER_LO_2_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CC_MAX_RAND_INT_PER_LO_2_get", value );

    return value;
}
static INLINE void etime_field_range_CC_MAX_RAND_INT_PER_LO_2_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CC_MAX_RAND_INT_PER_LO_2_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CC_MAX_RAND_INT_PER_LO_2_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CC_MAX_RAND_INT_PER_LO_2_set", stop_bit, 31 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CC_MAX_RAND_INT_PER_LO_2_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000240 bits 31:0) field CC_MAX_RAND_INT_PER_LO_2 of register PMC_ETIME120_REG_CC_INT_PER_2_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000240 bits 31:0) field CC_MAX_RAND_INT_PER_LO_2 of register PMC_ETIME120_REG_CC_INT_PER_2_CFG */
        etime_reg_CC_INT_PER_2_CFG_field_set( b_ptr,
                                              h_ptr,
                                              subfield_mask << (ETIME120_REG_CC_INT_PER_2_CFG_BIT_CC_MAX_RAND_INT_PER_LO_2_OFF + subfield_offset),
                                              ETIME120_REG_CC_INT_PER_2_CFG_BIT_CC_MAX_RAND_INT_PER_LO_2_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CC_MAX_RAND_INT_PER_LO_2_get( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CC_MAX_RAND_INT_PER_LO_2_get( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CC_MAX_RAND_INT_PER_LO_2_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CC_MAX_RAND_INT_PER_LO_2_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000240 bits 31:0) field CC_MAX_RAND_INT_PER_LO_2 of register PMC_ETIME120_REG_CC_INT_PER_2_CFG */
    reg_value = etime_reg_CC_INT_PER_2_CFG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CC_INT_PER_2_CFG_BIT_CC_MAX_RAND_INT_PER_LO_2_MSK)
                  >> ETIME120_REG_CC_INT_PER_2_CFG_BIT_CC_MAX_RAND_INT_PER_LO_2_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CC_INT_PER_2_CFG_BIT_CC_MAX_RAND_INT_PER_LO_2_MSK, ETIME120_REG_CC_INT_PER_2_CFG_BIT_CC_MAX_RAND_INT_PER_LO_2_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CC_MAX_RAND_INT_PER_LO_2_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CC_MAX_RAND_INT_PER_LO_1_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CC_MAX_RAND_INT_PER_LO_1_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value )
{
    IOLOG( "%s <= 0x%08x", "etime_field_CC_MAX_RAND_INT_PER_LO_1_set", value );

    /* (0x00000244 bits 31:0) field CC_MAX_RAND_INT_PER_LO_1 of register PMC_ETIME120_REG_CC_INT_PER_1_CFG */
    etime_reg_CC_INT_PER_1_CFG_field_set( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_CC_INT_PER_1_CFG_BIT_CC_MAX_RAND_INT_PER_LO_1_MSK,
                                          ETIME120_REG_CC_INT_PER_1_CFG_BIT_CC_MAX_RAND_INT_PER_LO_1_OFF,
                                          value);
}

static INLINE UINT32 etime_field_CC_MAX_RAND_INT_PER_LO_1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CC_MAX_RAND_INT_PER_LO_1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000244 bits 31:0) field CC_MAX_RAND_INT_PER_LO_1 of register PMC_ETIME120_REG_CC_INT_PER_1_CFG */
    reg_value = etime_reg_CC_INT_PER_1_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CC_INT_PER_1_CFG_BIT_CC_MAX_RAND_INT_PER_LO_1_MSK) >> ETIME120_REG_CC_INT_PER_1_CFG_BIT_CC_MAX_RAND_INT_PER_LO_1_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CC_MAX_RAND_INT_PER_LO_1_get", value );

    return value;
}
static INLINE void etime_field_range_CC_MAX_RAND_INT_PER_LO_1_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CC_MAX_RAND_INT_PER_LO_1_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CC_MAX_RAND_INT_PER_LO_1_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CC_MAX_RAND_INT_PER_LO_1_set", stop_bit, 31 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CC_MAX_RAND_INT_PER_LO_1_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000244 bits 31:0) field CC_MAX_RAND_INT_PER_LO_1 of register PMC_ETIME120_REG_CC_INT_PER_1_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000244 bits 31:0) field CC_MAX_RAND_INT_PER_LO_1 of register PMC_ETIME120_REG_CC_INT_PER_1_CFG */
        etime_reg_CC_INT_PER_1_CFG_field_set( b_ptr,
                                              h_ptr,
                                              subfield_mask << (ETIME120_REG_CC_INT_PER_1_CFG_BIT_CC_MAX_RAND_INT_PER_LO_1_OFF + subfield_offset),
                                              ETIME120_REG_CC_INT_PER_1_CFG_BIT_CC_MAX_RAND_INT_PER_LO_1_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CC_MAX_RAND_INT_PER_LO_1_get( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CC_MAX_RAND_INT_PER_LO_1_get( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CC_MAX_RAND_INT_PER_LO_1_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CC_MAX_RAND_INT_PER_LO_1_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000244 bits 31:0) field CC_MAX_RAND_INT_PER_LO_1 of register PMC_ETIME120_REG_CC_INT_PER_1_CFG */
    reg_value = etime_reg_CC_INT_PER_1_CFG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CC_INT_PER_1_CFG_BIT_CC_MAX_RAND_INT_PER_LO_1_MSK)
                  >> ETIME120_REG_CC_INT_PER_1_CFG_BIT_CC_MAX_RAND_INT_PER_LO_1_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CC_INT_PER_1_CFG_BIT_CC_MAX_RAND_INT_PER_LO_1_MSK, ETIME120_REG_CC_INT_PER_1_CFG_BIT_CC_MAX_RAND_INT_PER_LO_1_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CC_MAX_RAND_INT_PER_LO_1_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_REFL_TIMEOUT_100G_DLY_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_TIMEOUT_100G_DLY_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 value )
{
    if (value > 1023)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_TIMEOUT_100G_DLY_set", value, 1023);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_TIMEOUT_100G_DLY_set", value );

    /* (0x0000024c bits 29:20) field REFL_TIMEOUT_100G_DLY of register PMC_ETIME120_REG_REFL_DLY_CFG */
    etime_reg_REFL_DLY_CFG_field_set( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_100G_DLY_MSK,
                                      ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_100G_DLY_OFF,
                                      value);
}

static INLINE UINT32 etime_field_REFL_TIMEOUT_100G_DLY_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_TIMEOUT_100G_DLY_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000024c bits 29:20) field REFL_TIMEOUT_100G_DLY of register PMC_ETIME120_REG_REFL_DLY_CFG */
    reg_value = etime_reg_REFL_DLY_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_100G_DLY_MSK) >> ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_100G_DLY_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_TIMEOUT_100G_DLY_get", value );

    return value;
}
static INLINE void etime_field_range_REFL_TIMEOUT_100G_DLY_set( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit,
                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_REFL_TIMEOUT_100G_DLY_set( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit,
                                                                UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_REFL_TIMEOUT_100G_DLY_set", stop_bit, start_bit );
    if (stop_bit > 9) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_REFL_TIMEOUT_100G_DLY_set", stop_bit, 9 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_REFL_TIMEOUT_100G_DLY_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000024c bits 29:20) field REFL_TIMEOUT_100G_DLY of register PMC_ETIME120_REG_REFL_DLY_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 9) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 9;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000024c bits 29:20) field REFL_TIMEOUT_100G_DLY of register PMC_ETIME120_REG_REFL_DLY_CFG */
        etime_reg_REFL_DLY_CFG_field_set( b_ptr,
                                          h_ptr,
                                          subfield_mask << (ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_100G_DLY_OFF + subfield_offset),
                                          ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_100G_DLY_OFF + subfield_offset,
                                          value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_REFL_TIMEOUT_100G_DLY_get( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_REFL_TIMEOUT_100G_DLY_get( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_REFL_TIMEOUT_100G_DLY_get", stop_bit, start_bit );
    if (stop_bit > 9) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_REFL_TIMEOUT_100G_DLY_get", stop_bit, 9 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 9) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 9;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000024c bits 29:20) field REFL_TIMEOUT_100G_DLY of register PMC_ETIME120_REG_REFL_DLY_CFG */
    reg_value = etime_reg_REFL_DLY_CFG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_100G_DLY_MSK)
                  >> ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_100G_DLY_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_100G_DLY_MSK, ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_100G_DLY_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_REFL_TIMEOUT_100G_DLY_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_REFL_TIMEOUT_40G_DLY_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_TIMEOUT_40G_DLY_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value )
{
    if (value > 1023)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_TIMEOUT_40G_DLY_set", value, 1023);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_TIMEOUT_40G_DLY_set", value );

    /* (0x0000024c bits 19:10) field REFL_TIMEOUT_40G_DLY of register PMC_ETIME120_REG_REFL_DLY_CFG */
    etime_reg_REFL_DLY_CFG_field_set( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_40G_DLY_MSK,
                                      ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_40G_DLY_OFF,
                                      value);
}

static INLINE UINT32 etime_field_REFL_TIMEOUT_40G_DLY_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_TIMEOUT_40G_DLY_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000024c bits 19:10) field REFL_TIMEOUT_40G_DLY of register PMC_ETIME120_REG_REFL_DLY_CFG */
    reg_value = etime_reg_REFL_DLY_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_40G_DLY_MSK) >> ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_40G_DLY_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_TIMEOUT_40G_DLY_get", value );

    return value;
}
static INLINE void etime_field_range_REFL_TIMEOUT_40G_DLY_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_REFL_TIMEOUT_40G_DLY_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_REFL_TIMEOUT_40G_DLY_set", stop_bit, start_bit );
    if (stop_bit > 9) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_REFL_TIMEOUT_40G_DLY_set", stop_bit, 9 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_REFL_TIMEOUT_40G_DLY_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000024c bits 19:10) field REFL_TIMEOUT_40G_DLY of register PMC_ETIME120_REG_REFL_DLY_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 9) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 9;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000024c bits 19:10) field REFL_TIMEOUT_40G_DLY of register PMC_ETIME120_REG_REFL_DLY_CFG */
        etime_reg_REFL_DLY_CFG_field_set( b_ptr,
                                          h_ptr,
                                          subfield_mask << (ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_40G_DLY_OFF + subfield_offset),
                                          ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_40G_DLY_OFF + subfield_offset,
                                          value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_REFL_TIMEOUT_40G_DLY_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_REFL_TIMEOUT_40G_DLY_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_REFL_TIMEOUT_40G_DLY_get", stop_bit, start_bit );
    if (stop_bit > 9) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_REFL_TIMEOUT_40G_DLY_get", stop_bit, 9 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 9) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 9;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000024c bits 19:10) field REFL_TIMEOUT_40G_DLY of register PMC_ETIME120_REG_REFL_DLY_CFG */
    reg_value = etime_reg_REFL_DLY_CFG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_40G_DLY_MSK)
                  >> ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_40G_DLY_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_40G_DLY_MSK, ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_40G_DLY_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_REFL_TIMEOUT_40G_DLY_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_REFL_TIMEOUT_10G_DLY_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_TIMEOUT_10G_DLY_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value )
{
    if (value > 1023)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_TIMEOUT_10G_DLY_set", value, 1023);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_TIMEOUT_10G_DLY_set", value );

    /* (0x0000024c bits 9:0) field REFL_TIMEOUT_10G_DLY of register PMC_ETIME120_REG_REFL_DLY_CFG */
    etime_reg_REFL_DLY_CFG_field_set( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_10G_DLY_MSK,
                                      ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_10G_DLY_OFF,
                                      value);
}

static INLINE UINT32 etime_field_REFL_TIMEOUT_10G_DLY_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_TIMEOUT_10G_DLY_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000024c bits 9:0) field REFL_TIMEOUT_10G_DLY of register PMC_ETIME120_REG_REFL_DLY_CFG */
    reg_value = etime_reg_REFL_DLY_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_10G_DLY_MSK) >> ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_10G_DLY_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_TIMEOUT_10G_DLY_get", value );

    return value;
}
static INLINE void etime_field_range_REFL_TIMEOUT_10G_DLY_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_REFL_TIMEOUT_10G_DLY_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_REFL_TIMEOUT_10G_DLY_set", stop_bit, start_bit );
    if (stop_bit > 9) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_REFL_TIMEOUT_10G_DLY_set", stop_bit, 9 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_REFL_TIMEOUT_10G_DLY_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000024c bits 9:0) field REFL_TIMEOUT_10G_DLY of register PMC_ETIME120_REG_REFL_DLY_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 9) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 9;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000024c bits 9:0) field REFL_TIMEOUT_10G_DLY of register PMC_ETIME120_REG_REFL_DLY_CFG */
        etime_reg_REFL_DLY_CFG_field_set( b_ptr,
                                          h_ptr,
                                          subfield_mask << (ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_10G_DLY_OFF + subfield_offset),
                                          ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_10G_DLY_OFF + subfield_offset,
                                          value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_REFL_TIMEOUT_10G_DLY_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_REFL_TIMEOUT_10G_DLY_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_REFL_TIMEOUT_10G_DLY_get", stop_bit, start_bit );
    if (stop_bit > 9) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_REFL_TIMEOUT_10G_DLY_get", stop_bit, 9 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 9) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 9;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000024c bits 9:0) field REFL_TIMEOUT_10G_DLY of register PMC_ETIME120_REG_REFL_DLY_CFG */
    reg_value = etime_reg_REFL_DLY_CFG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_10G_DLY_MSK)
                  >> ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_10G_DLY_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_10G_DLY_MSK, ETIME120_REG_REFL_DLY_CFG_BIT_REFL_TIMEOUT_10G_DLY_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_REFL_TIMEOUT_10G_DLY_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_INTERPOL_VAL7_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_INTERPOL_VAL7_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_INTERPOL_VAL7_set", value, 15);
    IOLOG( "%s <= 0x%08x", "etime_field_INTERPOL_VAL7_set", value );

    /* (0x00000250 bits 31:28) field INTERPOL_VAL7 of register PMC_ETIME120_REG_INTERPOL_CFG */
    etime_reg_INTERPOL_CFG_field_set( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL7_MSK,
                                      ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL7_OFF,
                                      value);
}

static INLINE UINT32 etime_field_INTERPOL_VAL7_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_INTERPOL_VAL7_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000250 bits 31:28) field INTERPOL_VAL7 of register PMC_ETIME120_REG_INTERPOL_CFG */
    reg_value = etime_reg_INTERPOL_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL7_MSK) >> ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL7_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_INTERPOL_VAL7_get", value );

    return value;
}
static INLINE void etime_field_range_INTERPOL_VAL7_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_INTERPOL_VAL7_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_INTERPOL_VAL7_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_INTERPOL_VAL7_set", stop_bit, 3 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_INTERPOL_VAL7_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000250 bits 31:28) field INTERPOL_VAL7 of register PMC_ETIME120_REG_INTERPOL_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000250 bits 31:28) field INTERPOL_VAL7 of register PMC_ETIME120_REG_INTERPOL_CFG */
        etime_reg_INTERPOL_CFG_field_set( b_ptr,
                                          h_ptr,
                                          subfield_mask << (ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL7_OFF + subfield_offset),
                                          ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL7_OFF + subfield_offset,
                                          value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_INTERPOL_VAL7_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_INTERPOL_VAL7_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_INTERPOL_VAL7_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_INTERPOL_VAL7_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000250 bits 31:28) field INTERPOL_VAL7 of register PMC_ETIME120_REG_INTERPOL_CFG */
    reg_value = etime_reg_INTERPOL_CFG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL7_MSK)
                  >> ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL7_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL7_MSK, ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL7_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_INTERPOL_VAL7_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_INTERPOL_VAL6_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_INTERPOL_VAL6_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_INTERPOL_VAL6_set", value, 15);
    IOLOG( "%s <= 0x%08x", "etime_field_INTERPOL_VAL6_set", value );

    /* (0x00000250 bits 27:24) field INTERPOL_VAL6 of register PMC_ETIME120_REG_INTERPOL_CFG */
    etime_reg_INTERPOL_CFG_field_set( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL6_MSK,
                                      ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL6_OFF,
                                      value);
}

static INLINE UINT32 etime_field_INTERPOL_VAL6_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_INTERPOL_VAL6_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000250 bits 27:24) field INTERPOL_VAL6 of register PMC_ETIME120_REG_INTERPOL_CFG */
    reg_value = etime_reg_INTERPOL_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL6_MSK) >> ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL6_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_INTERPOL_VAL6_get", value );

    return value;
}
static INLINE void etime_field_range_INTERPOL_VAL6_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_INTERPOL_VAL6_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_INTERPOL_VAL6_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_INTERPOL_VAL6_set", stop_bit, 3 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_INTERPOL_VAL6_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000250 bits 27:24) field INTERPOL_VAL6 of register PMC_ETIME120_REG_INTERPOL_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000250 bits 27:24) field INTERPOL_VAL6 of register PMC_ETIME120_REG_INTERPOL_CFG */
        etime_reg_INTERPOL_CFG_field_set( b_ptr,
                                          h_ptr,
                                          subfield_mask << (ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL6_OFF + subfield_offset),
                                          ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL6_OFF + subfield_offset,
                                          value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_INTERPOL_VAL6_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_INTERPOL_VAL6_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_INTERPOL_VAL6_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_INTERPOL_VAL6_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000250 bits 27:24) field INTERPOL_VAL6 of register PMC_ETIME120_REG_INTERPOL_CFG */
    reg_value = etime_reg_INTERPOL_CFG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL6_MSK)
                  >> ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL6_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL6_MSK, ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL6_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_INTERPOL_VAL6_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_INTERPOL_VAL5_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_INTERPOL_VAL5_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_INTERPOL_VAL5_set", value, 15);
    IOLOG( "%s <= 0x%08x", "etime_field_INTERPOL_VAL5_set", value );

    /* (0x00000250 bits 23:20) field INTERPOL_VAL5 of register PMC_ETIME120_REG_INTERPOL_CFG */
    etime_reg_INTERPOL_CFG_field_set( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL5_MSK,
                                      ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL5_OFF,
                                      value);
}

static INLINE UINT32 etime_field_INTERPOL_VAL5_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_INTERPOL_VAL5_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000250 bits 23:20) field INTERPOL_VAL5 of register PMC_ETIME120_REG_INTERPOL_CFG */
    reg_value = etime_reg_INTERPOL_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL5_MSK) >> ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL5_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_INTERPOL_VAL5_get", value );

    return value;
}
static INLINE void etime_field_range_INTERPOL_VAL5_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_INTERPOL_VAL5_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_INTERPOL_VAL5_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_INTERPOL_VAL5_set", stop_bit, 3 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_INTERPOL_VAL5_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000250 bits 23:20) field INTERPOL_VAL5 of register PMC_ETIME120_REG_INTERPOL_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000250 bits 23:20) field INTERPOL_VAL5 of register PMC_ETIME120_REG_INTERPOL_CFG */
        etime_reg_INTERPOL_CFG_field_set( b_ptr,
                                          h_ptr,
                                          subfield_mask << (ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL5_OFF + subfield_offset),
                                          ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL5_OFF + subfield_offset,
                                          value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_INTERPOL_VAL5_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_INTERPOL_VAL5_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_INTERPOL_VAL5_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_INTERPOL_VAL5_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000250 bits 23:20) field INTERPOL_VAL5 of register PMC_ETIME120_REG_INTERPOL_CFG */
    reg_value = etime_reg_INTERPOL_CFG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL5_MSK)
                  >> ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL5_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL5_MSK, ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL5_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_INTERPOL_VAL5_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_INTERPOL_VAL4_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_INTERPOL_VAL4_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_INTERPOL_VAL4_set", value, 15);
    IOLOG( "%s <= 0x%08x", "etime_field_INTERPOL_VAL4_set", value );

    /* (0x00000250 bits 19:16) field INTERPOL_VAL4 of register PMC_ETIME120_REG_INTERPOL_CFG */
    etime_reg_INTERPOL_CFG_field_set( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL4_MSK,
                                      ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL4_OFF,
                                      value);
}

static INLINE UINT32 etime_field_INTERPOL_VAL4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_INTERPOL_VAL4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000250 bits 19:16) field INTERPOL_VAL4 of register PMC_ETIME120_REG_INTERPOL_CFG */
    reg_value = etime_reg_INTERPOL_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL4_MSK) >> ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL4_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_INTERPOL_VAL4_get", value );

    return value;
}
static INLINE void etime_field_range_INTERPOL_VAL4_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_INTERPOL_VAL4_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_INTERPOL_VAL4_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_INTERPOL_VAL4_set", stop_bit, 3 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_INTERPOL_VAL4_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000250 bits 19:16) field INTERPOL_VAL4 of register PMC_ETIME120_REG_INTERPOL_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000250 bits 19:16) field INTERPOL_VAL4 of register PMC_ETIME120_REG_INTERPOL_CFG */
        etime_reg_INTERPOL_CFG_field_set( b_ptr,
                                          h_ptr,
                                          subfield_mask << (ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL4_OFF + subfield_offset),
                                          ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL4_OFF + subfield_offset,
                                          value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_INTERPOL_VAL4_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_INTERPOL_VAL4_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_INTERPOL_VAL4_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_INTERPOL_VAL4_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000250 bits 19:16) field INTERPOL_VAL4 of register PMC_ETIME120_REG_INTERPOL_CFG */
    reg_value = etime_reg_INTERPOL_CFG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL4_MSK)
                  >> ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL4_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL4_MSK, ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL4_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_INTERPOL_VAL4_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_INTERPOL_VAL3_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_INTERPOL_VAL3_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_INTERPOL_VAL3_set", value, 15);
    IOLOG( "%s <= 0x%08x", "etime_field_INTERPOL_VAL3_set", value );

    /* (0x00000250 bits 15:12) field INTERPOL_VAL3 of register PMC_ETIME120_REG_INTERPOL_CFG */
    etime_reg_INTERPOL_CFG_field_set( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL3_MSK,
                                      ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL3_OFF,
                                      value);
}

static INLINE UINT32 etime_field_INTERPOL_VAL3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_INTERPOL_VAL3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000250 bits 15:12) field INTERPOL_VAL3 of register PMC_ETIME120_REG_INTERPOL_CFG */
    reg_value = etime_reg_INTERPOL_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL3_MSK) >> ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL3_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_INTERPOL_VAL3_get", value );

    return value;
}
static INLINE void etime_field_range_INTERPOL_VAL3_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_INTERPOL_VAL3_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_INTERPOL_VAL3_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_INTERPOL_VAL3_set", stop_bit, 3 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_INTERPOL_VAL3_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000250 bits 15:12) field INTERPOL_VAL3 of register PMC_ETIME120_REG_INTERPOL_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000250 bits 15:12) field INTERPOL_VAL3 of register PMC_ETIME120_REG_INTERPOL_CFG */
        etime_reg_INTERPOL_CFG_field_set( b_ptr,
                                          h_ptr,
                                          subfield_mask << (ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL3_OFF + subfield_offset),
                                          ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL3_OFF + subfield_offset,
                                          value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_INTERPOL_VAL3_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_INTERPOL_VAL3_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_INTERPOL_VAL3_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_INTERPOL_VAL3_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000250 bits 15:12) field INTERPOL_VAL3 of register PMC_ETIME120_REG_INTERPOL_CFG */
    reg_value = etime_reg_INTERPOL_CFG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL3_MSK)
                  >> ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL3_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL3_MSK, ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL3_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_INTERPOL_VAL3_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_INTERPOL_VAL2_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_INTERPOL_VAL2_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_INTERPOL_VAL2_set", value, 15);
    IOLOG( "%s <= 0x%08x", "etime_field_INTERPOL_VAL2_set", value );

    /* (0x00000250 bits 11:8) field INTERPOL_VAL2 of register PMC_ETIME120_REG_INTERPOL_CFG */
    etime_reg_INTERPOL_CFG_field_set( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL2_MSK,
                                      ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL2_OFF,
                                      value);
}

static INLINE UINT32 etime_field_INTERPOL_VAL2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_INTERPOL_VAL2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000250 bits 11:8) field INTERPOL_VAL2 of register PMC_ETIME120_REG_INTERPOL_CFG */
    reg_value = etime_reg_INTERPOL_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL2_MSK) >> ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL2_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_INTERPOL_VAL2_get", value );

    return value;
}
static INLINE void etime_field_range_INTERPOL_VAL2_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_INTERPOL_VAL2_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_INTERPOL_VAL2_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_INTERPOL_VAL2_set", stop_bit, 3 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_INTERPOL_VAL2_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000250 bits 11:8) field INTERPOL_VAL2 of register PMC_ETIME120_REG_INTERPOL_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000250 bits 11:8) field INTERPOL_VAL2 of register PMC_ETIME120_REG_INTERPOL_CFG */
        etime_reg_INTERPOL_CFG_field_set( b_ptr,
                                          h_ptr,
                                          subfield_mask << (ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL2_OFF + subfield_offset),
                                          ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL2_OFF + subfield_offset,
                                          value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_INTERPOL_VAL2_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_INTERPOL_VAL2_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_INTERPOL_VAL2_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_INTERPOL_VAL2_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000250 bits 11:8) field INTERPOL_VAL2 of register PMC_ETIME120_REG_INTERPOL_CFG */
    reg_value = etime_reg_INTERPOL_CFG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL2_MSK)
                  >> ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL2_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL2_MSK, ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL2_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_INTERPOL_VAL2_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_INTERPOL_VAL1_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_INTERPOL_VAL1_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_INTERPOL_VAL1_set", value, 15);
    IOLOG( "%s <= 0x%08x", "etime_field_INTERPOL_VAL1_set", value );

    /* (0x00000250 bits 7:4) field INTERPOL_VAL1 of register PMC_ETIME120_REG_INTERPOL_CFG */
    etime_reg_INTERPOL_CFG_field_set( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL1_MSK,
                                      ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL1_OFF,
                                      value);
}

static INLINE UINT32 etime_field_INTERPOL_VAL1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_INTERPOL_VAL1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000250 bits 7:4) field INTERPOL_VAL1 of register PMC_ETIME120_REG_INTERPOL_CFG */
    reg_value = etime_reg_INTERPOL_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL1_MSK) >> ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL1_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_INTERPOL_VAL1_get", value );

    return value;
}
static INLINE void etime_field_range_INTERPOL_VAL1_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_INTERPOL_VAL1_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_INTERPOL_VAL1_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_INTERPOL_VAL1_set", stop_bit, 3 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_INTERPOL_VAL1_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000250 bits 7:4) field INTERPOL_VAL1 of register PMC_ETIME120_REG_INTERPOL_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000250 bits 7:4) field INTERPOL_VAL1 of register PMC_ETIME120_REG_INTERPOL_CFG */
        etime_reg_INTERPOL_CFG_field_set( b_ptr,
                                          h_ptr,
                                          subfield_mask << (ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL1_OFF + subfield_offset),
                                          ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL1_OFF + subfield_offset,
                                          value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_INTERPOL_VAL1_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_INTERPOL_VAL1_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_INTERPOL_VAL1_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_INTERPOL_VAL1_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000250 bits 7:4) field INTERPOL_VAL1 of register PMC_ETIME120_REG_INTERPOL_CFG */
    reg_value = etime_reg_INTERPOL_CFG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL1_MSK)
                  >> ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL1_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL1_MSK, ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL1_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_INTERPOL_VAL1_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_INTERPOL_VAL0_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_INTERPOL_VAL0_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_INTERPOL_VAL0_set", value, 15);
    IOLOG( "%s <= 0x%08x", "etime_field_INTERPOL_VAL0_set", value );

    /* (0x00000250 bits 3:0) field INTERPOL_VAL0 of register PMC_ETIME120_REG_INTERPOL_CFG */
    etime_reg_INTERPOL_CFG_field_set( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL0_MSK,
                                      ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL0_OFF,
                                      value);
}

static INLINE UINT32 etime_field_INTERPOL_VAL0_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_INTERPOL_VAL0_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000250 bits 3:0) field INTERPOL_VAL0 of register PMC_ETIME120_REG_INTERPOL_CFG */
    reg_value = etime_reg_INTERPOL_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL0_MSK) >> ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL0_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_INTERPOL_VAL0_get", value );

    return value;
}
static INLINE void etime_field_range_INTERPOL_VAL0_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_INTERPOL_VAL0_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_INTERPOL_VAL0_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_INTERPOL_VAL0_set", stop_bit, 3 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_INTERPOL_VAL0_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000250 bits 3:0) field INTERPOL_VAL0 of register PMC_ETIME120_REG_INTERPOL_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000250 bits 3:0) field INTERPOL_VAL0 of register PMC_ETIME120_REG_INTERPOL_CFG */
        etime_reg_INTERPOL_CFG_field_set( b_ptr,
                                          h_ptr,
                                          subfield_mask << (ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL0_OFF + subfield_offset),
                                          ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL0_OFF + subfield_offset,
                                          value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_INTERPOL_VAL0_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_INTERPOL_VAL0_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_INTERPOL_VAL0_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_INTERPOL_VAL0_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000250 bits 3:0) field INTERPOL_VAL0 of register PMC_ETIME120_REG_INTERPOL_CFG */
    reg_value = etime_reg_INTERPOL_CFG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL0_MSK)
                  >> ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL0_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL0_MSK, ETIME120_REG_INTERPOL_CFG_BIT_INTERPOL_VAL0_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_INTERPOL_VAL0_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CAPT_OFFS_EXT_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CAPT_OFFS_EXT_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1023)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CAPT_OFFS_EXT_set", value, 1023);
    IOLOG( "%s <= 0x%08x", "etime_field_CAPT_OFFS_EXT_set", value );

    /* (0x00000254 bits 29:20) field CAPT_OFFS_EXT of register PMC_ETIME120_REG_CAPT_OFFS */
    etime_reg_CAPT_OFFS_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_EXT_MSK,
                                   ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_EXT_OFF,
                                   value);
}

static INLINE UINT32 etime_field_CAPT_OFFS_EXT_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CAPT_OFFS_EXT_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000254 bits 29:20) field CAPT_OFFS_EXT of register PMC_ETIME120_REG_CAPT_OFFS */
    reg_value = etime_reg_CAPT_OFFS_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_EXT_MSK) >> ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_EXT_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CAPT_OFFS_EXT_get", value );

    return value;
}
static INLINE void etime_field_range_CAPT_OFFS_EXT_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CAPT_OFFS_EXT_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CAPT_OFFS_EXT_set", stop_bit, start_bit );
    if (stop_bit > 9) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CAPT_OFFS_EXT_set", stop_bit, 9 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CAPT_OFFS_EXT_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000254 bits 29:20) field CAPT_OFFS_EXT of register PMC_ETIME120_REG_CAPT_OFFS */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 9) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 9;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000254 bits 29:20) field CAPT_OFFS_EXT of register PMC_ETIME120_REG_CAPT_OFFS */
        etime_reg_CAPT_OFFS_field_set( b_ptr,
                                       h_ptr,
                                       subfield_mask << (ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_EXT_OFF + subfield_offset),
                                       ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_EXT_OFF + subfield_offset,
                                       value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CAPT_OFFS_EXT_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CAPT_OFFS_EXT_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CAPT_OFFS_EXT_get", stop_bit, start_bit );
    if (stop_bit > 9) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CAPT_OFFS_EXT_get", stop_bit, 9 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 9) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 9;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000254 bits 29:20) field CAPT_OFFS_EXT of register PMC_ETIME120_REG_CAPT_OFFS */
    reg_value = etime_reg_CAPT_OFFS_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_EXT_MSK)
                  >> ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_EXT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_EXT_MSK, ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_EXT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CAPT_OFFS_EXT_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CAPT_OFFS_IRIGI_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CAPT_OFFS_IRIGI_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    if (value > 1023)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CAPT_OFFS_IRIGI_set", value, 1023);
    IOLOG( "%s <= 0x%08x", "etime_field_CAPT_OFFS_IRIGI_set", value );

    /* (0x00000254 bits 19:10) field CAPT_OFFS_IRIGI of register PMC_ETIME120_REG_CAPT_OFFS */
    etime_reg_CAPT_OFFS_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_IRIGI_MSK,
                                   ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_IRIGI_OFF,
                                   value);
}

static INLINE UINT32 etime_field_CAPT_OFFS_IRIGI_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CAPT_OFFS_IRIGI_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000254 bits 19:10) field CAPT_OFFS_IRIGI of register PMC_ETIME120_REG_CAPT_OFFS */
    reg_value = etime_reg_CAPT_OFFS_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_IRIGI_MSK) >> ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_IRIGI_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CAPT_OFFS_IRIGI_get", value );

    return value;
}
static INLINE void etime_field_range_CAPT_OFFS_IRIGI_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CAPT_OFFS_IRIGI_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CAPT_OFFS_IRIGI_set", stop_bit, start_bit );
    if (stop_bit > 9) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CAPT_OFFS_IRIGI_set", stop_bit, 9 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CAPT_OFFS_IRIGI_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000254 bits 19:10) field CAPT_OFFS_IRIGI of register PMC_ETIME120_REG_CAPT_OFFS */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 9) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 9;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000254 bits 19:10) field CAPT_OFFS_IRIGI of register PMC_ETIME120_REG_CAPT_OFFS */
        etime_reg_CAPT_OFFS_field_set( b_ptr,
                                       h_ptr,
                                       subfield_mask << (ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_IRIGI_OFF + subfield_offset),
                                       ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_IRIGI_OFF + subfield_offset,
                                       value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CAPT_OFFS_IRIGI_get( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CAPT_OFFS_IRIGI_get( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CAPT_OFFS_IRIGI_get", stop_bit, start_bit );
    if (stop_bit > 9) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CAPT_OFFS_IRIGI_get", stop_bit, 9 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 9) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 9;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000254 bits 19:10) field CAPT_OFFS_IRIGI of register PMC_ETIME120_REG_CAPT_OFFS */
    reg_value = etime_reg_CAPT_OFFS_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_IRIGI_MSK)
                  >> ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_IRIGI_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_IRIGI_MSK, ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_IRIGI_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CAPT_OFFS_IRIGI_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_CAPT_OFFS_IRIGO_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CAPT_OFFS_IRIGO_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    if (value > 1023)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CAPT_OFFS_IRIGO_set", value, 1023);
    IOLOG( "%s <= 0x%08x", "etime_field_CAPT_OFFS_IRIGO_set", value );

    /* (0x00000254 bits 9:0) field CAPT_OFFS_IRIGO of register PMC_ETIME120_REG_CAPT_OFFS */
    etime_reg_CAPT_OFFS_field_set( b_ptr,
                                   h_ptr,
                                   ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_IRIGO_MSK,
                                   ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_IRIGO_OFF,
                                   value);
}

static INLINE UINT32 etime_field_CAPT_OFFS_IRIGO_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CAPT_OFFS_IRIGO_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000254 bits 9:0) field CAPT_OFFS_IRIGO of register PMC_ETIME120_REG_CAPT_OFFS */
    reg_value = etime_reg_CAPT_OFFS_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_IRIGO_MSK) >> ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_IRIGO_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CAPT_OFFS_IRIGO_get", value );

    return value;
}
static INLINE void etime_field_range_CAPT_OFFS_IRIGO_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_CAPT_OFFS_IRIGO_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CAPT_OFFS_IRIGO_set", stop_bit, start_bit );
    if (stop_bit > 9) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CAPT_OFFS_IRIGO_set", stop_bit, 9 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CAPT_OFFS_IRIGO_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000254 bits 9:0) field CAPT_OFFS_IRIGO of register PMC_ETIME120_REG_CAPT_OFFS */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 9) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 9;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000254 bits 9:0) field CAPT_OFFS_IRIGO of register PMC_ETIME120_REG_CAPT_OFFS */
        etime_reg_CAPT_OFFS_field_set( b_ptr,
                                       h_ptr,
                                       subfield_mask << (ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_IRIGO_OFF + subfield_offset),
                                       ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_IRIGO_OFF + subfield_offset,
                                       value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_CAPT_OFFS_IRIGO_get( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CAPT_OFFS_IRIGO_get( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CAPT_OFFS_IRIGO_get", stop_bit, start_bit );
    if (stop_bit > 9) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CAPT_OFFS_IRIGO_get", stop_bit, 9 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 9) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 9;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000254 bits 9:0) field CAPT_OFFS_IRIGO of register PMC_ETIME120_REG_CAPT_OFFS */
    reg_value = etime_reg_CAPT_OFFS_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_IRIGO_MSK)
                  >> ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_IRIGO_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_IRIGO_MSK, ETIME120_REG_CAPT_OFFS_BIT_CAPT_OFFS_IRIGO_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CAPT_OFFS_IRIGO_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_EXT_CPB_LINK_SCH_TS7_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EXT_CPB_LINK_SCH_TS7_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value )
{
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS7_set", value, 15);
    IOLOG( "%s <= 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS7_set", value );

    /* (0x00000288 bits 31:28) field EXT_CPB_LINK_SCH_TS7 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    etime_reg_EXT_CPB_LSC_LOW_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS7_MSK,
                                         ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS7_OFF,
                                         value);
}

static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_TS7_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_TS7_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000288 bits 31:28) field EXT_CPB_LINK_SCH_TS7 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    reg_value = etime_reg_EXT_CPB_LSC_LOW_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS7_MSK) >> ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS7_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS7_get", value );

    return value;
}
static INLINE void etime_field_range_EXT_CPB_LINK_SCH_TS7_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_EXT_CPB_LINK_SCH_TS7_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_CPB_LINK_SCH_TS7_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_CPB_LINK_SCH_TS7_set", stop_bit, 3 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_CPB_LINK_SCH_TS7_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000288 bits 31:28) field EXT_CPB_LINK_SCH_TS7 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000288 bits 31:28) field EXT_CPB_LINK_SCH_TS7 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
        etime_reg_EXT_CPB_LSC_LOW_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS7_OFF + subfield_offset),
                                             ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS7_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_EXT_CPB_LINK_SCH_TS7_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_EXT_CPB_LINK_SCH_TS7_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_CPB_LINK_SCH_TS7_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_CPB_LINK_SCH_TS7_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000288 bits 31:28) field EXT_CPB_LINK_SCH_TS7 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    reg_value = etime_reg_EXT_CPB_LSC_LOW_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS7_MSK)
                  >> ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS7_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS7_MSK, ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS7_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_CPB_LINK_SCH_TS7_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_EXT_CPB_LINK_SCH_TS6_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EXT_CPB_LINK_SCH_TS6_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value )
{
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS6_set", value, 15);
    IOLOG( "%s <= 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS6_set", value );

    /* (0x00000288 bits 27:24) field EXT_CPB_LINK_SCH_TS6 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    etime_reg_EXT_CPB_LSC_LOW_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS6_MSK,
                                         ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS6_OFF,
                                         value);
}

static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_TS6_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_TS6_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000288 bits 27:24) field EXT_CPB_LINK_SCH_TS6 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    reg_value = etime_reg_EXT_CPB_LSC_LOW_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS6_MSK) >> ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS6_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS6_get", value );

    return value;
}
static INLINE void etime_field_range_EXT_CPB_LINK_SCH_TS6_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_EXT_CPB_LINK_SCH_TS6_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_CPB_LINK_SCH_TS6_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_CPB_LINK_SCH_TS6_set", stop_bit, 3 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_CPB_LINK_SCH_TS6_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000288 bits 27:24) field EXT_CPB_LINK_SCH_TS6 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000288 bits 27:24) field EXT_CPB_LINK_SCH_TS6 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
        etime_reg_EXT_CPB_LSC_LOW_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS6_OFF + subfield_offset),
                                             ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS6_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_EXT_CPB_LINK_SCH_TS6_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_EXT_CPB_LINK_SCH_TS6_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_CPB_LINK_SCH_TS6_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_CPB_LINK_SCH_TS6_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000288 bits 27:24) field EXT_CPB_LINK_SCH_TS6 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    reg_value = etime_reg_EXT_CPB_LSC_LOW_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS6_MSK)
                  >> ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS6_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS6_MSK, ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS6_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_CPB_LINK_SCH_TS6_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_EXT_CPB_LINK_SCH_TS5_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EXT_CPB_LINK_SCH_TS5_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value )
{
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS5_set", value, 15);
    IOLOG( "%s <= 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS5_set", value );

    /* (0x00000288 bits 23:20) field EXT_CPB_LINK_SCH_TS5 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    etime_reg_EXT_CPB_LSC_LOW_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS5_MSK,
                                         ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS5_OFF,
                                         value);
}

static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_TS5_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_TS5_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000288 bits 23:20) field EXT_CPB_LINK_SCH_TS5 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    reg_value = etime_reg_EXT_CPB_LSC_LOW_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS5_MSK) >> ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS5_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS5_get", value );

    return value;
}
static INLINE void etime_field_range_EXT_CPB_LINK_SCH_TS5_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_EXT_CPB_LINK_SCH_TS5_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_CPB_LINK_SCH_TS5_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_CPB_LINK_SCH_TS5_set", stop_bit, 3 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_CPB_LINK_SCH_TS5_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000288 bits 23:20) field EXT_CPB_LINK_SCH_TS5 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000288 bits 23:20) field EXT_CPB_LINK_SCH_TS5 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
        etime_reg_EXT_CPB_LSC_LOW_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS5_OFF + subfield_offset),
                                             ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS5_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_EXT_CPB_LINK_SCH_TS5_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_EXT_CPB_LINK_SCH_TS5_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_CPB_LINK_SCH_TS5_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_CPB_LINK_SCH_TS5_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000288 bits 23:20) field EXT_CPB_LINK_SCH_TS5 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    reg_value = etime_reg_EXT_CPB_LSC_LOW_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS5_MSK)
                  >> ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS5_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS5_MSK, ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS5_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_CPB_LINK_SCH_TS5_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_EXT_CPB_LINK_SCH_TS4_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EXT_CPB_LINK_SCH_TS4_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value )
{
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS4_set", value, 15);
    IOLOG( "%s <= 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS4_set", value );

    /* (0x00000288 bits 19:16) field EXT_CPB_LINK_SCH_TS4 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    etime_reg_EXT_CPB_LSC_LOW_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS4_MSK,
                                         ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS4_OFF,
                                         value);
}

static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_TS4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_TS4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000288 bits 19:16) field EXT_CPB_LINK_SCH_TS4 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    reg_value = etime_reg_EXT_CPB_LSC_LOW_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS4_MSK) >> ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS4_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS4_get", value );

    return value;
}
static INLINE void etime_field_range_EXT_CPB_LINK_SCH_TS4_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_EXT_CPB_LINK_SCH_TS4_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_CPB_LINK_SCH_TS4_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_CPB_LINK_SCH_TS4_set", stop_bit, 3 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_CPB_LINK_SCH_TS4_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000288 bits 19:16) field EXT_CPB_LINK_SCH_TS4 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000288 bits 19:16) field EXT_CPB_LINK_SCH_TS4 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
        etime_reg_EXT_CPB_LSC_LOW_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS4_OFF + subfield_offset),
                                             ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS4_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_EXT_CPB_LINK_SCH_TS4_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_EXT_CPB_LINK_SCH_TS4_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_CPB_LINK_SCH_TS4_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_CPB_LINK_SCH_TS4_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000288 bits 19:16) field EXT_CPB_LINK_SCH_TS4 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    reg_value = etime_reg_EXT_CPB_LSC_LOW_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS4_MSK)
                  >> ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS4_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS4_MSK, ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS4_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_CPB_LINK_SCH_TS4_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_EXT_CPB_LINK_SCH_TS3_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EXT_CPB_LINK_SCH_TS3_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value )
{
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS3_set", value, 15);
    IOLOG( "%s <= 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS3_set", value );

    /* (0x00000288 bits 15:12) field EXT_CPB_LINK_SCH_TS3 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    etime_reg_EXT_CPB_LSC_LOW_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS3_MSK,
                                         ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS3_OFF,
                                         value);
}

static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_TS3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_TS3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000288 bits 15:12) field EXT_CPB_LINK_SCH_TS3 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    reg_value = etime_reg_EXT_CPB_LSC_LOW_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS3_MSK) >> ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS3_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS3_get", value );

    return value;
}
static INLINE void etime_field_range_EXT_CPB_LINK_SCH_TS3_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_EXT_CPB_LINK_SCH_TS3_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_CPB_LINK_SCH_TS3_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_CPB_LINK_SCH_TS3_set", stop_bit, 3 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_CPB_LINK_SCH_TS3_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000288 bits 15:12) field EXT_CPB_LINK_SCH_TS3 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000288 bits 15:12) field EXT_CPB_LINK_SCH_TS3 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
        etime_reg_EXT_CPB_LSC_LOW_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS3_OFF + subfield_offset),
                                             ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS3_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_EXT_CPB_LINK_SCH_TS3_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_EXT_CPB_LINK_SCH_TS3_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_CPB_LINK_SCH_TS3_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_CPB_LINK_SCH_TS3_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000288 bits 15:12) field EXT_CPB_LINK_SCH_TS3 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    reg_value = etime_reg_EXT_CPB_LSC_LOW_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS3_MSK)
                  >> ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS3_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS3_MSK, ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS3_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_CPB_LINK_SCH_TS3_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_EXT_CPB_LINK_SCH_TS2_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EXT_CPB_LINK_SCH_TS2_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value )
{
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS2_set", value, 15);
    IOLOG( "%s <= 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS2_set", value );

    /* (0x00000288 bits 11:8) field EXT_CPB_LINK_SCH_TS2 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    etime_reg_EXT_CPB_LSC_LOW_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS2_MSK,
                                         ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS2_OFF,
                                         value);
}

static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_TS2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_TS2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000288 bits 11:8) field EXT_CPB_LINK_SCH_TS2 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    reg_value = etime_reg_EXT_CPB_LSC_LOW_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS2_MSK) >> ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS2_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS2_get", value );

    return value;
}
static INLINE void etime_field_range_EXT_CPB_LINK_SCH_TS2_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_EXT_CPB_LINK_SCH_TS2_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_CPB_LINK_SCH_TS2_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_CPB_LINK_SCH_TS2_set", stop_bit, 3 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_CPB_LINK_SCH_TS2_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000288 bits 11:8) field EXT_CPB_LINK_SCH_TS2 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000288 bits 11:8) field EXT_CPB_LINK_SCH_TS2 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
        etime_reg_EXT_CPB_LSC_LOW_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS2_OFF + subfield_offset),
                                             ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS2_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_EXT_CPB_LINK_SCH_TS2_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_EXT_CPB_LINK_SCH_TS2_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_CPB_LINK_SCH_TS2_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_CPB_LINK_SCH_TS2_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000288 bits 11:8) field EXT_CPB_LINK_SCH_TS2 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    reg_value = etime_reg_EXT_CPB_LSC_LOW_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS2_MSK)
                  >> ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS2_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS2_MSK, ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS2_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_CPB_LINK_SCH_TS2_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_EXT_CPB_LINK_SCH_TS1_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EXT_CPB_LINK_SCH_TS1_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value )
{
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS1_set", value, 15);
    IOLOG( "%s <= 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS1_set", value );

    /* (0x00000288 bits 7:4) field EXT_CPB_LINK_SCH_TS1 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    etime_reg_EXT_CPB_LSC_LOW_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS1_MSK,
                                         ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS1_OFF,
                                         value);
}

static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_TS1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_TS1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000288 bits 7:4) field EXT_CPB_LINK_SCH_TS1 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    reg_value = etime_reg_EXT_CPB_LSC_LOW_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS1_MSK) >> ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS1_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS1_get", value );

    return value;
}
static INLINE void etime_field_range_EXT_CPB_LINK_SCH_TS1_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_EXT_CPB_LINK_SCH_TS1_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_CPB_LINK_SCH_TS1_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_CPB_LINK_SCH_TS1_set", stop_bit, 3 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_CPB_LINK_SCH_TS1_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000288 bits 7:4) field EXT_CPB_LINK_SCH_TS1 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000288 bits 7:4) field EXT_CPB_LINK_SCH_TS1 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
        etime_reg_EXT_CPB_LSC_LOW_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS1_OFF + subfield_offset),
                                             ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS1_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_EXT_CPB_LINK_SCH_TS1_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_EXT_CPB_LINK_SCH_TS1_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_CPB_LINK_SCH_TS1_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_CPB_LINK_SCH_TS1_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000288 bits 7:4) field EXT_CPB_LINK_SCH_TS1 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    reg_value = etime_reg_EXT_CPB_LSC_LOW_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS1_MSK)
                  >> ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS1_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS1_MSK, ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS1_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_CPB_LINK_SCH_TS1_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_EXT_CPB_LINK_SCH_TS0_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EXT_CPB_LINK_SCH_TS0_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value )
{
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS0_set", value, 15);
    IOLOG( "%s <= 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS0_set", value );

    /* (0x00000288 bits 3:0) field EXT_CPB_LINK_SCH_TS0 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    etime_reg_EXT_CPB_LSC_LOW_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS0_MSK,
                                         ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS0_OFF,
                                         value);
}

static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_TS0_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_TS0_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000288 bits 3:0) field EXT_CPB_LINK_SCH_TS0 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    reg_value = etime_reg_EXT_CPB_LSC_LOW_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS0_MSK) >> ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS0_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS0_get", value );

    return value;
}
static INLINE void etime_field_range_EXT_CPB_LINK_SCH_TS0_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_EXT_CPB_LINK_SCH_TS0_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_CPB_LINK_SCH_TS0_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_CPB_LINK_SCH_TS0_set", stop_bit, 3 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_CPB_LINK_SCH_TS0_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000288 bits 3:0) field EXT_CPB_LINK_SCH_TS0 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000288 bits 3:0) field EXT_CPB_LINK_SCH_TS0 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
        etime_reg_EXT_CPB_LSC_LOW_field_set( b_ptr,
                                             h_ptr,
                                             subfield_mask << (ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS0_OFF + subfield_offset),
                                             ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS0_OFF + subfield_offset,
                                             value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_EXT_CPB_LINK_SCH_TS0_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_EXT_CPB_LINK_SCH_TS0_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_CPB_LINK_SCH_TS0_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_CPB_LINK_SCH_TS0_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000288 bits 3:0) field EXT_CPB_LINK_SCH_TS0 of register PMC_ETIME120_REG_EXT_CPB_LSC_LOW */
    reg_value = etime_reg_EXT_CPB_LSC_LOW_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS0_MSK)
                  >> ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS0_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS0_MSK, ETIME120_REG_EXT_CPB_LSC_LOW_BIT_EXT_CPB_LINK_SCH_TS0_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_CPB_LINK_SCH_TS0_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_EXT_CPB_LINK_SCH_TS11_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EXT_CPB_LINK_SCH_TS11_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 value )
{
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS11_set", value, 15);
    IOLOG( "%s <= 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS11_set", value );

    /* (0x0000028c bits 15:12) field EXT_CPB_LINK_SCH_TS11 of register PMC_ETIME120_REG_EXT_CPB_LSC_HIGH */
    etime_reg_EXT_CPB_LSC_HIGH_field_set( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS11_MSK,
                                          ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS11_OFF,
                                          value);
}

static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_TS11_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_TS11_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000028c bits 15:12) field EXT_CPB_LINK_SCH_TS11 of register PMC_ETIME120_REG_EXT_CPB_LSC_HIGH */
    reg_value = etime_reg_EXT_CPB_LSC_HIGH_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS11_MSK) >> ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS11_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS11_get", value );

    return value;
}
static INLINE void etime_field_range_EXT_CPB_LINK_SCH_TS11_set( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit,
                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_EXT_CPB_LINK_SCH_TS11_set( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit,
                                                                UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_CPB_LINK_SCH_TS11_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_CPB_LINK_SCH_TS11_set", stop_bit, 3 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_CPB_LINK_SCH_TS11_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000028c bits 15:12) field EXT_CPB_LINK_SCH_TS11 of register PMC_ETIME120_REG_EXT_CPB_LSC_HIGH */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000028c bits 15:12) field EXT_CPB_LINK_SCH_TS11 of register PMC_ETIME120_REG_EXT_CPB_LSC_HIGH */
        etime_reg_EXT_CPB_LSC_HIGH_field_set( b_ptr,
                                              h_ptr,
                                              subfield_mask << (ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS11_OFF + subfield_offset),
                                              ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS11_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_EXT_CPB_LINK_SCH_TS11_get( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_EXT_CPB_LINK_SCH_TS11_get( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_CPB_LINK_SCH_TS11_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_CPB_LINK_SCH_TS11_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000028c bits 15:12) field EXT_CPB_LINK_SCH_TS11 of register PMC_ETIME120_REG_EXT_CPB_LSC_HIGH */
    reg_value = etime_reg_EXT_CPB_LSC_HIGH_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS11_MSK)
                  >> ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS11_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS11_MSK, ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS11_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_CPB_LINK_SCH_TS11_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_EXT_CPB_LINK_SCH_TS10_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EXT_CPB_LINK_SCH_TS10_set( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 value )
{
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS10_set", value, 15);
    IOLOG( "%s <= 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS10_set", value );

    /* (0x0000028c bits 11:8) field EXT_CPB_LINK_SCH_TS10 of register PMC_ETIME120_REG_EXT_CPB_LSC_HIGH */
    etime_reg_EXT_CPB_LSC_HIGH_field_set( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS10_MSK,
                                          ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS10_OFF,
                                          value);
}

static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_TS10_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_TS10_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000028c bits 11:8) field EXT_CPB_LINK_SCH_TS10 of register PMC_ETIME120_REG_EXT_CPB_LSC_HIGH */
    reg_value = etime_reg_EXT_CPB_LSC_HIGH_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS10_MSK) >> ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS10_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS10_get", value );

    return value;
}
static INLINE void etime_field_range_EXT_CPB_LINK_SCH_TS10_set( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit,
                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_EXT_CPB_LINK_SCH_TS10_set( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit,
                                                                UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_CPB_LINK_SCH_TS10_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_CPB_LINK_SCH_TS10_set", stop_bit, 3 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_CPB_LINK_SCH_TS10_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000028c bits 11:8) field EXT_CPB_LINK_SCH_TS10 of register PMC_ETIME120_REG_EXT_CPB_LSC_HIGH */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000028c bits 11:8) field EXT_CPB_LINK_SCH_TS10 of register PMC_ETIME120_REG_EXT_CPB_LSC_HIGH */
        etime_reg_EXT_CPB_LSC_HIGH_field_set( b_ptr,
                                              h_ptr,
                                              subfield_mask << (ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS10_OFF + subfield_offset),
                                              ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS10_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_EXT_CPB_LINK_SCH_TS10_get( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_EXT_CPB_LINK_SCH_TS10_get( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_CPB_LINK_SCH_TS10_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_CPB_LINK_SCH_TS10_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000028c bits 11:8) field EXT_CPB_LINK_SCH_TS10 of register PMC_ETIME120_REG_EXT_CPB_LSC_HIGH */
    reg_value = etime_reg_EXT_CPB_LSC_HIGH_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS10_MSK)
                  >> ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS10_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS10_MSK, ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS10_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_CPB_LINK_SCH_TS10_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_EXT_CPB_LINK_SCH_TS9_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EXT_CPB_LINK_SCH_TS9_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value )
{
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS9_set", value, 15);
    IOLOG( "%s <= 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS9_set", value );

    /* (0x0000028c bits 7:4) field EXT_CPB_LINK_SCH_TS9 of register PMC_ETIME120_REG_EXT_CPB_LSC_HIGH */
    etime_reg_EXT_CPB_LSC_HIGH_field_set( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS9_MSK,
                                          ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS9_OFF,
                                          value);
}

static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_TS9_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_TS9_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000028c bits 7:4) field EXT_CPB_LINK_SCH_TS9 of register PMC_ETIME120_REG_EXT_CPB_LSC_HIGH */
    reg_value = etime_reg_EXT_CPB_LSC_HIGH_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS9_MSK) >> ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS9_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS9_get", value );

    return value;
}
static INLINE void etime_field_range_EXT_CPB_LINK_SCH_TS9_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_EXT_CPB_LINK_SCH_TS9_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_CPB_LINK_SCH_TS9_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_CPB_LINK_SCH_TS9_set", stop_bit, 3 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_CPB_LINK_SCH_TS9_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000028c bits 7:4) field EXT_CPB_LINK_SCH_TS9 of register PMC_ETIME120_REG_EXT_CPB_LSC_HIGH */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000028c bits 7:4) field EXT_CPB_LINK_SCH_TS9 of register PMC_ETIME120_REG_EXT_CPB_LSC_HIGH */
        etime_reg_EXT_CPB_LSC_HIGH_field_set( b_ptr,
                                              h_ptr,
                                              subfield_mask << (ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS9_OFF + subfield_offset),
                                              ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS9_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_EXT_CPB_LINK_SCH_TS9_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_EXT_CPB_LINK_SCH_TS9_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_CPB_LINK_SCH_TS9_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_CPB_LINK_SCH_TS9_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000028c bits 7:4) field EXT_CPB_LINK_SCH_TS9 of register PMC_ETIME120_REG_EXT_CPB_LSC_HIGH */
    reg_value = etime_reg_EXT_CPB_LSC_HIGH_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS9_MSK)
                  >> ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS9_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS9_MSK, ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS9_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_CPB_LINK_SCH_TS9_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_EXT_CPB_LINK_SCH_TS8_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EXT_CPB_LINK_SCH_TS8_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value )
{
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS8_set", value, 15);
    IOLOG( "%s <= 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS8_set", value );

    /* (0x0000028c bits 3:0) field EXT_CPB_LINK_SCH_TS8 of register PMC_ETIME120_REG_EXT_CPB_LSC_HIGH */
    etime_reg_EXT_CPB_LSC_HIGH_field_set( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS8_MSK,
                                          ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS8_OFF,
                                          value);
}

static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_TS8_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_TS8_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000028c bits 3:0) field EXT_CPB_LINK_SCH_TS8 of register PMC_ETIME120_REG_EXT_CPB_LSC_HIGH */
    reg_value = etime_reg_EXT_CPB_LSC_HIGH_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS8_MSK) >> ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS8_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EXT_CPB_LINK_SCH_TS8_get", value );

    return value;
}
static INLINE void etime_field_range_EXT_CPB_LINK_SCH_TS8_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_EXT_CPB_LINK_SCH_TS8_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_CPB_LINK_SCH_TS8_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_CPB_LINK_SCH_TS8_set", stop_bit, 3 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_CPB_LINK_SCH_TS8_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000028c bits 3:0) field EXT_CPB_LINK_SCH_TS8 of register PMC_ETIME120_REG_EXT_CPB_LSC_HIGH */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000028c bits 3:0) field EXT_CPB_LINK_SCH_TS8 of register PMC_ETIME120_REG_EXT_CPB_LSC_HIGH */
        etime_reg_EXT_CPB_LSC_HIGH_field_set( b_ptr,
                                              h_ptr,
                                              subfield_mask << (ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS8_OFF + subfield_offset),
                                              ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS8_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_EXT_CPB_LINK_SCH_TS8_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_EXT_CPB_LINK_SCH_TS8_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_CPB_LINK_SCH_TS8_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_CPB_LINK_SCH_TS8_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000028c bits 3:0) field EXT_CPB_LINK_SCH_TS8 of register PMC_ETIME120_REG_EXT_CPB_LSC_HIGH */
    reg_value = etime_reg_EXT_CPB_LSC_HIGH_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS8_MSK)
                  >> ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS8_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS8_MSK, ETIME120_REG_EXT_CPB_LSC_HIGH_BIT_EXT_CPB_LINK_SCH_TS8_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_CPB_LINK_SCH_TS8_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_EXT_CPB_LINK_SCH_LAST_TIMESLOT_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EXT_CPB_LINK_SCH_LAST_TIMESLOT_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 value )
{
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EXT_CPB_LINK_SCH_LAST_TIMESLOT_set", value, 15);
    IOLOG( "%s <= 0x%08x", "etime_field_EXT_CPB_LINK_SCH_LAST_TIMESLOT_set", value );

    /* (0x00000290 bits 7:4) field EXT_CPB_LINK_SCH_LAST_TIMESLOT of register PMC_ETIME120_REG_EXT_CPB_CFG */
    etime_reg_EXT_CPB_CFG_field_set( b_ptr,
                                     h_ptr,
                                     ETIME120_REG_EXT_CPB_CFG_BIT_EXT_CPB_LINK_SCH_LAST_TIMESLOT_MSK,
                                     ETIME120_REG_EXT_CPB_CFG_BIT_EXT_CPB_LINK_SCH_LAST_TIMESLOT_OFF,
                                     value);
}

static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_LAST_TIMESLOT_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_LAST_TIMESLOT_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000290 bits 7:4) field EXT_CPB_LINK_SCH_LAST_TIMESLOT of register PMC_ETIME120_REG_EXT_CPB_CFG */
    reg_value = etime_reg_EXT_CPB_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EXT_CPB_CFG_BIT_EXT_CPB_LINK_SCH_LAST_TIMESLOT_MSK) >> ETIME120_REG_EXT_CPB_CFG_BIT_EXT_CPB_LINK_SCH_LAST_TIMESLOT_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EXT_CPB_LINK_SCH_LAST_TIMESLOT_get", value );

    return value;
}
static INLINE void etime_field_range_EXT_CPB_LINK_SCH_LAST_TIMESLOT_set( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit,
                                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_EXT_CPB_LINK_SCH_LAST_TIMESLOT_set( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit,
                                                                         UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_CPB_LINK_SCH_LAST_TIMESLOT_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_CPB_LINK_SCH_LAST_TIMESLOT_set", stop_bit, 3 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_CPB_LINK_SCH_LAST_TIMESLOT_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000290 bits 7:4) field EXT_CPB_LINK_SCH_LAST_TIMESLOT of register PMC_ETIME120_REG_EXT_CPB_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000290 bits 7:4) field EXT_CPB_LINK_SCH_LAST_TIMESLOT of register PMC_ETIME120_REG_EXT_CPB_CFG */
        etime_reg_EXT_CPB_CFG_field_set( b_ptr,
                                         h_ptr,
                                         subfield_mask << (ETIME120_REG_EXT_CPB_CFG_BIT_EXT_CPB_LINK_SCH_LAST_TIMESLOT_OFF + subfield_offset),
                                         ETIME120_REG_EXT_CPB_CFG_BIT_EXT_CPB_LINK_SCH_LAST_TIMESLOT_OFF + subfield_offset,
                                         value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_EXT_CPB_LINK_SCH_LAST_TIMESLOT_get( etime_buffer_t *b_ptr,
                                                                           etime_handle_t *h_ptr,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_EXT_CPB_LINK_SCH_LAST_TIMESLOT_get( etime_buffer_t *b_ptr,
                                                                           etime_handle_t *h_ptr,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_CPB_LINK_SCH_LAST_TIMESLOT_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_CPB_LINK_SCH_LAST_TIMESLOT_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000290 bits 7:4) field EXT_CPB_LINK_SCH_LAST_TIMESLOT of register PMC_ETIME120_REG_EXT_CPB_CFG */
    reg_value = etime_reg_EXT_CPB_CFG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_CPB_CFG_BIT_EXT_CPB_LINK_SCH_LAST_TIMESLOT_MSK)
                  >> ETIME120_REG_EXT_CPB_CFG_BIT_EXT_CPB_LINK_SCH_LAST_TIMESLOT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_CPB_CFG_BIT_EXT_CPB_LINK_SCH_LAST_TIMESLOT_MSK, ETIME120_REG_EXT_CPB_CFG_BIT_EXT_CPB_LINK_SCH_LAST_TIMESLOT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_CPB_LINK_SCH_LAST_TIMESLOT_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_EXT_CPB_LINK_SCH_OFFSET_set( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EXT_CPB_LINK_SCH_OFFSET_set( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 value )
{
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EXT_CPB_LINK_SCH_OFFSET_set", value, 15);
    IOLOG( "%s <= 0x%08x", "etime_field_EXT_CPB_LINK_SCH_OFFSET_set", value );

    /* (0x00000290 bits 3:0) field EXT_CPB_LINK_SCH_OFFSET of register PMC_ETIME120_REG_EXT_CPB_CFG */
    etime_reg_EXT_CPB_CFG_field_set( b_ptr,
                                     h_ptr,
                                     ETIME120_REG_EXT_CPB_CFG_BIT_EXT_CPB_LINK_SCH_OFFSET_MSK,
                                     ETIME120_REG_EXT_CPB_CFG_BIT_EXT_CPB_LINK_SCH_OFFSET_OFF,
                                     value);
}

static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_OFFSET_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_OFFSET_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000290 bits 3:0) field EXT_CPB_LINK_SCH_OFFSET of register PMC_ETIME120_REG_EXT_CPB_CFG */
    reg_value = etime_reg_EXT_CPB_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EXT_CPB_CFG_BIT_EXT_CPB_LINK_SCH_OFFSET_MSK) >> ETIME120_REG_EXT_CPB_CFG_BIT_EXT_CPB_LINK_SCH_OFFSET_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EXT_CPB_LINK_SCH_OFFSET_get", value );

    return value;
}
static INLINE void etime_field_range_EXT_CPB_LINK_SCH_OFFSET_set( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_EXT_CPB_LINK_SCH_OFFSET_set( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_CPB_LINK_SCH_OFFSET_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_CPB_LINK_SCH_OFFSET_set", stop_bit, 3 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_CPB_LINK_SCH_OFFSET_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000290 bits 3:0) field EXT_CPB_LINK_SCH_OFFSET of register PMC_ETIME120_REG_EXT_CPB_CFG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000290 bits 3:0) field EXT_CPB_LINK_SCH_OFFSET of register PMC_ETIME120_REG_EXT_CPB_CFG */
        etime_reg_EXT_CPB_CFG_field_set( b_ptr,
                                         h_ptr,
                                         subfield_mask << (ETIME120_REG_EXT_CPB_CFG_BIT_EXT_CPB_LINK_SCH_OFFSET_OFF + subfield_offset),
                                         ETIME120_REG_EXT_CPB_CFG_BIT_EXT_CPB_LINK_SCH_OFFSET_OFF + subfield_offset,
                                         value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_EXT_CPB_LINK_SCH_OFFSET_get( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_EXT_CPB_LINK_SCH_OFFSET_get( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_CPB_LINK_SCH_OFFSET_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_CPB_LINK_SCH_OFFSET_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000290 bits 3:0) field EXT_CPB_LINK_SCH_OFFSET of register PMC_ETIME120_REG_EXT_CPB_CFG */
    reg_value = etime_reg_EXT_CPB_CFG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_CPB_CFG_BIT_EXT_CPB_LINK_SCH_OFFSET_MSK)
                  >> ETIME120_REG_EXT_CPB_CFG_BIT_EXT_CPB_LINK_SCH_OFFSET_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_CPB_CFG_BIT_EXT_CPB_LINK_SCH_OFFSET_MSK, ETIME120_REG_EXT_CPB_CFG_BIT_EXT_CPB_LINK_SCH_OFFSET_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_CPB_LINK_SCH_OFFSET_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_EXT_SLOTS_OCCUPIED_100G_set( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EXT_SLOTS_OCCUPIED_100G_set( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 value )
{
    if (value > 127)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EXT_SLOTS_OCCUPIED_100G_set", value, 127);
    IOLOG( "%s <= 0x%08x", "etime_field_EXT_SLOTS_OCCUPIED_100G_set", value );

    /* (0x00000298 bits 20:14) field EXT_SLOTS_OCCUPIED_100G of register PMC_ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED */
    etime_reg_EXT_NUM_SLOTS_OCCUPIED_field_set( b_ptr,
                                                h_ptr,
                                                ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_100G_MSK,
                                                ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_100G_OFF,
                                                value);
}

static INLINE UINT32 etime_field_EXT_SLOTS_OCCUPIED_100G_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EXT_SLOTS_OCCUPIED_100G_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000298 bits 20:14) field EXT_SLOTS_OCCUPIED_100G of register PMC_ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED */
    reg_value = etime_reg_EXT_NUM_SLOTS_OCCUPIED_read( b_ptr,
                                                       h_ptr);
    value = (reg_value & ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_100G_MSK) >> ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_100G_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EXT_SLOTS_OCCUPIED_100G_get", value );

    return value;
}
static INLINE void etime_field_range_EXT_SLOTS_OCCUPIED_100G_set( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_EXT_SLOTS_OCCUPIED_100G_set( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_SLOTS_OCCUPIED_100G_set", stop_bit, start_bit );
    if (stop_bit > 6) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_SLOTS_OCCUPIED_100G_set", stop_bit, 6 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_SLOTS_OCCUPIED_100G_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000298 bits 20:14) field EXT_SLOTS_OCCUPIED_100G of register PMC_ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 6) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 6;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000298 bits 20:14) field EXT_SLOTS_OCCUPIED_100G of register PMC_ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED */
        etime_reg_EXT_NUM_SLOTS_OCCUPIED_field_set( b_ptr,
                                                    h_ptr,
                                                    subfield_mask << (ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_100G_OFF + subfield_offset),
                                                    ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_100G_OFF + subfield_offset,
                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_EXT_SLOTS_OCCUPIED_100G_get( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_EXT_SLOTS_OCCUPIED_100G_get( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_SLOTS_OCCUPIED_100G_get", stop_bit, start_bit );
    if (stop_bit > 6) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_SLOTS_OCCUPIED_100G_get", stop_bit, 6 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 6) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 6;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000298 bits 20:14) field EXT_SLOTS_OCCUPIED_100G of register PMC_ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED */
    reg_value = etime_reg_EXT_NUM_SLOTS_OCCUPIED_read( b_ptr,
                                                       h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_100G_MSK)
                  >> ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_100G_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_100G_MSK, ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_100G_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_SLOTS_OCCUPIED_100G_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_EXT_SLOTS_OCCUPIED_40G_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EXT_SLOTS_OCCUPIED_40G_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value )
{
    if (value > 127)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EXT_SLOTS_OCCUPIED_40G_set", value, 127);
    IOLOG( "%s <= 0x%08x", "etime_field_EXT_SLOTS_OCCUPIED_40G_set", value );

    /* (0x00000298 bits 13:7) field EXT_SLOTS_OCCUPIED_40G of register PMC_ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED */
    etime_reg_EXT_NUM_SLOTS_OCCUPIED_field_set( b_ptr,
                                                h_ptr,
                                                ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_40G_MSK,
                                                ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_40G_OFF,
                                                value);
}

static INLINE UINT32 etime_field_EXT_SLOTS_OCCUPIED_40G_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EXT_SLOTS_OCCUPIED_40G_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000298 bits 13:7) field EXT_SLOTS_OCCUPIED_40G of register PMC_ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED */
    reg_value = etime_reg_EXT_NUM_SLOTS_OCCUPIED_read( b_ptr,
                                                       h_ptr);
    value = (reg_value & ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_40G_MSK) >> ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_40G_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EXT_SLOTS_OCCUPIED_40G_get", value );

    return value;
}
static INLINE void etime_field_range_EXT_SLOTS_OCCUPIED_40G_set( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_EXT_SLOTS_OCCUPIED_40G_set( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_SLOTS_OCCUPIED_40G_set", stop_bit, start_bit );
    if (stop_bit > 6) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_SLOTS_OCCUPIED_40G_set", stop_bit, 6 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_SLOTS_OCCUPIED_40G_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000298 bits 13:7) field EXT_SLOTS_OCCUPIED_40G of register PMC_ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 6) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 6;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000298 bits 13:7) field EXT_SLOTS_OCCUPIED_40G of register PMC_ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED */
        etime_reg_EXT_NUM_SLOTS_OCCUPIED_field_set( b_ptr,
                                                    h_ptr,
                                                    subfield_mask << (ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_40G_OFF + subfield_offset),
                                                    ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_40G_OFF + subfield_offset,
                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_EXT_SLOTS_OCCUPIED_40G_get( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_EXT_SLOTS_OCCUPIED_40G_get( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_SLOTS_OCCUPIED_40G_get", stop_bit, start_bit );
    if (stop_bit > 6) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_SLOTS_OCCUPIED_40G_get", stop_bit, 6 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 6) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 6;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000298 bits 13:7) field EXT_SLOTS_OCCUPIED_40G of register PMC_ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED */
    reg_value = etime_reg_EXT_NUM_SLOTS_OCCUPIED_read( b_ptr,
                                                       h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_40G_MSK)
                  >> ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_40G_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_40G_MSK, ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_40G_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_SLOTS_OCCUPIED_40G_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_EXT_SLOTS_OCCUPIED_10G_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EXT_SLOTS_OCCUPIED_10G_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value )
{
    if (value > 127)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EXT_SLOTS_OCCUPIED_10G_set", value, 127);
    IOLOG( "%s <= 0x%08x", "etime_field_EXT_SLOTS_OCCUPIED_10G_set", value );

    /* (0x00000298 bits 6:0) field EXT_SLOTS_OCCUPIED_10G of register PMC_ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED */
    etime_reg_EXT_NUM_SLOTS_OCCUPIED_field_set( b_ptr,
                                                h_ptr,
                                                ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_10G_MSK,
                                                ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_10G_OFF,
                                                value);
}

static INLINE UINT32 etime_field_EXT_SLOTS_OCCUPIED_10G_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EXT_SLOTS_OCCUPIED_10G_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000298 bits 6:0) field EXT_SLOTS_OCCUPIED_10G of register PMC_ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED */
    reg_value = etime_reg_EXT_NUM_SLOTS_OCCUPIED_read( b_ptr,
                                                       h_ptr);
    value = (reg_value & ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_10G_MSK) >> ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_10G_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EXT_SLOTS_OCCUPIED_10G_get", value );

    return value;
}
static INLINE void etime_field_range_EXT_SLOTS_OCCUPIED_10G_set( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_EXT_SLOTS_OCCUPIED_10G_set( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_SLOTS_OCCUPIED_10G_set", stop_bit, start_bit );
    if (stop_bit > 6) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_SLOTS_OCCUPIED_10G_set", stop_bit, 6 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_SLOTS_OCCUPIED_10G_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000298 bits 6:0) field EXT_SLOTS_OCCUPIED_10G of register PMC_ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 6) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 6;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000298 bits 6:0) field EXT_SLOTS_OCCUPIED_10G of register PMC_ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED */
        etime_reg_EXT_NUM_SLOTS_OCCUPIED_field_set( b_ptr,
                                                    h_ptr,
                                                    subfield_mask << (ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_10G_OFF + subfield_offset),
                                                    ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_10G_OFF + subfield_offset,
                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_EXT_SLOTS_OCCUPIED_10G_get( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_EXT_SLOTS_OCCUPIED_10G_get( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_SLOTS_OCCUPIED_10G_get", stop_bit, start_bit );
    if (stop_bit > 6) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_SLOTS_OCCUPIED_10G_get", stop_bit, 6 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 6) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 6;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000298 bits 6:0) field EXT_SLOTS_OCCUPIED_10G of register PMC_ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED */
    reg_value = etime_reg_EXT_NUM_SLOTS_OCCUPIED_read( b_ptr,
                                                       h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_10G_MSK)
                  >> ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_10G_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_10G_MSK, ETIME120_REG_EXT_NUM_SLOTS_OCCUPIED_BIT_EXT_SLOTS_OCCUPIED_10G_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_SLOTS_OCCUPIED_10G_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_LINE_REF_ENA_set( etime_buffer_t *b_ptr,
                                                 etime_handle_t *h_ptr,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_LINE_REF_ENA_set( etime_buffer_t *b_ptr,
                                                 etime_handle_t *h_ptr,
                                                 UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_LINE_REF_ENA_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_LINE_REF_ENA_set", value );

    /* (0x0000029c bits 1) field LINE_REF_ENA of register PMC_ETIME120_REG_ENA_REG */
    etime_reg_ENA_REG_field_set( b_ptr,
                                 h_ptr,
                                 ETIME120_REG_ENA_REG_BIT_LINE_REF_ENA_MSK,
                                 ETIME120_REG_ENA_REG_BIT_LINE_REF_ENA_OFF,
                                 value);
}

static INLINE UINT32 etime_field_LINE_REF_ENA_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_LINE_REF_ENA_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000029c bits 1) field LINE_REF_ENA of register PMC_ETIME120_REG_ENA_REG */
    reg_value = etime_reg_ENA_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_ENA_REG_BIT_LINE_REF_ENA_MSK) >> ETIME120_REG_ENA_REG_BIT_LINE_REF_ENA_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_LINE_REF_ENA_get", value );

    return value;
}
static INLINE void etime_field_REFL_PATH_ENA_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_PATH_ENA_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_PATH_ENA_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_PATH_ENA_set", value );

    /* (0x0000029c bits 0) field REFL_PATH_ENA of register PMC_ETIME120_REG_ENA_REG */
    etime_reg_ENA_REG_field_set( b_ptr,
                                 h_ptr,
                                 ETIME120_REG_ENA_REG_BIT_REFL_PATH_ENA_MSK,
                                 ETIME120_REG_ENA_REG_BIT_REFL_PATH_ENA_OFF,
                                 value);
}

static INLINE UINT32 etime_field_REFL_PATH_ENA_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_PATH_ENA_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000029c bits 0) field REFL_PATH_ENA of register PMC_ETIME120_REG_ENA_REG */
    reg_value = etime_reg_ENA_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_ENA_REG_BIT_REFL_PATH_ENA_MSK) >> ETIME120_REG_ENA_REG_BIT_REFL_PATH_ENA_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_PATH_ENA_get", value );

    return value;
}
static INLINE void etime_field_REFL_DROP_ENA_CH11_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_DROP_ENA_CH11_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_DROP_ENA_CH11_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_DROP_ENA_CH11_set", value );

    /* (0x000002a0 bits 11) field REFL_DROP_ENA_CH11 of register PMC_ETIME120_REG_REFL_DROP_ENA_CFG_REG */
    etime_reg_REFL_DROP_ENA_CFG_REG_field_set( b_ptr,
                                               h_ptr,
                                               ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH11_MSK,
                                               ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH11_OFF,
                                               value);
}

static INLINE UINT32 etime_field_REFL_DROP_ENA_CH11_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_DROP_ENA_CH11_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000002a0 bits 11) field REFL_DROP_ENA_CH11 of register PMC_ETIME120_REG_REFL_DROP_ENA_CFG_REG */
    reg_value = etime_reg_REFL_DROP_ENA_CFG_REG_read( b_ptr,
                                                      h_ptr);
    value = (reg_value & ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH11_MSK) >> ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH11_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_DROP_ENA_CH11_get", value );

    return value;
}
static INLINE void etime_field_REFL_DROP_ENA_CH10_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_DROP_ENA_CH10_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_DROP_ENA_CH10_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_DROP_ENA_CH10_set", value );

    /* (0x000002a0 bits 10) field REFL_DROP_ENA_CH10 of register PMC_ETIME120_REG_REFL_DROP_ENA_CFG_REG */
    etime_reg_REFL_DROP_ENA_CFG_REG_field_set( b_ptr,
                                               h_ptr,
                                               ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH10_MSK,
                                               ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH10_OFF,
                                               value);
}

static INLINE UINT32 etime_field_REFL_DROP_ENA_CH10_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_DROP_ENA_CH10_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000002a0 bits 10) field REFL_DROP_ENA_CH10 of register PMC_ETIME120_REG_REFL_DROP_ENA_CFG_REG */
    reg_value = etime_reg_REFL_DROP_ENA_CFG_REG_read( b_ptr,
                                                      h_ptr);
    value = (reg_value & ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH10_MSK) >> ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH10_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_DROP_ENA_CH10_get", value );

    return value;
}
static INLINE void etime_field_REFL_DROP_ENA_CH9_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_DROP_ENA_CH9_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_DROP_ENA_CH9_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_DROP_ENA_CH9_set", value );

    /* (0x000002a0 bits 9) field REFL_DROP_ENA_CH9 of register PMC_ETIME120_REG_REFL_DROP_ENA_CFG_REG */
    etime_reg_REFL_DROP_ENA_CFG_REG_field_set( b_ptr,
                                               h_ptr,
                                               ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH9_MSK,
                                               ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH9_OFF,
                                               value);
}

static INLINE UINT32 etime_field_REFL_DROP_ENA_CH9_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_DROP_ENA_CH9_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000002a0 bits 9) field REFL_DROP_ENA_CH9 of register PMC_ETIME120_REG_REFL_DROP_ENA_CFG_REG */
    reg_value = etime_reg_REFL_DROP_ENA_CFG_REG_read( b_ptr,
                                                      h_ptr);
    value = (reg_value & ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH9_MSK) >> ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH9_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_DROP_ENA_CH9_get", value );

    return value;
}
static INLINE void etime_field_REFL_DROP_ENA_CH8_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_DROP_ENA_CH8_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_DROP_ENA_CH8_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_DROP_ENA_CH8_set", value );

    /* (0x000002a0 bits 8) field REFL_DROP_ENA_CH8 of register PMC_ETIME120_REG_REFL_DROP_ENA_CFG_REG */
    etime_reg_REFL_DROP_ENA_CFG_REG_field_set( b_ptr,
                                               h_ptr,
                                               ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH8_MSK,
                                               ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH8_OFF,
                                               value);
}

static INLINE UINT32 etime_field_REFL_DROP_ENA_CH8_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_DROP_ENA_CH8_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000002a0 bits 8) field REFL_DROP_ENA_CH8 of register PMC_ETIME120_REG_REFL_DROP_ENA_CFG_REG */
    reg_value = etime_reg_REFL_DROP_ENA_CFG_REG_read( b_ptr,
                                                      h_ptr);
    value = (reg_value & ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH8_MSK) >> ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH8_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_DROP_ENA_CH8_get", value );

    return value;
}
static INLINE void etime_field_REFL_DROP_ENA_CH7_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_DROP_ENA_CH7_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_DROP_ENA_CH7_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_DROP_ENA_CH7_set", value );

    /* (0x000002a0 bits 7) field REFL_DROP_ENA_CH7 of register PMC_ETIME120_REG_REFL_DROP_ENA_CFG_REG */
    etime_reg_REFL_DROP_ENA_CFG_REG_field_set( b_ptr,
                                               h_ptr,
                                               ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH7_MSK,
                                               ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH7_OFF,
                                               value);
}

static INLINE UINT32 etime_field_REFL_DROP_ENA_CH7_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_DROP_ENA_CH7_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000002a0 bits 7) field REFL_DROP_ENA_CH7 of register PMC_ETIME120_REG_REFL_DROP_ENA_CFG_REG */
    reg_value = etime_reg_REFL_DROP_ENA_CFG_REG_read( b_ptr,
                                                      h_ptr);
    value = (reg_value & ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH7_MSK) >> ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH7_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_DROP_ENA_CH7_get", value );

    return value;
}
static INLINE void etime_field_REFL_DROP_ENA_CH6_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_DROP_ENA_CH6_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_DROP_ENA_CH6_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_DROP_ENA_CH6_set", value );

    /* (0x000002a0 bits 6) field REFL_DROP_ENA_CH6 of register PMC_ETIME120_REG_REFL_DROP_ENA_CFG_REG */
    etime_reg_REFL_DROP_ENA_CFG_REG_field_set( b_ptr,
                                               h_ptr,
                                               ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH6_MSK,
                                               ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH6_OFF,
                                               value);
}

static INLINE UINT32 etime_field_REFL_DROP_ENA_CH6_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_DROP_ENA_CH6_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000002a0 bits 6) field REFL_DROP_ENA_CH6 of register PMC_ETIME120_REG_REFL_DROP_ENA_CFG_REG */
    reg_value = etime_reg_REFL_DROP_ENA_CFG_REG_read( b_ptr,
                                                      h_ptr);
    value = (reg_value & ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH6_MSK) >> ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH6_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_DROP_ENA_CH6_get", value );

    return value;
}
static INLINE void etime_field_REFL_DROP_ENA_CH5_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_DROP_ENA_CH5_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_DROP_ENA_CH5_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_DROP_ENA_CH5_set", value );

    /* (0x000002a0 bits 5) field REFL_DROP_ENA_CH5 of register PMC_ETIME120_REG_REFL_DROP_ENA_CFG_REG */
    etime_reg_REFL_DROP_ENA_CFG_REG_field_set( b_ptr,
                                               h_ptr,
                                               ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH5_MSK,
                                               ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH5_OFF,
                                               value);
}

static INLINE UINT32 etime_field_REFL_DROP_ENA_CH5_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_DROP_ENA_CH5_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000002a0 bits 5) field REFL_DROP_ENA_CH5 of register PMC_ETIME120_REG_REFL_DROP_ENA_CFG_REG */
    reg_value = etime_reg_REFL_DROP_ENA_CFG_REG_read( b_ptr,
                                                      h_ptr);
    value = (reg_value & ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH5_MSK) >> ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH5_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_DROP_ENA_CH5_get", value );

    return value;
}
static INLINE void etime_field_REFL_DROP_ENA_CH4_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_DROP_ENA_CH4_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_DROP_ENA_CH4_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_DROP_ENA_CH4_set", value );

    /* (0x000002a0 bits 4) field REFL_DROP_ENA_CH4 of register PMC_ETIME120_REG_REFL_DROP_ENA_CFG_REG */
    etime_reg_REFL_DROP_ENA_CFG_REG_field_set( b_ptr,
                                               h_ptr,
                                               ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH4_MSK,
                                               ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH4_OFF,
                                               value);
}

static INLINE UINT32 etime_field_REFL_DROP_ENA_CH4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_DROP_ENA_CH4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000002a0 bits 4) field REFL_DROP_ENA_CH4 of register PMC_ETIME120_REG_REFL_DROP_ENA_CFG_REG */
    reg_value = etime_reg_REFL_DROP_ENA_CFG_REG_read( b_ptr,
                                                      h_ptr);
    value = (reg_value & ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH4_MSK) >> ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH4_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_DROP_ENA_CH4_get", value );

    return value;
}
static INLINE void etime_field_REFL_DROP_ENA_CH3_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_DROP_ENA_CH3_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_DROP_ENA_CH3_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_DROP_ENA_CH3_set", value );

    /* (0x000002a0 bits 3) field REFL_DROP_ENA_CH3 of register PMC_ETIME120_REG_REFL_DROP_ENA_CFG_REG */
    etime_reg_REFL_DROP_ENA_CFG_REG_field_set( b_ptr,
                                               h_ptr,
                                               ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH3_MSK,
                                               ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH3_OFF,
                                               value);
}

static INLINE UINT32 etime_field_REFL_DROP_ENA_CH3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_DROP_ENA_CH3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000002a0 bits 3) field REFL_DROP_ENA_CH3 of register PMC_ETIME120_REG_REFL_DROP_ENA_CFG_REG */
    reg_value = etime_reg_REFL_DROP_ENA_CFG_REG_read( b_ptr,
                                                      h_ptr);
    value = (reg_value & ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH3_MSK) >> ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH3_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_DROP_ENA_CH3_get", value );

    return value;
}
static INLINE void etime_field_REFL_DROP_ENA_CH2_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_DROP_ENA_CH2_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_DROP_ENA_CH2_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_DROP_ENA_CH2_set", value );

    /* (0x000002a0 bits 2) field REFL_DROP_ENA_CH2 of register PMC_ETIME120_REG_REFL_DROP_ENA_CFG_REG */
    etime_reg_REFL_DROP_ENA_CFG_REG_field_set( b_ptr,
                                               h_ptr,
                                               ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH2_MSK,
                                               ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH2_OFF,
                                               value);
}

static INLINE UINT32 etime_field_REFL_DROP_ENA_CH2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_DROP_ENA_CH2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000002a0 bits 2) field REFL_DROP_ENA_CH2 of register PMC_ETIME120_REG_REFL_DROP_ENA_CFG_REG */
    reg_value = etime_reg_REFL_DROP_ENA_CFG_REG_read( b_ptr,
                                                      h_ptr);
    value = (reg_value & ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH2_MSK) >> ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH2_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_DROP_ENA_CH2_get", value );

    return value;
}
static INLINE void etime_field_REFL_DROP_ENA_CH1_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_DROP_ENA_CH1_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_DROP_ENA_CH1_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_DROP_ENA_CH1_set", value );

    /* (0x000002a0 bits 1) field REFL_DROP_ENA_CH1 of register PMC_ETIME120_REG_REFL_DROP_ENA_CFG_REG */
    etime_reg_REFL_DROP_ENA_CFG_REG_field_set( b_ptr,
                                               h_ptr,
                                               ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH1_MSK,
                                               ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH1_OFF,
                                               value);
}

static INLINE UINT32 etime_field_REFL_DROP_ENA_CH1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_DROP_ENA_CH1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000002a0 bits 1) field REFL_DROP_ENA_CH1 of register PMC_ETIME120_REG_REFL_DROP_ENA_CFG_REG */
    reg_value = etime_reg_REFL_DROP_ENA_CFG_REG_read( b_ptr,
                                                      h_ptr);
    value = (reg_value & ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH1_MSK) >> ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH1_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_DROP_ENA_CH1_get", value );

    return value;
}
static INLINE void etime_field_REFL_DROP_ENA_CH0_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_DROP_ENA_CH0_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_DROP_ENA_CH0_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_DROP_ENA_CH0_set", value );

    /* (0x000002a0 bits 0) field REFL_DROP_ENA_CH0 of register PMC_ETIME120_REG_REFL_DROP_ENA_CFG_REG */
    etime_reg_REFL_DROP_ENA_CFG_REG_field_set( b_ptr,
                                               h_ptr,
                                               ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH0_MSK,
                                               ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH0_OFF,
                                               value);
}

static INLINE UINT32 etime_field_REFL_DROP_ENA_CH0_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_DROP_ENA_CH0_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000002a0 bits 0) field REFL_DROP_ENA_CH0 of register PMC_ETIME120_REG_REFL_DROP_ENA_CFG_REG */
    reg_value = etime_reg_REFL_DROP_ENA_CFG_REG_read( b_ptr,
                                                      h_ptr);
    value = (reg_value & ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH0_MSK) >> ETIME120_REG_REFL_DROP_ENA_CFG_REG_BIT_REFL_DROP_ENA_CH0_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_DROP_ENA_CH0_get", value );

    return value;
}
static INLINE void etime_field_LINE_REF_CNT_DLY_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_LINE_REF_CNT_DLY_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    IOLOG( "%s <= 0x%08x", "etime_field_LINE_REF_CNT_DLY_set", value );

    /* (0x000002a8 bits 31:0) field LINE_REF_CNT_DLY of register PMC_ETIME120_REG_LINE_REF_CNT_DLY_REG */
    etime_reg_LINE_REF_CNT_DLY_REG_field_set( b_ptr,
                                              h_ptr,
                                              ETIME120_REG_LINE_REF_CNT_DLY_REG_BIT_LINE_REF_CNT_DLY_MSK,
                                              ETIME120_REG_LINE_REF_CNT_DLY_REG_BIT_LINE_REF_CNT_DLY_OFF,
                                              value);
}

static INLINE UINT32 etime_field_LINE_REF_CNT_DLY_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_LINE_REF_CNT_DLY_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000002a8 bits 31:0) field LINE_REF_CNT_DLY of register PMC_ETIME120_REG_LINE_REF_CNT_DLY_REG */
    reg_value = etime_reg_LINE_REF_CNT_DLY_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_LINE_REF_CNT_DLY_REG_BIT_LINE_REF_CNT_DLY_MSK) >> ETIME120_REG_LINE_REF_CNT_DLY_REG_BIT_LINE_REF_CNT_DLY_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_LINE_REF_CNT_DLY_get", value );

    return value;
}
static INLINE void etime_field_range_LINE_REF_CNT_DLY_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_LINE_REF_CNT_DLY_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit,
                                                           UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_LINE_REF_CNT_DLY_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_LINE_REF_CNT_DLY_set", stop_bit, 31 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_LINE_REF_CNT_DLY_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000002a8 bits 31:0) field LINE_REF_CNT_DLY of register PMC_ETIME120_REG_LINE_REF_CNT_DLY_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000002a8 bits 31:0) field LINE_REF_CNT_DLY of register PMC_ETIME120_REG_LINE_REF_CNT_DLY_REG */
        etime_reg_LINE_REF_CNT_DLY_REG_field_set( b_ptr,
                                                  h_ptr,
                                                  subfield_mask << (ETIME120_REG_LINE_REF_CNT_DLY_REG_BIT_LINE_REF_CNT_DLY_OFF + subfield_offset),
                                                  ETIME120_REG_LINE_REF_CNT_DLY_REG_BIT_LINE_REF_CNT_DLY_OFF + subfield_offset,
                                                  value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_LINE_REF_CNT_DLY_get( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_LINE_REF_CNT_DLY_get( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_LINE_REF_CNT_DLY_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_LINE_REF_CNT_DLY_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000002a8 bits 31:0) field LINE_REF_CNT_DLY of register PMC_ETIME120_REG_LINE_REF_CNT_DLY_REG */
    reg_value = etime_reg_LINE_REF_CNT_DLY_REG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_LINE_REF_CNT_DLY_REG_BIT_LINE_REF_CNT_DLY_MSK)
                  >> ETIME120_REG_LINE_REF_CNT_DLY_REG_BIT_LINE_REF_CNT_DLY_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_LINE_REF_CNT_DLY_REG_BIT_LINE_REF_CNT_DLY_MSK, ETIME120_REG_LINE_REF_CNT_DLY_REG_BIT_LINE_REF_CNT_DLY_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_LINE_REF_CNT_DLY_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_IRIGO_OFFS_S_set( etime_buffer_t *b_ptr,
                                                 etime_handle_t *h_ptr,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGO_OFFS_S_set( etime_buffer_t *b_ptr,
                                                 etime_handle_t *h_ptr,
                                                 UINT32 value )
{
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGO_OFFS_S_set", value, 65535);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGO_OFFS_S_set", value );

    /* (0x000002dc bits 15:0) field IRIGO_OFFS_S of register PMC_ETIME120_REG_IRIGO_OFFS_S_REG */
    etime_reg_IRIGO_OFFS_S_REG_field_set( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_IRIGO_OFFS_S_REG_BIT_IRIGO_OFFS_S_MSK,
                                          ETIME120_REG_IRIGO_OFFS_S_REG_BIT_IRIGO_OFFS_S_OFF,
                                          value);
}

static INLINE UINT32 etime_field_IRIGO_OFFS_S_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGO_OFFS_S_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000002dc bits 15:0) field IRIGO_OFFS_S of register PMC_ETIME120_REG_IRIGO_OFFS_S_REG */
    reg_value = etime_reg_IRIGO_OFFS_S_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_IRIGO_OFFS_S_REG_BIT_IRIGO_OFFS_S_MSK) >> ETIME120_REG_IRIGO_OFFS_S_REG_BIT_IRIGO_OFFS_S_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGO_OFFS_S_get", value );

    return value;
}
static INLINE void etime_field_range_IRIGO_OFFS_S_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_IRIGO_OFFS_S_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 start_bit,
                                                       UINT32 stop_bit,
                                                       UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGO_OFFS_S_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGO_OFFS_S_set", stop_bit, 15 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGO_OFFS_S_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000002dc bits 15:0) field IRIGO_OFFS_S of register PMC_ETIME120_REG_IRIGO_OFFS_S_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000002dc bits 15:0) field IRIGO_OFFS_S of register PMC_ETIME120_REG_IRIGO_OFFS_S_REG */
        etime_reg_IRIGO_OFFS_S_REG_field_set( b_ptr,
                                              h_ptr,
                                              subfield_mask << (ETIME120_REG_IRIGO_OFFS_S_REG_BIT_IRIGO_OFFS_S_OFF + subfield_offset),
                                              ETIME120_REG_IRIGO_OFFS_S_REG_BIT_IRIGO_OFFS_S_OFF + subfield_offset,
                                              value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_IRIGO_OFFS_S_get( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_IRIGO_OFFS_S_get( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGO_OFFS_S_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGO_OFFS_S_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000002dc bits 15:0) field IRIGO_OFFS_S of register PMC_ETIME120_REG_IRIGO_OFFS_S_REG */
    reg_value = etime_reg_IRIGO_OFFS_S_REG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_IRIGO_OFFS_S_REG_BIT_IRIGO_OFFS_S_MSK)
                  >> ETIME120_REG_IRIGO_OFFS_S_REG_BIT_IRIGO_OFFS_S_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_IRIGO_OFFS_S_REG_BIT_IRIGO_OFFS_S_MSK, ETIME120_REG_IRIGO_OFFS_S_REG_BIT_IRIGO_OFFS_S_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGO_OFFS_S_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_IRIGO_OFFS_NS_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGO_OFFS_NS_set( etime_buffer_t *b_ptr,
                                                  etime_handle_t *h_ptr,
                                                  UINT32 value )
{
    if (value > 2147483647)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGO_OFFS_NS_set", value, 2147483647);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGO_OFFS_NS_set", value );

    /* (0x000002e0 bits 30:0) field IRIGO_OFFS_NS of register PMC_ETIME120_REG_IRIGO_OFFS_NS_REG */
    etime_reg_IRIGO_OFFS_NS_REG_field_set( b_ptr,
                                           h_ptr,
                                           ETIME120_REG_IRIGO_OFFS_NS_REG_BIT_IRIGO_OFFS_NS_MSK,
                                           ETIME120_REG_IRIGO_OFFS_NS_REG_BIT_IRIGO_OFFS_NS_OFF,
                                           value);
}

static INLINE UINT32 etime_field_IRIGO_OFFS_NS_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGO_OFFS_NS_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000002e0 bits 30:0) field IRIGO_OFFS_NS of register PMC_ETIME120_REG_IRIGO_OFFS_NS_REG */
    reg_value = etime_reg_IRIGO_OFFS_NS_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_IRIGO_OFFS_NS_REG_BIT_IRIGO_OFFS_NS_MSK) >> ETIME120_REG_IRIGO_OFFS_NS_REG_BIT_IRIGO_OFFS_NS_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGO_OFFS_NS_get", value );

    return value;
}
static INLINE void etime_field_range_IRIGO_OFFS_NS_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_IRIGO_OFFS_NS_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit,
                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGO_OFFS_NS_set", stop_bit, start_bit );
    if (stop_bit > 30) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGO_OFFS_NS_set", stop_bit, 30 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGO_OFFS_NS_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000002e0 bits 30:0) field IRIGO_OFFS_NS of register PMC_ETIME120_REG_IRIGO_OFFS_NS_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 30) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 30;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000002e0 bits 30:0) field IRIGO_OFFS_NS of register PMC_ETIME120_REG_IRIGO_OFFS_NS_REG */
        etime_reg_IRIGO_OFFS_NS_REG_field_set( b_ptr,
                                               h_ptr,
                                               subfield_mask << (ETIME120_REG_IRIGO_OFFS_NS_REG_BIT_IRIGO_OFFS_NS_OFF + subfield_offset),
                                               ETIME120_REG_IRIGO_OFFS_NS_REG_BIT_IRIGO_OFFS_NS_OFF + subfield_offset,
                                               value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_IRIGO_OFFS_NS_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_IRIGO_OFFS_NS_get( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_IRIGO_OFFS_NS_get", stop_bit, start_bit );
    if (stop_bit > 30) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_IRIGO_OFFS_NS_get", stop_bit, 30 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 30) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 30;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000002e0 bits 30:0) field IRIGO_OFFS_NS of register PMC_ETIME120_REG_IRIGO_OFFS_NS_REG */
    reg_value = etime_reg_IRIGO_OFFS_NS_REG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_IRIGO_OFFS_NS_REG_BIT_IRIGO_OFFS_NS_MSK)
                  >> ETIME120_REG_IRIGO_OFFS_NS_REG_BIT_IRIGO_OFFS_NS_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_IRIGO_OFFS_NS_REG_BIT_IRIGO_OFFS_NS_MSK, ETIME120_REG_IRIGO_OFFS_NS_REG_BIT_IRIGO_OFFS_NS_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_IRIGO_OFFS_NS_get", start_bit, stop_bit, value );

    return value;
}

/*
 * ==================================================================================
 * Parameter Access Functions for Paramset config_edge
 * ==================================================================================
 */
static INLINE void etime_field_REFL_LINK_RESET_11_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_LINK_RESET_11_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_LINK_RESET_11_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_LINK_RESET_11_set", value );

    /* (0x00000000 bits 11) field REFL_LINK_RESET_11 of register PMC_ETIME120_REG_REFLLRR */
    etime_reg_REFLLRR_field_set( b_ptr,
                                 h_ptr,
                                 ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_11_MSK,
                                 ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_11_OFF,
                                 value);
}

static INLINE UINT32 etime_field_REFL_LINK_RESET_11_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_LINK_RESET_11_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000000 bits 11) field REFL_LINK_RESET_11 of register PMC_ETIME120_REG_REFLLRR */
    reg_value = etime_reg_REFLLRR_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_11_MSK) >> ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_11_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_LINK_RESET_11_get", value );

    return value;
}
static INLINE void etime_field_REFL_LINK_RESET_10_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_LINK_RESET_10_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_LINK_RESET_10_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_LINK_RESET_10_set", value );

    /* (0x00000000 bits 10) field REFL_LINK_RESET_10 of register PMC_ETIME120_REG_REFLLRR */
    etime_reg_REFLLRR_field_set( b_ptr,
                                 h_ptr,
                                 ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_10_MSK,
                                 ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_10_OFF,
                                 value);
}

static INLINE UINT32 etime_field_REFL_LINK_RESET_10_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_LINK_RESET_10_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000000 bits 10) field REFL_LINK_RESET_10 of register PMC_ETIME120_REG_REFLLRR */
    reg_value = etime_reg_REFLLRR_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_10_MSK) >> ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_10_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_LINK_RESET_10_get", value );

    return value;
}
static INLINE void etime_field_REFL_LINK_RESET_9_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_LINK_RESET_9_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_LINK_RESET_9_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_LINK_RESET_9_set", value );

    /* (0x00000000 bits 9) field REFL_LINK_RESET_9 of register PMC_ETIME120_REG_REFLLRR */
    etime_reg_REFLLRR_field_set( b_ptr,
                                 h_ptr,
                                 ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_9_MSK,
                                 ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_9_OFF,
                                 value);
}

static INLINE UINT32 etime_field_REFL_LINK_RESET_9_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_LINK_RESET_9_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000000 bits 9) field REFL_LINK_RESET_9 of register PMC_ETIME120_REG_REFLLRR */
    reg_value = etime_reg_REFLLRR_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_9_MSK) >> ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_9_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_LINK_RESET_9_get", value );

    return value;
}
static INLINE void etime_field_REFL_LINK_RESET_8_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_LINK_RESET_8_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_LINK_RESET_8_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_LINK_RESET_8_set", value );

    /* (0x00000000 bits 8) field REFL_LINK_RESET_8 of register PMC_ETIME120_REG_REFLLRR */
    etime_reg_REFLLRR_field_set( b_ptr,
                                 h_ptr,
                                 ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_8_MSK,
                                 ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_8_OFF,
                                 value);
}

static INLINE UINT32 etime_field_REFL_LINK_RESET_8_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_LINK_RESET_8_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000000 bits 8) field REFL_LINK_RESET_8 of register PMC_ETIME120_REG_REFLLRR */
    reg_value = etime_reg_REFLLRR_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_8_MSK) >> ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_8_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_LINK_RESET_8_get", value );

    return value;
}
static INLINE void etime_field_REFL_LINK_RESET_7_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_LINK_RESET_7_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_LINK_RESET_7_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_LINK_RESET_7_set", value );

    /* (0x00000000 bits 7) field REFL_LINK_RESET_7 of register PMC_ETIME120_REG_REFLLRR */
    etime_reg_REFLLRR_field_set( b_ptr,
                                 h_ptr,
                                 ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_7_MSK,
                                 ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_7_OFF,
                                 value);
}

static INLINE UINT32 etime_field_REFL_LINK_RESET_7_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_LINK_RESET_7_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000000 bits 7) field REFL_LINK_RESET_7 of register PMC_ETIME120_REG_REFLLRR */
    reg_value = etime_reg_REFLLRR_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_7_MSK) >> ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_7_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_LINK_RESET_7_get", value );

    return value;
}
static INLINE void etime_field_REFL_LINK_RESET_6_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_LINK_RESET_6_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_LINK_RESET_6_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_LINK_RESET_6_set", value );

    /* (0x00000000 bits 6) field REFL_LINK_RESET_6 of register PMC_ETIME120_REG_REFLLRR */
    etime_reg_REFLLRR_field_set( b_ptr,
                                 h_ptr,
                                 ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_6_MSK,
                                 ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_6_OFF,
                                 value);
}

static INLINE UINT32 etime_field_REFL_LINK_RESET_6_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_LINK_RESET_6_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000000 bits 6) field REFL_LINK_RESET_6 of register PMC_ETIME120_REG_REFLLRR */
    reg_value = etime_reg_REFLLRR_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_6_MSK) >> ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_6_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_LINK_RESET_6_get", value );

    return value;
}
static INLINE void etime_field_REFL_LINK_RESET_5_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_LINK_RESET_5_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_LINK_RESET_5_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_LINK_RESET_5_set", value );

    /* (0x00000000 bits 5) field REFL_LINK_RESET_5 of register PMC_ETIME120_REG_REFLLRR */
    etime_reg_REFLLRR_field_set( b_ptr,
                                 h_ptr,
                                 ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_5_MSK,
                                 ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_5_OFF,
                                 value);
}

static INLINE UINT32 etime_field_REFL_LINK_RESET_5_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_LINK_RESET_5_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000000 bits 5) field REFL_LINK_RESET_5 of register PMC_ETIME120_REG_REFLLRR */
    reg_value = etime_reg_REFLLRR_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_5_MSK) >> ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_5_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_LINK_RESET_5_get", value );

    return value;
}
static INLINE void etime_field_REFL_LINK_RESET_4_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_LINK_RESET_4_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_LINK_RESET_4_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_LINK_RESET_4_set", value );

    /* (0x00000000 bits 4) field REFL_LINK_RESET_4 of register PMC_ETIME120_REG_REFLLRR */
    etime_reg_REFLLRR_field_set( b_ptr,
                                 h_ptr,
                                 ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_4_MSK,
                                 ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_4_OFF,
                                 value);
}

static INLINE UINT32 etime_field_REFL_LINK_RESET_4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_LINK_RESET_4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000000 bits 4) field REFL_LINK_RESET_4 of register PMC_ETIME120_REG_REFLLRR */
    reg_value = etime_reg_REFLLRR_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_4_MSK) >> ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_4_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_LINK_RESET_4_get", value );

    return value;
}
static INLINE void etime_field_REFL_LINK_RESET_3_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_LINK_RESET_3_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_LINK_RESET_3_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_LINK_RESET_3_set", value );

    /* (0x00000000 bits 3) field REFL_LINK_RESET_3 of register PMC_ETIME120_REG_REFLLRR */
    etime_reg_REFLLRR_field_set( b_ptr,
                                 h_ptr,
                                 ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_3_MSK,
                                 ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_3_OFF,
                                 value);
}

static INLINE UINT32 etime_field_REFL_LINK_RESET_3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_LINK_RESET_3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000000 bits 3) field REFL_LINK_RESET_3 of register PMC_ETIME120_REG_REFLLRR */
    reg_value = etime_reg_REFLLRR_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_3_MSK) >> ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_3_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_LINK_RESET_3_get", value );

    return value;
}
static INLINE void etime_field_REFL_LINK_RESET_2_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_LINK_RESET_2_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_LINK_RESET_2_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_LINK_RESET_2_set", value );

    /* (0x00000000 bits 2) field REFL_LINK_RESET_2 of register PMC_ETIME120_REG_REFLLRR */
    etime_reg_REFLLRR_field_set( b_ptr,
                                 h_ptr,
                                 ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_2_MSK,
                                 ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_2_OFF,
                                 value);
}

static INLINE UINT32 etime_field_REFL_LINK_RESET_2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_LINK_RESET_2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000000 bits 2) field REFL_LINK_RESET_2 of register PMC_ETIME120_REG_REFLLRR */
    reg_value = etime_reg_REFLLRR_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_2_MSK) >> ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_2_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_LINK_RESET_2_get", value );

    return value;
}
static INLINE void etime_field_REFL_LINK_RESET_1_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_LINK_RESET_1_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_LINK_RESET_1_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_LINK_RESET_1_set", value );

    /* (0x00000000 bits 1) field REFL_LINK_RESET_1 of register PMC_ETIME120_REG_REFLLRR */
    etime_reg_REFLLRR_field_set( b_ptr,
                                 h_ptr,
                                 ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_1_MSK,
                                 ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_1_OFF,
                                 value);
}

static INLINE UINT32 etime_field_REFL_LINK_RESET_1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_LINK_RESET_1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000000 bits 1) field REFL_LINK_RESET_1 of register PMC_ETIME120_REG_REFLLRR */
    reg_value = etime_reg_REFLLRR_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_1_MSK) >> ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_1_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_LINK_RESET_1_get", value );

    return value;
}
static INLINE void etime_field_REFL_LINK_RESET_0_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_REFL_LINK_RESET_0_set( etime_buffer_t *b_ptr,
                                                      etime_handle_t *h_ptr,
                                                      UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_REFL_LINK_RESET_0_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_REFL_LINK_RESET_0_set", value );

    /* (0x00000000 bits 0) field REFL_LINK_RESET_0 of register PMC_ETIME120_REG_REFLLRR */
    etime_reg_REFLLRR_field_set( b_ptr,
                                 h_ptr,
                                 ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_0_MSK,
                                 ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_0_OFF,
                                 value);
}

static INLINE UINT32 etime_field_REFL_LINK_RESET_0_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_LINK_RESET_0_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000000 bits 0) field REFL_LINK_RESET_0 of register PMC_ETIME120_REG_REFLLRR */
    reg_value = etime_reg_REFLLRR_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_0_MSK) >> ETIME120_REG_REFLLRR_BIT_REFL_LINK_RESET_0_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_LINK_RESET_0_get", value );

    return value;
}
static INLINE void etime_field_PMON_CNT_CLR_set( etime_buffer_t *b_ptr,
                                                 etime_handle_t *h_ptr,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_PMON_CNT_CLR_set( etime_buffer_t *b_ptr,
                                                 etime_handle_t *h_ptr,
                                                 UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_PMON_CNT_CLR_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_PMON_CNT_CLR_set", value );

    /* (0x00000290 bits 8) field PMON_CNT_CLR of register PMC_ETIME120_REG_EXT_CPB_CFG */
    etime_reg_EXT_CPB_CFG_field_set( b_ptr,
                                     h_ptr,
                                     ETIME120_REG_EXT_CPB_CFG_BIT_PMON_CNT_CLR_MSK,
                                     ETIME120_REG_EXT_CPB_CFG_BIT_PMON_CNT_CLR_OFF,
                                     value);
}

static INLINE UINT32 etime_field_PMON_CNT_CLR_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_PMON_CNT_CLR_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000290 bits 8) field PMON_CNT_CLR of register PMC_ETIME120_REG_EXT_CPB_CFG */
    reg_value = etime_reg_EXT_CPB_CFG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EXT_CPB_CFG_BIT_PMON_CNT_CLR_MSK) >> ETIME120_REG_EXT_CPB_CFG_BIT_PMON_CNT_CLR_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_PMON_CNT_CLR_get", value );

    return value;
}
static INLINE void etime_field_EXT_CPB_LINK_SCH_UPD_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EXT_CPB_LINK_SCH_UPD_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EXT_CPB_LINK_SCH_UPD_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_EXT_CPB_LINK_SCH_UPD_set", value );

    /* (0x00000294 bits 0) field EXT_CPB_LINK_SCH_UPD of register PMC_ETIME120_REG_EXT_LNK_SCH_UPD */
    etime_reg_EXT_LNK_SCH_UPD_field_set( b_ptr,
                                         h_ptr,
                                         ETIME120_REG_EXT_LNK_SCH_UPD_BIT_EXT_CPB_LINK_SCH_UPD_MSK,
                                         ETIME120_REG_EXT_LNK_SCH_UPD_BIT_EXT_CPB_LINK_SCH_UPD_OFF,
                                         value);
}

static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_UPD_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EXT_CPB_LINK_SCH_UPD_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000294 bits 0) field EXT_CPB_LINK_SCH_UPD of register PMC_ETIME120_REG_EXT_LNK_SCH_UPD */
    reg_value = etime_reg_EXT_LNK_SCH_UPD_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EXT_LNK_SCH_UPD_BIT_EXT_CPB_LINK_SCH_UPD_MSK) >> ETIME120_REG_EXT_LNK_SCH_UPD_BIT_EXT_CPB_LINK_SCH_UPD_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EXT_CPB_LINK_SCH_UPD_get", value );

    return value;
}

/*
 * ==================================================================================
 * Parameter Access Functions for Paramset int_enable
 * ==================================================================================
 */
static INLINE void etime_field_RAM_BIT_SB_ECC_INT_E_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_RAM_BIT_SB_ECC_INT_E_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value )
{
    if (value > 131071)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_RAM_BIT_SB_ECC_INT_E_set", value, 131071);
    IOLOG( "%s <= 0x%08x", "etime_field_RAM_BIT_SB_ECC_INT_E_set", value );

    /* (0x0000002c bits 16:0) field RAM_BIT_SB_ECC_INT_E of register PMC_ETIME120_REG_SB_ECC_ERR_INT_EN_REG */
    etime_reg_SB_ECC_ERR_INT_EN_REG_field_set( b_ptr,
                                               h_ptr,
                                               ETIME120_REG_SB_ECC_ERR_INT_EN_REG_BIT_RAM_BIT_SB_ECC_INT_E_MSK,
                                               ETIME120_REG_SB_ECC_ERR_INT_EN_REG_BIT_RAM_BIT_SB_ECC_INT_E_OFF,
                                               value);
}

static INLINE UINT32 etime_field_RAM_BIT_SB_ECC_INT_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_RAM_BIT_SB_ECC_INT_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000002c bits 16:0) field RAM_BIT_SB_ECC_INT_E of register PMC_ETIME120_REG_SB_ECC_ERR_INT_EN_REG */
    reg_value = etime_reg_SB_ECC_ERR_INT_EN_REG_read( b_ptr,
                                                      h_ptr);
    value = (reg_value & ETIME120_REG_SB_ECC_ERR_INT_EN_REG_BIT_RAM_BIT_SB_ECC_INT_E_MSK) >> ETIME120_REG_SB_ECC_ERR_INT_EN_REG_BIT_RAM_BIT_SB_ECC_INT_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_RAM_BIT_SB_ECC_INT_E_get", value );

    return value;
}
static INLINE void etime_field_range_RAM_BIT_SB_ECC_INT_E_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_RAM_BIT_SB_ECC_INT_E_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_RAM_BIT_SB_ECC_INT_E_set", stop_bit, start_bit );
    if (stop_bit > 16) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_RAM_BIT_SB_ECC_INT_E_set", stop_bit, 16 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_RAM_BIT_SB_ECC_INT_E_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000002c bits 16:0) field RAM_BIT_SB_ECC_INT_E of register PMC_ETIME120_REG_SB_ECC_ERR_INT_EN_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 16) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 16;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000002c bits 16:0) field RAM_BIT_SB_ECC_INT_E of register PMC_ETIME120_REG_SB_ECC_ERR_INT_EN_REG */
        etime_reg_SB_ECC_ERR_INT_EN_REG_field_set( b_ptr,
                                                   h_ptr,
                                                   subfield_mask << (ETIME120_REG_SB_ECC_ERR_INT_EN_REG_BIT_RAM_BIT_SB_ECC_INT_E_OFF + subfield_offset),
                                                   ETIME120_REG_SB_ECC_ERR_INT_EN_REG_BIT_RAM_BIT_SB_ECC_INT_E_OFF + subfield_offset,
                                                   value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_RAM_BIT_SB_ECC_INT_E_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_RAM_BIT_SB_ECC_INT_E_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_RAM_BIT_SB_ECC_INT_E_get", stop_bit, start_bit );
    if (stop_bit > 16) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_RAM_BIT_SB_ECC_INT_E_get", stop_bit, 16 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 16) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 16;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000002c bits 16:0) field RAM_BIT_SB_ECC_INT_E of register PMC_ETIME120_REG_SB_ECC_ERR_INT_EN_REG */
    reg_value = etime_reg_SB_ECC_ERR_INT_EN_REG_read( b_ptr,
                                                      h_ptr);
    field_value = (reg_value & ETIME120_REG_SB_ECC_ERR_INT_EN_REG_BIT_RAM_BIT_SB_ECC_INT_E_MSK)
                  >> ETIME120_REG_SB_ECC_ERR_INT_EN_REG_BIT_RAM_BIT_SB_ECC_INT_E_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_SB_ECC_ERR_INT_EN_REG_BIT_RAM_BIT_SB_ECC_INT_E_MSK, ETIME120_REG_SB_ECC_ERR_INT_EN_REG_BIT_RAM_BIT_SB_ECC_INT_E_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_RAM_BIT_SB_ECC_INT_E_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_RAM_BIT_MB_ECC_INT_E_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_RAM_BIT_MB_ECC_INT_E_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value )
{
    if (value > 131071)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_RAM_BIT_MB_ECC_INT_E_set", value, 131071);
    IOLOG( "%s <= 0x%08x", "etime_field_RAM_BIT_MB_ECC_INT_E_set", value );

    /* (0x00000030 bits 16:0) field RAM_BIT_MB_ECC_INT_E of register PMC_ETIME120_REG_MB_ECC_ERR_INT_EN_REG */
    etime_reg_MB_ECC_ERR_INT_EN_REG_field_set( b_ptr,
                                               h_ptr,
                                               ETIME120_REG_MB_ECC_ERR_INT_EN_REG_BIT_RAM_BIT_MB_ECC_INT_E_MSK,
                                               ETIME120_REG_MB_ECC_ERR_INT_EN_REG_BIT_RAM_BIT_MB_ECC_INT_E_OFF,
                                               value);
}

static INLINE UINT32 etime_field_RAM_BIT_MB_ECC_INT_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_RAM_BIT_MB_ECC_INT_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000030 bits 16:0) field RAM_BIT_MB_ECC_INT_E of register PMC_ETIME120_REG_MB_ECC_ERR_INT_EN_REG */
    reg_value = etime_reg_MB_ECC_ERR_INT_EN_REG_read( b_ptr,
                                                      h_ptr);
    value = (reg_value & ETIME120_REG_MB_ECC_ERR_INT_EN_REG_BIT_RAM_BIT_MB_ECC_INT_E_MSK) >> ETIME120_REG_MB_ECC_ERR_INT_EN_REG_BIT_RAM_BIT_MB_ECC_INT_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_RAM_BIT_MB_ECC_INT_E_get", value );

    return value;
}
static INLINE void etime_field_range_RAM_BIT_MB_ECC_INT_E_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_RAM_BIT_MB_ECC_INT_E_set( etime_buffer_t *b_ptr,
                                                               etime_handle_t *h_ptr,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_RAM_BIT_MB_ECC_INT_E_set", stop_bit, start_bit );
    if (stop_bit > 16) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_RAM_BIT_MB_ECC_INT_E_set", stop_bit, 16 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_RAM_BIT_MB_ECC_INT_E_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000030 bits 16:0) field RAM_BIT_MB_ECC_INT_E of register PMC_ETIME120_REG_MB_ECC_ERR_INT_EN_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 16) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 16;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000030 bits 16:0) field RAM_BIT_MB_ECC_INT_E of register PMC_ETIME120_REG_MB_ECC_ERR_INT_EN_REG */
        etime_reg_MB_ECC_ERR_INT_EN_REG_field_set( b_ptr,
                                                   h_ptr,
                                                   subfield_mask << (ETIME120_REG_MB_ECC_ERR_INT_EN_REG_BIT_RAM_BIT_MB_ECC_INT_E_OFF + subfield_offset),
                                                   ETIME120_REG_MB_ECC_ERR_INT_EN_REG_BIT_RAM_BIT_MB_ECC_INT_E_OFF + subfield_offset,
                                                   value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_RAM_BIT_MB_ECC_INT_E_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_RAM_BIT_MB_ECC_INT_E_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_RAM_BIT_MB_ECC_INT_E_get", stop_bit, start_bit );
    if (stop_bit > 16) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_RAM_BIT_MB_ECC_INT_E_get", stop_bit, 16 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 16) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 16;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000030 bits 16:0) field RAM_BIT_MB_ECC_INT_E of register PMC_ETIME120_REG_MB_ECC_ERR_INT_EN_REG */
    reg_value = etime_reg_MB_ECC_ERR_INT_EN_REG_read( b_ptr,
                                                      h_ptr);
    field_value = (reg_value & ETIME120_REG_MB_ECC_ERR_INT_EN_REG_BIT_RAM_BIT_MB_ECC_INT_E_MSK)
                  >> ETIME120_REG_MB_ECC_ERR_INT_EN_REG_BIT_RAM_BIT_MB_ECC_INT_E_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_MB_ECC_ERR_INT_EN_REG_BIT_RAM_BIT_MB_ECC_INT_E_MSK, ETIME120_REG_MB_ECC_ERR_INT_EN_REG_BIT_RAM_BIT_MB_ECC_INT_E_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_RAM_BIT_MB_ECC_INT_E_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_EXT_RAM_OFLOW_INT_E_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EXT_RAM_OFLOW_INT_E_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value )
{
    if (value > 4095)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EXT_RAM_OFLOW_INT_E_set", value, 4095);
    IOLOG( "%s <= 0x%08x", "etime_field_EXT_RAM_OFLOW_INT_E_set", value );

    /* (0x00000034 bits 11:0) field EXT_RAM_OFLOW_INT_E of register PMC_ETIME120_REG_REFL_OFLOW_ERR_INT_EN_REG */
    etime_reg_REFL_OFLOW_ERR_INT_EN_REG_field_set( b_ptr,
                                                   h_ptr,
                                                   ETIME120_REG_REFL_OFLOW_ERR_INT_EN_REG_BIT_EXT_RAM_OFLOW_INT_E_MSK,
                                                   ETIME120_REG_REFL_OFLOW_ERR_INT_EN_REG_BIT_EXT_RAM_OFLOW_INT_E_OFF,
                                                   value);
}

static INLINE UINT32 etime_field_EXT_RAM_OFLOW_INT_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EXT_RAM_OFLOW_INT_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000034 bits 11:0) field EXT_RAM_OFLOW_INT_E of register PMC_ETIME120_REG_REFL_OFLOW_ERR_INT_EN_REG */
    reg_value = etime_reg_REFL_OFLOW_ERR_INT_EN_REG_read( b_ptr,
                                                          h_ptr);
    value = (reg_value & ETIME120_REG_REFL_OFLOW_ERR_INT_EN_REG_BIT_EXT_RAM_OFLOW_INT_E_MSK) >> ETIME120_REG_REFL_OFLOW_ERR_INT_EN_REG_BIT_EXT_RAM_OFLOW_INT_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EXT_RAM_OFLOW_INT_E_get", value );

    return value;
}
static INLINE void etime_field_range_EXT_RAM_OFLOW_INT_E_set( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_EXT_RAM_OFLOW_INT_E_set( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit,
                                                              UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_RAM_OFLOW_INT_E_set", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_RAM_OFLOW_INT_E_set", stop_bit, 11 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_RAM_OFLOW_INT_E_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000034 bits 11:0) field EXT_RAM_OFLOW_INT_E of register PMC_ETIME120_REG_REFL_OFLOW_ERR_INT_EN_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000034 bits 11:0) field EXT_RAM_OFLOW_INT_E of register PMC_ETIME120_REG_REFL_OFLOW_ERR_INT_EN_REG */
        etime_reg_REFL_OFLOW_ERR_INT_EN_REG_field_set( b_ptr,
                                                       h_ptr,
                                                       subfield_mask << (ETIME120_REG_REFL_OFLOW_ERR_INT_EN_REG_BIT_EXT_RAM_OFLOW_INT_E_OFF + subfield_offset),
                                                       ETIME120_REG_REFL_OFLOW_ERR_INT_EN_REG_BIT_EXT_RAM_OFLOW_INT_E_OFF + subfield_offset,
                                                       value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_EXT_RAM_OFLOW_INT_E_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_EXT_RAM_OFLOW_INT_E_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_RAM_OFLOW_INT_E_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_RAM_OFLOW_INT_E_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000034 bits 11:0) field EXT_RAM_OFLOW_INT_E of register PMC_ETIME120_REG_REFL_OFLOW_ERR_INT_EN_REG */
    reg_value = etime_reg_REFL_OFLOW_ERR_INT_EN_REG_read( b_ptr,
                                                          h_ptr);
    field_value = (reg_value & ETIME120_REG_REFL_OFLOW_ERR_INT_EN_REG_BIT_EXT_RAM_OFLOW_INT_E_MSK)
                  >> ETIME120_REG_REFL_OFLOW_ERR_INT_EN_REG_BIT_EXT_RAM_OFLOW_INT_E_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_REFL_OFLOW_ERR_INT_EN_REG_BIT_EXT_RAM_OFLOW_INT_E_MSK, ETIME120_REG_REFL_OFLOW_ERR_INT_EN_REG_BIT_EXT_RAM_OFLOW_INT_E_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_RAM_OFLOW_INT_E_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TS_RAM_WR_DIS_INT_E_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TS_RAM_WR_DIS_INT_E_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value )
{
    if (value > 4095)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TS_RAM_WR_DIS_INT_E_set", value, 4095);
    IOLOG( "%s <= 0x%08x", "etime_field_TS_RAM_WR_DIS_INT_E_set", value );

    /* (0x00000038 bits 23:12) field TS_RAM_WR_DIS_INT_E of register PMC_ETIME120_REG_TS_DIS_INT_EN_REG */
    etime_reg_TS_DIS_INT_EN_REG_field_set( b_ptr,
                                           h_ptr,
                                           ETIME120_REG_TS_DIS_INT_EN_REG_BIT_TS_RAM_WR_DIS_INT_E_MSK,
                                           ETIME120_REG_TS_DIS_INT_EN_REG_BIT_TS_RAM_WR_DIS_INT_E_OFF,
                                           value);
}

static INLINE UINT32 etime_field_TS_RAM_WR_DIS_INT_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TS_RAM_WR_DIS_INT_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000038 bits 23:12) field TS_RAM_WR_DIS_INT_E of register PMC_ETIME120_REG_TS_DIS_INT_EN_REG */
    reg_value = etime_reg_TS_DIS_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TS_DIS_INT_EN_REG_BIT_TS_RAM_WR_DIS_INT_E_MSK) >> ETIME120_REG_TS_DIS_INT_EN_REG_BIT_TS_RAM_WR_DIS_INT_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TS_RAM_WR_DIS_INT_E_get", value );

    return value;
}
static INLINE void etime_field_range_TS_RAM_WR_DIS_INT_E_set( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TS_RAM_WR_DIS_INT_E_set( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit,
                                                              UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TS_RAM_WR_DIS_INT_E_set", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TS_RAM_WR_DIS_INT_E_set", stop_bit, 11 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TS_RAM_WR_DIS_INT_E_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000038 bits 23:12) field TS_RAM_WR_DIS_INT_E of register PMC_ETIME120_REG_TS_DIS_INT_EN_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000038 bits 23:12) field TS_RAM_WR_DIS_INT_E of register PMC_ETIME120_REG_TS_DIS_INT_EN_REG */
        etime_reg_TS_DIS_INT_EN_REG_field_set( b_ptr,
                                               h_ptr,
                                               subfield_mask << (ETIME120_REG_TS_DIS_INT_EN_REG_BIT_TS_RAM_WR_DIS_INT_E_OFF + subfield_offset),
                                               ETIME120_REG_TS_DIS_INT_EN_REG_BIT_TS_RAM_WR_DIS_INT_E_OFF + subfield_offset,
                                               value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TS_RAM_WR_DIS_INT_E_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TS_RAM_WR_DIS_INT_E_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TS_RAM_WR_DIS_INT_E_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TS_RAM_WR_DIS_INT_E_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000038 bits 23:12) field TS_RAM_WR_DIS_INT_E of register PMC_ETIME120_REG_TS_DIS_INT_EN_REG */
    reg_value = etime_reg_TS_DIS_INT_EN_REG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TS_DIS_INT_EN_REG_BIT_TS_RAM_WR_DIS_INT_E_MSK)
                  >> ETIME120_REG_TS_DIS_INT_EN_REG_BIT_TS_RAM_WR_DIS_INT_E_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TS_DIS_INT_EN_REG_BIT_TS_RAM_WR_DIS_INT_E_MSK, ETIME120_REG_TS_DIS_INT_EN_REG_BIT_TS_RAM_WR_DIS_INT_E_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TS_RAM_WR_DIS_INT_E_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_TS_RAM_RD_DIS_INT_E_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TS_RAM_RD_DIS_INT_E_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value )
{
    if (value > 4095)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TS_RAM_RD_DIS_INT_E_set", value, 4095);
    IOLOG( "%s <= 0x%08x", "etime_field_TS_RAM_RD_DIS_INT_E_set", value );

    /* (0x00000038 bits 11:0) field TS_RAM_RD_DIS_INT_E of register PMC_ETIME120_REG_TS_DIS_INT_EN_REG */
    etime_reg_TS_DIS_INT_EN_REG_field_set( b_ptr,
                                           h_ptr,
                                           ETIME120_REG_TS_DIS_INT_EN_REG_BIT_TS_RAM_RD_DIS_INT_E_MSK,
                                           ETIME120_REG_TS_DIS_INT_EN_REG_BIT_TS_RAM_RD_DIS_INT_E_OFF,
                                           value);
}

static INLINE UINT32 etime_field_TS_RAM_RD_DIS_INT_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TS_RAM_RD_DIS_INT_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000038 bits 11:0) field TS_RAM_RD_DIS_INT_E of register PMC_ETIME120_REG_TS_DIS_INT_EN_REG */
    reg_value = etime_reg_TS_DIS_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TS_DIS_INT_EN_REG_BIT_TS_RAM_RD_DIS_INT_E_MSK) >> ETIME120_REG_TS_DIS_INT_EN_REG_BIT_TS_RAM_RD_DIS_INT_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TS_RAM_RD_DIS_INT_E_get", value );

    return value;
}
static INLINE void etime_field_range_TS_RAM_RD_DIS_INT_E_set( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TS_RAM_RD_DIS_INT_E_set( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit,
                                                              UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TS_RAM_RD_DIS_INT_E_set", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TS_RAM_RD_DIS_INT_E_set", stop_bit, 11 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TS_RAM_RD_DIS_INT_E_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000038 bits 11:0) field TS_RAM_RD_DIS_INT_E of register PMC_ETIME120_REG_TS_DIS_INT_EN_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000038 bits 11:0) field TS_RAM_RD_DIS_INT_E of register PMC_ETIME120_REG_TS_DIS_INT_EN_REG */
        etime_reg_TS_DIS_INT_EN_REG_field_set( b_ptr,
                                               h_ptr,
                                               subfield_mask << (ETIME120_REG_TS_DIS_INT_EN_REG_BIT_TS_RAM_RD_DIS_INT_E_OFF + subfield_offset),
                                               ETIME120_REG_TS_DIS_INT_EN_REG_BIT_TS_RAM_RD_DIS_INT_E_OFF + subfield_offset,
                                               value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TS_RAM_RD_DIS_INT_E_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TS_RAM_RD_DIS_INT_E_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TS_RAM_RD_DIS_INT_E_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TS_RAM_RD_DIS_INT_E_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000038 bits 11:0) field TS_RAM_RD_DIS_INT_E of register PMC_ETIME120_REG_TS_DIS_INT_EN_REG */
    reg_value = etime_reg_TS_DIS_INT_EN_REG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TS_DIS_INT_EN_REG_BIT_TS_RAM_RD_DIS_INT_E_MSK)
                  >> ETIME120_REG_TS_DIS_INT_EN_REG_BIT_TS_RAM_RD_DIS_INT_E_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TS_DIS_INT_EN_REG_BIT_TS_RAM_RD_DIS_INT_E_MSK, ETIME120_REG_TS_DIS_INT_EN_REG_BIT_TS_RAM_RD_DIS_INT_E_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TS_RAM_RD_DIS_INT_E_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_PACKET_RAM_WR_DIS_INT_E_set( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_PACKET_RAM_WR_DIS_INT_E_set( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 value )
{
    if (value > 4095)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_PACKET_RAM_WR_DIS_INT_E_set", value, 4095);
    IOLOG( "%s <= 0x%08x", "etime_field_PACKET_RAM_WR_DIS_INT_E_set", value );

    /* (0x0000003c bits 23:12) field PACKET_RAM_WR_DIS_INT_E of register PMC_ETIME120_REG_PACKET_DIS_INT_EN_REG */
    etime_reg_PACKET_DIS_INT_EN_REG_field_set( b_ptr,
                                               h_ptr,
                                               ETIME120_REG_PACKET_DIS_INT_EN_REG_BIT_PACKET_RAM_WR_DIS_INT_E_MSK,
                                               ETIME120_REG_PACKET_DIS_INT_EN_REG_BIT_PACKET_RAM_WR_DIS_INT_E_OFF,
                                               value);
}

static INLINE UINT32 etime_field_PACKET_RAM_WR_DIS_INT_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_PACKET_RAM_WR_DIS_INT_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000003c bits 23:12) field PACKET_RAM_WR_DIS_INT_E of register PMC_ETIME120_REG_PACKET_DIS_INT_EN_REG */
    reg_value = etime_reg_PACKET_DIS_INT_EN_REG_read( b_ptr,
                                                      h_ptr);
    value = (reg_value & ETIME120_REG_PACKET_DIS_INT_EN_REG_BIT_PACKET_RAM_WR_DIS_INT_E_MSK) >> ETIME120_REG_PACKET_DIS_INT_EN_REG_BIT_PACKET_RAM_WR_DIS_INT_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_PACKET_RAM_WR_DIS_INT_E_get", value );

    return value;
}
static INLINE void etime_field_range_PACKET_RAM_WR_DIS_INT_E_set( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_PACKET_RAM_WR_DIS_INT_E_set( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_PACKET_RAM_WR_DIS_INT_E_set", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_PACKET_RAM_WR_DIS_INT_E_set", stop_bit, 11 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_PACKET_RAM_WR_DIS_INT_E_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000003c bits 23:12) field PACKET_RAM_WR_DIS_INT_E of register PMC_ETIME120_REG_PACKET_DIS_INT_EN_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000003c bits 23:12) field PACKET_RAM_WR_DIS_INT_E of register PMC_ETIME120_REG_PACKET_DIS_INT_EN_REG */
        etime_reg_PACKET_DIS_INT_EN_REG_field_set( b_ptr,
                                                   h_ptr,
                                                   subfield_mask << (ETIME120_REG_PACKET_DIS_INT_EN_REG_BIT_PACKET_RAM_WR_DIS_INT_E_OFF + subfield_offset),
                                                   ETIME120_REG_PACKET_DIS_INT_EN_REG_BIT_PACKET_RAM_WR_DIS_INT_E_OFF + subfield_offset,
                                                   value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_PACKET_RAM_WR_DIS_INT_E_get( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_PACKET_RAM_WR_DIS_INT_E_get( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_PACKET_RAM_WR_DIS_INT_E_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_PACKET_RAM_WR_DIS_INT_E_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000003c bits 23:12) field PACKET_RAM_WR_DIS_INT_E of register PMC_ETIME120_REG_PACKET_DIS_INT_EN_REG */
    reg_value = etime_reg_PACKET_DIS_INT_EN_REG_read( b_ptr,
                                                      h_ptr);
    field_value = (reg_value & ETIME120_REG_PACKET_DIS_INT_EN_REG_BIT_PACKET_RAM_WR_DIS_INT_E_MSK)
                  >> ETIME120_REG_PACKET_DIS_INT_EN_REG_BIT_PACKET_RAM_WR_DIS_INT_E_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_PACKET_DIS_INT_EN_REG_BIT_PACKET_RAM_WR_DIS_INT_E_MSK, ETIME120_REG_PACKET_DIS_INT_EN_REG_BIT_PACKET_RAM_WR_DIS_INT_E_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_PACKET_RAM_WR_DIS_INT_E_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_PACKET_RAM_RD_DIS_INT_E_set( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_PACKET_RAM_RD_DIS_INT_E_set( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 value )
{
    if (value > 4095)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_PACKET_RAM_RD_DIS_INT_E_set", value, 4095);
    IOLOG( "%s <= 0x%08x", "etime_field_PACKET_RAM_RD_DIS_INT_E_set", value );

    /* (0x0000003c bits 11:0) field PACKET_RAM_RD_DIS_INT_E of register PMC_ETIME120_REG_PACKET_DIS_INT_EN_REG */
    etime_reg_PACKET_DIS_INT_EN_REG_field_set( b_ptr,
                                               h_ptr,
                                               ETIME120_REG_PACKET_DIS_INT_EN_REG_BIT_PACKET_RAM_RD_DIS_INT_E_MSK,
                                               ETIME120_REG_PACKET_DIS_INT_EN_REG_BIT_PACKET_RAM_RD_DIS_INT_E_OFF,
                                               value);
}

static INLINE UINT32 etime_field_PACKET_RAM_RD_DIS_INT_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_PACKET_RAM_RD_DIS_INT_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000003c bits 11:0) field PACKET_RAM_RD_DIS_INT_E of register PMC_ETIME120_REG_PACKET_DIS_INT_EN_REG */
    reg_value = etime_reg_PACKET_DIS_INT_EN_REG_read( b_ptr,
                                                      h_ptr);
    value = (reg_value & ETIME120_REG_PACKET_DIS_INT_EN_REG_BIT_PACKET_RAM_RD_DIS_INT_E_MSK) >> ETIME120_REG_PACKET_DIS_INT_EN_REG_BIT_PACKET_RAM_RD_DIS_INT_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_PACKET_RAM_RD_DIS_INT_E_get", value );

    return value;
}
static INLINE void etime_field_range_PACKET_RAM_RD_DIS_INT_E_set( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_PACKET_RAM_RD_DIS_INT_E_set( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_PACKET_RAM_RD_DIS_INT_E_set", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_PACKET_RAM_RD_DIS_INT_E_set", stop_bit, 11 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_PACKET_RAM_RD_DIS_INT_E_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000003c bits 11:0) field PACKET_RAM_RD_DIS_INT_E of register PMC_ETIME120_REG_PACKET_DIS_INT_EN_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000003c bits 11:0) field PACKET_RAM_RD_DIS_INT_E of register PMC_ETIME120_REG_PACKET_DIS_INT_EN_REG */
        etime_reg_PACKET_DIS_INT_EN_REG_field_set( b_ptr,
                                                   h_ptr,
                                                   subfield_mask << (ETIME120_REG_PACKET_DIS_INT_EN_REG_BIT_PACKET_RAM_RD_DIS_INT_E_OFF + subfield_offset),
                                                   ETIME120_REG_PACKET_DIS_INT_EN_REG_BIT_PACKET_RAM_RD_DIS_INT_E_OFF + subfield_offset,
                                                   value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_PACKET_RAM_RD_DIS_INT_E_get( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_PACKET_RAM_RD_DIS_INT_E_get( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_PACKET_RAM_RD_DIS_INT_E_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_PACKET_RAM_RD_DIS_INT_E_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000003c bits 11:0) field PACKET_RAM_RD_DIS_INT_E of register PMC_ETIME120_REG_PACKET_DIS_INT_EN_REG */
    reg_value = etime_reg_PACKET_DIS_INT_EN_REG_read( b_ptr,
                                                      h_ptr);
    field_value = (reg_value & ETIME120_REG_PACKET_DIS_INT_EN_REG_BIT_PACKET_RAM_RD_DIS_INT_E_MSK)
                  >> ETIME120_REG_PACKET_DIS_INT_EN_REG_BIT_PACKET_RAM_RD_DIS_INT_E_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_PACKET_DIS_INT_EN_REG_BIT_PACKET_RAM_RD_DIS_INT_E_MSK, ETIME120_REG_PACKET_DIS_INT_EN_REG_BIT_PACKET_RAM_RD_DIS_INT_E_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_PACKET_RAM_RD_DIS_INT_E_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_PACKET_RAM_OSIZE_INT_E_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_PACKET_RAM_OSIZE_INT_E_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 value )
{
    if (value > 4095)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_PACKET_RAM_OSIZE_INT_E_set", value, 4095);
    IOLOG( "%s <= 0x%08x", "etime_field_PACKET_RAM_OSIZE_INT_E_set", value );

    /* (0x00000040 bits 11:0) field PACKET_RAM_OSIZE_INT_E of register PMC_ETIME120_REG_PACKET_RAM_ERR_INT_EN_REG */
    etime_reg_PACKET_RAM_ERR_INT_EN_REG_field_set( b_ptr,
                                                   h_ptr,
                                                   ETIME120_REG_PACKET_RAM_ERR_INT_EN_REG_BIT_PACKET_RAM_OSIZE_INT_E_MSK,
                                                   ETIME120_REG_PACKET_RAM_ERR_INT_EN_REG_BIT_PACKET_RAM_OSIZE_INT_E_OFF,
                                                   value);
}

static INLINE UINT32 etime_field_PACKET_RAM_OSIZE_INT_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_PACKET_RAM_OSIZE_INT_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000040 bits 11:0) field PACKET_RAM_OSIZE_INT_E of register PMC_ETIME120_REG_PACKET_RAM_ERR_INT_EN_REG */
    reg_value = etime_reg_PACKET_RAM_ERR_INT_EN_REG_read( b_ptr,
                                                          h_ptr);
    value = (reg_value & ETIME120_REG_PACKET_RAM_ERR_INT_EN_REG_BIT_PACKET_RAM_OSIZE_INT_E_MSK) >> ETIME120_REG_PACKET_RAM_ERR_INT_EN_REG_BIT_PACKET_RAM_OSIZE_INT_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_PACKET_RAM_OSIZE_INT_E_get", value );

    return value;
}
static INLINE void etime_field_range_PACKET_RAM_OSIZE_INT_E_set( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_PACKET_RAM_OSIZE_INT_E_set( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_PACKET_RAM_OSIZE_INT_E_set", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_PACKET_RAM_OSIZE_INT_E_set", stop_bit, 11 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_PACKET_RAM_OSIZE_INT_E_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000040 bits 11:0) field PACKET_RAM_OSIZE_INT_E of register PMC_ETIME120_REG_PACKET_RAM_ERR_INT_EN_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000040 bits 11:0) field PACKET_RAM_OSIZE_INT_E of register PMC_ETIME120_REG_PACKET_RAM_ERR_INT_EN_REG */
        etime_reg_PACKET_RAM_ERR_INT_EN_REG_field_set( b_ptr,
                                                       h_ptr,
                                                       subfield_mask << (ETIME120_REG_PACKET_RAM_ERR_INT_EN_REG_BIT_PACKET_RAM_OSIZE_INT_E_OFF + subfield_offset),
                                                       ETIME120_REG_PACKET_RAM_ERR_INT_EN_REG_BIT_PACKET_RAM_OSIZE_INT_E_OFF + subfield_offset,
                                                       value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_PACKET_RAM_OSIZE_INT_E_get( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_PACKET_RAM_OSIZE_INT_E_get( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_PACKET_RAM_OSIZE_INT_E_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_PACKET_RAM_OSIZE_INT_E_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000040 bits 11:0) field PACKET_RAM_OSIZE_INT_E of register PMC_ETIME120_REG_PACKET_RAM_ERR_INT_EN_REG */
    reg_value = etime_reg_PACKET_RAM_ERR_INT_EN_REG_read( b_ptr,
                                                          h_ptr);
    field_value = (reg_value & ETIME120_REG_PACKET_RAM_ERR_INT_EN_REG_BIT_PACKET_RAM_OSIZE_INT_E_MSK)
                  >> ETIME120_REG_PACKET_RAM_ERR_INT_EN_REG_BIT_PACKET_RAM_OSIZE_INT_E_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_PACKET_RAM_ERR_INT_EN_REG_BIT_PACKET_RAM_OSIZE_INT_E_MSK, ETIME120_REG_PACKET_RAM_ERR_INT_EN_REG_BIT_PACKET_RAM_OSIZE_INT_E_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_PACKET_RAM_OSIZE_INT_E_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_EXT_DESYNC_INT_E_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EXT_DESYNC_INT_E_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    if (value > 4095)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EXT_DESYNC_INT_E_set", value, 4095);
    IOLOG( "%s <= 0x%08x", "etime_field_EXT_DESYNC_INT_E_set", value );

    /* (0x00000044 bits 11:0) field EXT_DESYNC_INT_E of register PMC_ETIME120_REG_EXT_DESYNC_ERR_INT_EN_REG */
    etime_reg_EXT_DESYNC_ERR_INT_EN_REG_field_set( b_ptr,
                                                   h_ptr,
                                                   ETIME120_REG_EXT_DESYNC_ERR_INT_EN_REG_BIT_EXT_DESYNC_INT_E_MSK,
                                                   ETIME120_REG_EXT_DESYNC_ERR_INT_EN_REG_BIT_EXT_DESYNC_INT_E_OFF,
                                                   value);
}

static INLINE UINT32 etime_field_EXT_DESYNC_INT_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EXT_DESYNC_INT_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000044 bits 11:0) field EXT_DESYNC_INT_E of register PMC_ETIME120_REG_EXT_DESYNC_ERR_INT_EN_REG */
    reg_value = etime_reg_EXT_DESYNC_ERR_INT_EN_REG_read( b_ptr,
                                                          h_ptr);
    value = (reg_value & ETIME120_REG_EXT_DESYNC_ERR_INT_EN_REG_BIT_EXT_DESYNC_INT_E_MSK) >> ETIME120_REG_EXT_DESYNC_ERR_INT_EN_REG_BIT_EXT_DESYNC_INT_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EXT_DESYNC_INT_E_get", value );

    return value;
}
static INLINE void etime_field_range_EXT_DESYNC_INT_E_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_EXT_DESYNC_INT_E_set( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit,
                                                           UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_DESYNC_INT_E_set", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_DESYNC_INT_E_set", stop_bit, 11 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_DESYNC_INT_E_set", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000044 bits 11:0) field EXT_DESYNC_INT_E of register PMC_ETIME120_REG_EXT_DESYNC_ERR_INT_EN_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000044 bits 11:0) field EXT_DESYNC_INT_E of register PMC_ETIME120_REG_EXT_DESYNC_ERR_INT_EN_REG */
        etime_reg_EXT_DESYNC_ERR_INT_EN_REG_field_set( b_ptr,
                                                       h_ptr,
                                                       subfield_mask << (ETIME120_REG_EXT_DESYNC_ERR_INT_EN_REG_BIT_EXT_DESYNC_INT_E_OFF + subfield_offset),
                                                       ETIME120_REG_EXT_DESYNC_ERR_INT_EN_REG_BIT_EXT_DESYNC_INT_E_OFF + subfield_offset,
                                                       value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_EXT_DESYNC_INT_E_get( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_EXT_DESYNC_INT_E_get( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_DESYNC_INT_E_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_DESYNC_INT_E_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000044 bits 11:0) field EXT_DESYNC_INT_E of register PMC_ETIME120_REG_EXT_DESYNC_ERR_INT_EN_REG */
    reg_value = etime_reg_EXT_DESYNC_ERR_INT_EN_REG_read( b_ptr,
                                                          h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_DESYNC_ERR_INT_EN_REG_BIT_EXT_DESYNC_INT_E_MSK)
                  >> ETIME120_REG_EXT_DESYNC_ERR_INT_EN_REG_BIT_EXT_DESYNC_INT_E_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_DESYNC_ERR_INT_EN_REG_BIT_EXT_DESYNC_INT_E_MSK, ETIME120_REG_EXT_DESYNC_ERR_INT_EN_REG_BIT_EXT_DESYNC_INT_E_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_DESYNC_INT_E_get", start_bit, stop_bit, value );

    return value;
}
static INLINE void etime_field_ILLEGAL_1STEP_INT_E_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_ILLEGAL_1STEP_INT_E_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_ILLEGAL_1STEP_INT_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_ILLEGAL_1STEP_INT_E_set", value );

    /* (0x00000048 bits 27) field ILLEGAL_1STEP_INT_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    etime_reg_GP_INT_EN_REG_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_ILLEGAL_1STEP_INT_E_MSK,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_ILLEGAL_1STEP_INT_E_OFF,
                                       value);
}

static INLINE UINT32 etime_field_ILLEGAL_1STEP_INT_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_ILLEGAL_1STEP_INT_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000048 bits 27) field ILLEGAL_1STEP_INT_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    reg_value = etime_reg_GP_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_EN_REG_BIT_ILLEGAL_1STEP_INT_E_MSK) >> ETIME120_REG_GP_INT_EN_REG_BIT_ILLEGAL_1STEP_INT_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_ILLEGAL_1STEP_INT_E_get", value );

    return value;
}
static INLINE void etime_field_LINE_REF_CPTR_EVNT_E_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_LINE_REF_CPTR_EVNT_E_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_LINE_REF_CPTR_EVNT_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_LINE_REF_CPTR_EVNT_E_set", value );

    /* (0x00000048 bits 26) field LINE_REF_CPTR_EVNT_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    etime_reg_GP_INT_EN_REG_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_LINE_REF_CPTR_EVNT_E_MSK,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_LINE_REF_CPTR_EVNT_E_OFF,
                                       value);
}

static INLINE UINT32 etime_field_LINE_REF_CPTR_EVNT_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_LINE_REF_CPTR_EVNT_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000048 bits 26) field LINE_REF_CPTR_EVNT_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    reg_value = etime_reg_GP_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_EN_REG_BIT_LINE_REF_CPTR_EVNT_E_MSK) >> ETIME120_REG_GP_INT_EN_REG_BIT_LINE_REF_CPTR_EVNT_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_LINE_REF_CPTR_EVNT_E_get", value );

    return value;
}
static INLINE void etime_field_IRIGO_TS_CPTR_EVNT_E_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGO_TS_CPTR_EVNT_E_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGO_TS_CPTR_EVNT_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGO_TS_CPTR_EVNT_E_set", value );

    /* (0x00000048 bits 25) field IRIGO_TS_CPTR_EVNT_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    etime_reg_GP_INT_EN_REG_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_IRIGO_TS_CPTR_EVNT_E_MSK,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_IRIGO_TS_CPTR_EVNT_E_OFF,
                                       value);
}

static INLINE UINT32 etime_field_IRIGO_TS_CPTR_EVNT_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGO_TS_CPTR_EVNT_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000048 bits 25) field IRIGO_TS_CPTR_EVNT_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    reg_value = etime_reg_GP_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_EN_REG_BIT_IRIGO_TS_CPTR_EVNT_E_MSK) >> ETIME120_REG_GP_INT_EN_REG_BIT_IRIGO_TS_CPTR_EVNT_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGO_TS_CPTR_EVNT_E_get", value );

    return value;
}
static INLINE void etime_field_IRIGO_ONE_PPSO_REALIGN_E_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGO_ONE_PPSO_REALIGN_E_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGO_ONE_PPSO_REALIGN_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGO_ONE_PPSO_REALIGN_E_set", value );

    /* (0x00000048 bits 24) field IRIGO_ONE_PPSO_REALIGN_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    etime_reg_GP_INT_EN_REG_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_IRIGO_ONE_PPSO_REALIGN_E_MSK,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_IRIGO_ONE_PPSO_REALIGN_E_OFF,
                                       value);
}

static INLINE UINT32 etime_field_IRIGO_ONE_PPSO_REALIGN_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGO_ONE_PPSO_REALIGN_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000048 bits 24) field IRIGO_ONE_PPSO_REALIGN_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    reg_value = etime_reg_GP_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_EN_REG_BIT_IRIGO_ONE_PPSO_REALIGN_E_MSK) >> ETIME120_REG_GP_INT_EN_REG_BIT_IRIGO_ONE_PPSO_REALIGN_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGO_ONE_PPSO_REALIGN_E_get", value );

    return value;
}
static INLINE void etime_field_IRIGO_TX_DAT_VAL_E_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGO_TX_DAT_VAL_E_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGO_TX_DAT_VAL_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGO_TX_DAT_VAL_E_set", value );

    /* (0x00000048 bits 23) field IRIGO_TX_DAT_VAL_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    etime_reg_GP_INT_EN_REG_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_IRIGO_TX_DAT_VAL_E_MSK,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_IRIGO_TX_DAT_VAL_E_OFF,
                                       value);
}

static INLINE UINT32 etime_field_IRIGO_TX_DAT_VAL_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGO_TX_DAT_VAL_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000048 bits 23) field IRIGO_TX_DAT_VAL_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    reg_value = etime_reg_GP_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_EN_REG_BIT_IRIGO_TX_DAT_VAL_E_MSK) >> ETIME120_REG_GP_INT_EN_REG_BIT_IRIGO_TX_DAT_VAL_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGO_TX_DAT_VAL_E_get", value );

    return value;
}
static INLINE void etime_field_PTP_DCSU_TSTMPR_CPTR_EVNT_E_set( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_PTP_DCSU_TSTMPR_CPTR_EVNT_E_set( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_PTP_DCSU_TSTMPR_CPTR_EVNT_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_PTP_DCSU_TSTMPR_CPTR_EVNT_E_set", value );

    /* (0x00000048 bits 22) field PTP_DCSU_TSTMPR_CPTR_EVNT_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    etime_reg_GP_INT_EN_REG_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_PTP_DCSU_TSTMPR_CPTR_EVNT_E_MSK,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_PTP_DCSU_TSTMPR_CPTR_EVNT_E_OFF,
                                       value);
}

static INLINE UINT32 etime_field_PTP_DCSU_TSTMPR_CPTR_EVNT_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_PTP_DCSU_TSTMPR_CPTR_EVNT_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000048 bits 22) field PTP_DCSU_TSTMPR_CPTR_EVNT_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    reg_value = etime_reg_GP_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_EN_REG_BIT_PTP_DCSU_TSTMPR_CPTR_EVNT_E_MSK) >> ETIME120_REG_GP_INT_EN_REG_BIT_PTP_DCSU_TSTMPR_CPTR_EVNT_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_PTP_DCSU_TSTMPR_CPTR_EVNT_E_get", value );

    return value;
}
static INLINE void etime_field_IRIGI_TS_CPTR_EVNT_E_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGI_TS_CPTR_EVNT_E_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGI_TS_CPTR_EVNT_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGI_TS_CPTR_EVNT_E_set", value );

    /* (0x00000048 bits 21) field IRIGI_TS_CPTR_EVNT_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    etime_reg_GP_INT_EN_REG_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_IRIGI_TS_CPTR_EVNT_E_MSK,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_IRIGI_TS_CPTR_EVNT_E_OFF,
                                       value);
}

static INLINE UINT32 etime_field_IRIGI_TS_CPTR_EVNT_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_TS_CPTR_EVNT_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000048 bits 21) field IRIGI_TS_CPTR_EVNT_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    reg_value = etime_reg_GP_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_EN_REG_BIT_IRIGI_TS_CPTR_EVNT_E_MSK) >> ETIME120_REG_GP_INT_EN_REG_BIT_IRIGI_TS_CPTR_EVNT_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_TS_CPTR_EVNT_E_get", value );

    return value;
}
static INLINE void etime_field_IRIGI_RX_DAT_VAL_E_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGI_RX_DAT_VAL_E_set( etime_buffer_t *b_ptr,
                                                       etime_handle_t *h_ptr,
                                                       UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGI_RX_DAT_VAL_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGI_RX_DAT_VAL_E_set", value );

    /* (0x00000048 bits 20) field IRIGI_RX_DAT_VAL_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    etime_reg_GP_INT_EN_REG_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_IRIGI_RX_DAT_VAL_E_MSK,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_IRIGI_RX_DAT_VAL_E_OFF,
                                       value);
}

static INLINE UINT32 etime_field_IRIGI_RX_DAT_VAL_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_RX_DAT_VAL_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000048 bits 20) field IRIGI_RX_DAT_VAL_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    reg_value = etime_reg_GP_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_EN_REG_BIT_IRIGI_RX_DAT_VAL_E_MSK) >> ETIME120_REG_GP_INT_EN_REG_BIT_IRIGI_RX_DAT_VAL_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_RX_DAT_VAL_E_get", value );

    return value;
}
static INLINE void etime_field_IRIGI_REALIGN_E_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGI_REALIGN_E_set( etime_buffer_t *b_ptr,
                                                    etime_handle_t *h_ptr,
                                                    UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGI_REALIGN_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGI_REALIGN_E_set", value );

    /* (0x00000048 bits 19) field IRIGI_REALIGN_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    etime_reg_GP_INT_EN_REG_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_IRIGI_REALIGN_E_MSK,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_IRIGI_REALIGN_E_OFF,
                                       value);
}

static INLINE UINT32 etime_field_IRIGI_REALIGN_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_REALIGN_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000048 bits 19) field IRIGI_REALIGN_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    reg_value = etime_reg_GP_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_EN_REG_BIT_IRIGI_REALIGN_E_MSK) >> ETIME120_REG_GP_INT_EN_REG_BIT_IRIGI_REALIGN_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_REALIGN_E_get", value );

    return value;
}
static INLINE void etime_field_IRIGI_P0PR_MISSING_E_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGI_P0PR_MISSING_E_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGI_P0PR_MISSING_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGI_P0PR_MISSING_E_set", value );

    /* (0x00000048 bits 18) field IRIGI_P0PR_MISSING_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    etime_reg_GP_INT_EN_REG_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_IRIGI_P0PR_MISSING_E_MSK,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_IRIGI_P0PR_MISSING_E_OFF,
                                       value);
}

static INLINE UINT32 etime_field_IRIGI_P0PR_MISSING_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_P0PR_MISSING_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000048 bits 18) field IRIGI_P0PR_MISSING_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    reg_value = etime_reg_GP_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_EN_REG_BIT_IRIGI_P0PR_MISSING_E_MSK) >> ETIME120_REG_GP_INT_EN_REG_BIT_IRIGI_P0PR_MISSING_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_P0PR_MISSING_E_get", value );

    return value;
}
static INLINE void etime_field_IRIGI_IDLE_E_set( etime_buffer_t *b_ptr,
                                                 etime_handle_t *h_ptr,
                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGI_IDLE_E_set( etime_buffer_t *b_ptr,
                                                 etime_handle_t *h_ptr,
                                                 UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGI_IDLE_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGI_IDLE_E_set", value );

    /* (0x00000048 bits 17) field IRIGI_IDLE_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    etime_reg_GP_INT_EN_REG_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_IRIGI_IDLE_E_MSK,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_IRIGI_IDLE_E_OFF,
                                       value);
}

static INLINE UINT32 etime_field_IRIGI_IDLE_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_IDLE_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000048 bits 17) field IRIGI_IDLE_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    reg_value = etime_reg_GP_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_EN_REG_BIT_IRIGI_IDLE_E_MSK) >> ETIME120_REG_GP_INT_EN_REG_BIT_IRIGI_IDLE_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_IDLE_E_get", value );

    return value;
}
static INLINE void etime_field_IRIGI_ONE_PPSO_REALIGN_E_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGI_ONE_PPSO_REALIGN_E_set( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGI_ONE_PPSO_REALIGN_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGI_ONE_PPSO_REALIGN_E_set", value );

    /* (0x00000048 bits 16) field IRIGI_ONE_PPSO_REALIGN_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    etime_reg_GP_INT_EN_REG_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_IRIGI_ONE_PPSO_REALIGN_E_MSK,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_IRIGI_ONE_PPSO_REALIGN_E_OFF,
                                       value);
}

static INLINE UINT32 etime_field_IRIGI_ONE_PPSO_REALIGN_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_ONE_PPSO_REALIGN_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000048 bits 16) field IRIGI_ONE_PPSO_REALIGN_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    reg_value = etime_reg_GP_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_EN_REG_BIT_IRIGI_ONE_PPSO_REALIGN_E_MSK) >> ETIME120_REG_GP_INT_EN_REG_BIT_IRIGI_ONE_PPSO_REALIGN_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_ONE_PPSO_REALIGN_E_get", value );

    return value;
}
static INLINE void etime_field_IRIGI_PWM_DEC_ERR_E_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGI_PWM_DEC_ERR_E_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGI_PWM_DEC_ERR_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGI_PWM_DEC_ERR_E_set", value );

    /* (0x00000048 bits 15) field IRIGI_PWM_DEC_ERR_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    etime_reg_GP_INT_EN_REG_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_IRIGI_PWM_DEC_ERR_E_MSK,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_IRIGI_PWM_DEC_ERR_E_OFF,
                                       value);
}

static INLINE UINT32 etime_field_IRIGI_PWM_DEC_ERR_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_PWM_DEC_ERR_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000048 bits 15) field IRIGI_PWM_DEC_ERR_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    reg_value = etime_reg_GP_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_EN_REG_BIT_IRIGI_PWM_DEC_ERR_E_MSK) >> ETIME120_REG_GP_INT_EN_REG_BIT_IRIGI_PWM_DEC_ERR_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_PWM_DEC_ERR_E_get", value );

    return value;
}
static INLINE void etime_field_TOD_CFC_OFFS_TS_CNTR_UPDATED_E_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_CFC_OFFS_TS_CNTR_UPDATED_E_set( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_CFC_OFFS_TS_CNTR_UPDATED_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_CFC_OFFS_TS_CNTR_UPDATED_E_set", value );

    /* (0x00000048 bits 14) field TOD_CFC_OFFS_TS_CNTR_UPDATED_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    etime_reg_GP_INT_EN_REG_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_TOD_CFC_OFFS_TS_CNTR_UPDATED_E_MSK,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_TOD_CFC_OFFS_TS_CNTR_UPDATED_E_OFF,
                                       value);
}

static INLINE UINT32 etime_field_TOD_CFC_OFFS_TS_CNTR_UPDATED_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_CFC_OFFS_TS_CNTR_UPDATED_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000048 bits 14) field TOD_CFC_OFFS_TS_CNTR_UPDATED_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    reg_value = etime_reg_GP_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_EN_REG_BIT_TOD_CFC_OFFS_TS_CNTR_UPDATED_E_MSK) >> ETIME120_REG_GP_INT_EN_REG_BIT_TOD_CFC_OFFS_TS_CNTR_UPDATED_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_CFC_OFFS_TS_CNTR_UPDATED_E_get", value );

    return value;
}
static INLINE void etime_field_TS_INTERPOLATE_CNTR_ERR_E_set( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TS_INTERPOLATE_CNTR_ERR_E_set( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TS_INTERPOLATE_CNTR_ERR_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_TS_INTERPOLATE_CNTR_ERR_E_set", value );

    /* (0x00000048 bits 13) field TS_INTERPOLATE_CNTR_ERR_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    etime_reg_GP_INT_EN_REG_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_TS_INTERPOLATE_CNTR_ERR_E_MSK,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_TS_INTERPOLATE_CNTR_ERR_E_OFF,
                                       value);
}

static INLINE UINT32 etime_field_TS_INTERPOLATE_CNTR_ERR_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TS_INTERPOLATE_CNTR_ERR_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000048 bits 13) field TS_INTERPOLATE_CNTR_ERR_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    reg_value = etime_reg_GP_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_EN_REG_BIT_TS_INTERPOLATE_CNTR_ERR_E_MSK) >> ETIME120_REG_GP_INT_EN_REG_BIT_TS_INTERPOLATE_CNTR_ERR_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TS_INTERPOLATE_CNTR_ERR_E_get", value );

    return value;
}
static INLINE void etime_field_TS_TOD_SIGN_OVRFL_E_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TS_TOD_SIGN_OVRFL_E_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TS_TOD_SIGN_OVRFL_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_TS_TOD_SIGN_OVRFL_E_set", value );

    /* (0x00000048 bits 12) field TS_TOD_SIGN_OVRFL_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    etime_reg_GP_INT_EN_REG_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_TS_TOD_SIGN_OVRFL_E_MSK,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_TS_TOD_SIGN_OVRFL_E_OFF,
                                       value);
}

static INLINE UINT32 etime_field_TS_TOD_SIGN_OVRFL_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TS_TOD_SIGN_OVRFL_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000048 bits 12) field TS_TOD_SIGN_OVRFL_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    reg_value = etime_reg_GP_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_EN_REG_BIT_TS_TOD_SIGN_OVRFL_E_MSK) >> ETIME120_REG_GP_INT_EN_REG_BIT_TS_TOD_SIGN_OVRFL_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TS_TOD_SIGN_OVRFL_E_get", value );

    return value;
}
static INLINE void etime_field_CFC_OVRFL_E_set( etime_buffer_t *b_ptr,
                                                etime_handle_t *h_ptr,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CFC_OVRFL_E_set( etime_buffer_t *b_ptr,
                                                etime_handle_t *h_ptr,
                                                UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CFC_OVRFL_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_CFC_OVRFL_E_set", value );

    /* (0x00000048 bits 11) field CFC_OVRFL_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    etime_reg_GP_INT_EN_REG_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_CFC_OVRFL_E_MSK,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_CFC_OVRFL_E_OFF,
                                       value);
}

static INLINE UINT32 etime_field_CFC_OVRFL_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_OVRFL_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000048 bits 11) field CFC_OVRFL_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    reg_value = etime_reg_GP_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_EN_REG_BIT_CFC_OVRFL_E_MSK) >> ETIME120_REG_GP_INT_EN_REG_BIT_CFC_OVRFL_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_OVRFL_E_get", value );

    return value;
}
static INLINE void etime_field_TOD_TS_OVRFL_E_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_TS_OVRFL_E_set( etime_buffer_t *b_ptr,
                                                   etime_handle_t *h_ptr,
                                                   UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_TS_OVRFL_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_TS_OVRFL_E_set", value );

    /* (0x00000048 bits 10) field TOD_TS_OVRFL_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    etime_reg_GP_INT_EN_REG_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_TOD_TS_OVRFL_E_MSK,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_TOD_TS_OVRFL_E_OFF,
                                       value);
}

static INLINE UINT32 etime_field_TOD_TS_OVRFL_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_TS_OVRFL_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000048 bits 10) field TOD_TS_OVRFL_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    reg_value = etime_reg_GP_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_EN_REG_BIT_TOD_TS_OVRFL_E_MSK) >> ETIME120_REG_GP_INT_EN_REG_BIT_TOD_TS_OVRFL_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_TS_OVRFL_E_get", value );

    return value;
}
static INLINE void etime_field_FREE_RUN_CFC_OVRFL_E_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_FREE_RUN_CFC_OVRFL_E_set( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_FREE_RUN_CFC_OVRFL_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_FREE_RUN_CFC_OVRFL_E_set", value );

    /* (0x00000048 bits 9) field FREE_RUN_CFC_OVRFL_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    etime_reg_GP_INT_EN_REG_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_FREE_RUN_CFC_OVRFL_E_MSK,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_FREE_RUN_CFC_OVRFL_E_OFF,
                                       value);
}

static INLINE UINT32 etime_field_FREE_RUN_CFC_OVRFL_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_FREE_RUN_CFC_OVRFL_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000048 bits 9) field FREE_RUN_CFC_OVRFL_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    reg_value = etime_reg_GP_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_EN_REG_BIT_FREE_RUN_CFC_OVRFL_E_MSK) >> ETIME120_REG_GP_INT_EN_REG_BIT_FREE_RUN_CFC_OVRFL_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_FREE_RUN_CFC_OVRFL_E_get", value );

    return value;
}
static INLINE void etime_field_FREE_RUN_TS_OVRFL_E_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_FREE_RUN_TS_OVRFL_E_set( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_FREE_RUN_TS_OVRFL_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_FREE_RUN_TS_OVRFL_E_set", value );

    /* (0x00000048 bits 8) field FREE_RUN_TS_OVRFL_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    etime_reg_GP_INT_EN_REG_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_FREE_RUN_TS_OVRFL_E_MSK,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_FREE_RUN_TS_OVRFL_E_OFF,
                                       value);
}

static INLINE UINT32 etime_field_FREE_RUN_TS_OVRFL_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_FREE_RUN_TS_OVRFL_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000048 bits 8) field FREE_RUN_TS_OVRFL_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    reg_value = etime_reg_GP_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_EN_REG_BIT_FREE_RUN_TS_OVRFL_E_MSK) >> ETIME120_REG_GP_INT_EN_REG_BIT_FREE_RUN_TS_OVRFL_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_FREE_RUN_TS_OVRFL_E_get", value );

    return value;
}
static INLINE void etime_field_TOD_INT_1_E_set( etime_buffer_t *b_ptr,
                                                etime_handle_t *h_ptr,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_INT_1_E_set( etime_buffer_t *b_ptr,
                                                etime_handle_t *h_ptr,
                                                UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_INT_1_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_INT_1_E_set", value );

    /* (0x00000048 bits 7) field TOD_INT_1_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    etime_reg_GP_INT_EN_REG_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_TOD_INT_1_E_MSK,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_TOD_INT_1_E_OFF,
                                       value);
}

static INLINE UINT32 etime_field_TOD_INT_1_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_INT_1_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000048 bits 7) field TOD_INT_1_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    reg_value = etime_reg_GP_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_EN_REG_BIT_TOD_INT_1_E_MSK) >> ETIME120_REG_GP_INT_EN_REG_BIT_TOD_INT_1_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_INT_1_E_get", value );

    return value;
}
static INLINE void etime_field_TOD_INT_2_E_set( etime_buffer_t *b_ptr,
                                                etime_handle_t *h_ptr,
                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_INT_2_E_set( etime_buffer_t *b_ptr,
                                                etime_handle_t *h_ptr,
                                                UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_INT_2_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_INT_2_E_set", value );

    /* (0x00000048 bits 6) field TOD_INT_2_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    etime_reg_GP_INT_EN_REG_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_TOD_INT_2_E_MSK,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_TOD_INT_2_E_OFF,
                                       value);
}

static INLINE UINT32 etime_field_TOD_INT_2_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_INT_2_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000048 bits 6) field TOD_INT_2_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    reg_value = etime_reg_GP_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_EN_REG_BIT_TOD_INT_2_E_MSK) >> ETIME120_REG_GP_INT_EN_REG_BIT_TOD_INT_2_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_INT_2_E_get", value );

    return value;
}
static INLINE void etime_field_FREE_RUN_INT_1_E_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_FREE_RUN_INT_1_E_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_FREE_RUN_INT_1_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_FREE_RUN_INT_1_E_set", value );

    /* (0x00000048 bits 5) field FREE_RUN_INT_1_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    etime_reg_GP_INT_EN_REG_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_FREE_RUN_INT_1_E_MSK,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_FREE_RUN_INT_1_E_OFF,
                                       value);
}

static INLINE UINT32 etime_field_FREE_RUN_INT_1_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_FREE_RUN_INT_1_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000048 bits 5) field FREE_RUN_INT_1_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    reg_value = etime_reg_GP_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_EN_REG_BIT_FREE_RUN_INT_1_E_MSK) >> ETIME120_REG_GP_INT_EN_REG_BIT_FREE_RUN_INT_1_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_FREE_RUN_INT_1_E_get", value );

    return value;
}
static INLINE void etime_field_FREE_RUN_INT_2_E_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_FREE_RUN_INT_2_E_set( etime_buffer_t *b_ptr,
                                                     etime_handle_t *h_ptr,
                                                     UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_FREE_RUN_INT_2_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_FREE_RUN_INT_2_E_set", value );

    /* (0x00000048 bits 4) field FREE_RUN_INT_2_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    etime_reg_GP_INT_EN_REG_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_FREE_RUN_INT_2_E_MSK,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_FREE_RUN_INT_2_E_OFF,
                                       value);
}

static INLINE UINT32 etime_field_FREE_RUN_INT_2_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_FREE_RUN_INT_2_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000048 bits 4) field FREE_RUN_INT_2_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    reg_value = etime_reg_GP_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_EN_REG_BIT_FREE_RUN_INT_2_E_MSK) >> ETIME120_REG_GP_INT_EN_REG_BIT_FREE_RUN_INT_2_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_FREE_RUN_INT_2_E_get", value );

    return value;
}
static INLINE void etime_field_CC_INT_1_E_set( etime_buffer_t *b_ptr,
                                               etime_handle_t *h_ptr,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CC_INT_1_E_set( etime_buffer_t *b_ptr,
                                               etime_handle_t *h_ptr,
                                               UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CC_INT_1_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_CC_INT_1_E_set", value );

    /* (0x00000048 bits 3) field CC_INT_1_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    etime_reg_GP_INT_EN_REG_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_CC_INT_1_E_MSK,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_CC_INT_1_E_OFF,
                                       value);
}

static INLINE UINT32 etime_field_CC_INT_1_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CC_INT_1_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000048 bits 3) field CC_INT_1_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    reg_value = etime_reg_GP_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_EN_REG_BIT_CC_INT_1_E_MSK) >> ETIME120_REG_GP_INT_EN_REG_BIT_CC_INT_1_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CC_INT_1_E_get", value );

    return value;
}
static INLINE void etime_field_CC_INT_2_E_set( etime_buffer_t *b_ptr,
                                               etime_handle_t *h_ptr,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CC_INT_2_E_set( etime_buffer_t *b_ptr,
                                               etime_handle_t *h_ptr,
                                               UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CC_INT_2_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_CC_INT_2_E_set", value );

    /* (0x00000048 bits 2) field CC_INT_2_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    etime_reg_GP_INT_EN_REG_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_CC_INT_2_E_MSK,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_CC_INT_2_E_OFF,
                                       value);
}

static INLINE UINT32 etime_field_CC_INT_2_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CC_INT_2_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000048 bits 2) field CC_INT_2_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    reg_value = etime_reg_GP_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_EN_REG_BIT_CC_INT_2_E_MSK) >> ETIME120_REG_GP_INT_EN_REG_BIT_CC_INT_2_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CC_INT_2_E_get", value );

    return value;
}
static INLINE void etime_field_CC_INT_3_E_set( etime_buffer_t *b_ptr,
                                               etime_handle_t *h_ptr,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CC_INT_3_E_set( etime_buffer_t *b_ptr,
                                               etime_handle_t *h_ptr,
                                               UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CC_INT_3_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_CC_INT_3_E_set", value );

    /* (0x00000048 bits 1) field CC_INT_3_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    etime_reg_GP_INT_EN_REG_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_CC_INT_3_E_MSK,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_CC_INT_3_E_OFF,
                                       value);
}

static INLINE UINT32 etime_field_CC_INT_3_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CC_INT_3_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000048 bits 1) field CC_INT_3_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    reg_value = etime_reg_GP_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_EN_REG_BIT_CC_INT_3_E_MSK) >> ETIME120_REG_GP_INT_EN_REG_BIT_CC_INT_3_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CC_INT_3_E_get", value );

    return value;
}
static INLINE void etime_field_CC_INT_4_E_set( etime_buffer_t *b_ptr,
                                               etime_handle_t *h_ptr,
                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CC_INT_4_E_set( etime_buffer_t *b_ptr,
                                               etime_handle_t *h_ptr,
                                               UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CC_INT_4_E_set", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_CC_INT_4_E_set", value );

    /* (0x00000048 bits 0) field CC_INT_4_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    etime_reg_GP_INT_EN_REG_field_set( b_ptr,
                                       h_ptr,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_CC_INT_4_E_MSK,
                                       ETIME120_REG_GP_INT_EN_REG_BIT_CC_INT_4_E_OFF,
                                       value);
}

static INLINE UINT32 etime_field_CC_INT_4_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CC_INT_4_E_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000048 bits 0) field CC_INT_4_E of register PMC_ETIME120_REG_GP_INT_EN_REG */
    reg_value = etime_reg_GP_INT_EN_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_EN_REG_BIT_CC_INT_4_E_MSK) >> ETIME120_REG_GP_INT_EN_REG_BIT_CC_INT_4_E_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CC_INT_4_E_get", value );

    return value;
}

/*
 * ==================================================================================
 * Parameter Access Functions for Paramset int_sync
 * ==================================================================================
 */
static INLINE void etime_field_RAM_BIT_SB_ECC_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_RAM_BIT_SB_ECC_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 value )
{
    if (value > 131071)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_RAM_BIT_SB_ECC_INT_I_set_to_clear", value, 131071);
    IOLOG( "%s <= 0x%08x", "etime_field_RAM_BIT_SB_ECC_INT_I_set_to_clear", value );

    /* (0x0000000c bits 16:0) field RAM_BIT_SB_ECC_INT_I of register PMC_ETIME120_REG_SB_ECC_ERR_INT_REG */
    etime_reg_SB_ECC_ERR_INT_REG_action_on_write_field_set( b_ptr,
                                                            h_ptr,
                                                            ETIME120_REG_SB_ECC_ERR_INT_REG_BIT_RAM_BIT_SB_ECC_INT_I_MSK,
                                                            ETIME120_REG_SB_ECC_ERR_INT_REG_BIT_RAM_BIT_SB_ECC_INT_I_OFF,
                                                            value);
}

static INLINE UINT32 etime_field_RAM_BIT_SB_ECC_INT_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_RAM_BIT_SB_ECC_INT_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000000c bits 16:0) field RAM_BIT_SB_ECC_INT_I of register PMC_ETIME120_REG_SB_ECC_ERR_INT_REG */
    reg_value = etime_reg_SB_ECC_ERR_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_SB_ECC_ERR_INT_REG_BIT_RAM_BIT_SB_ECC_INT_I_MSK) >> ETIME120_REG_SB_ECC_ERR_INT_REG_BIT_RAM_BIT_SB_ECC_INT_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_RAM_BIT_SB_ECC_INT_I_get", value );

    return value;
}
static INLINE void etime_field_range_RAM_BIT_SB_ECC_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                        etime_handle_t *h_ptr,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit,
                                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_RAM_BIT_SB_ECC_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                        etime_handle_t *h_ptr,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit,
                                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_RAM_BIT_SB_ECC_INT_I_set_to_clear", stop_bit, start_bit );
    if (stop_bit > 16) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_RAM_BIT_SB_ECC_INT_I_set_to_clear", stop_bit, 16 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_RAM_BIT_SB_ECC_INT_I_set_to_clear", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000000c bits 16:0) field RAM_BIT_SB_ECC_INT_I of register PMC_ETIME120_REG_SB_ECC_ERR_INT_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 16) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 16;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000000c bits 16:0) field RAM_BIT_SB_ECC_INT_I of register PMC_ETIME120_REG_SB_ECC_ERR_INT_REG */
        etime_reg_SB_ECC_ERR_INT_REG_action_on_write_field_set( b_ptr,
                                                                h_ptr,
                                                                subfield_mask << (ETIME120_REG_SB_ECC_ERR_INT_REG_BIT_RAM_BIT_SB_ECC_INT_I_OFF + subfield_offset),
                                                                ETIME120_REG_SB_ECC_ERR_INT_REG_BIT_RAM_BIT_SB_ECC_INT_I_OFF + subfield_offset,
                                                                value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_RAM_BIT_SB_ECC_INT_I_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_RAM_BIT_SB_ECC_INT_I_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_RAM_BIT_SB_ECC_INT_I_get", stop_bit, start_bit );
    if (stop_bit > 16) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_RAM_BIT_SB_ECC_INT_I_get", stop_bit, 16 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 16) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 16;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000000c bits 16:0) field RAM_BIT_SB_ECC_INT_I of register PMC_ETIME120_REG_SB_ECC_ERR_INT_REG */
    reg_value = etime_reg_SB_ECC_ERR_INT_REG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_SB_ECC_ERR_INT_REG_BIT_RAM_BIT_SB_ECC_INT_I_MSK)
                  >> ETIME120_REG_SB_ECC_ERR_INT_REG_BIT_RAM_BIT_SB_ECC_INT_I_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_SB_ECC_ERR_INT_REG_BIT_RAM_BIT_SB_ECC_INT_I_MSK, ETIME120_REG_SB_ECC_ERR_INT_REG_BIT_RAM_BIT_SB_ECC_INT_I_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_RAM_BIT_SB_ECC_INT_I_get", start_bit, stop_bit, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_RAM_BIT_SB_ECC_INT_I_poll( etime_buffer_t *b_ptr,
                                                                                etime_handle_t *h_ptr,
                                                                                UINT32 start_bit,
                                                                                UINT32 stop_bit,
                                                                                UINT32 value,
                                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                                UINT32 max_count,
                                                                                UINT32 *num_failed_polls,
                                                                                UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_RAM_BIT_SB_ECC_INT_I_poll( etime_buffer_t *b_ptr,
                                                                                etime_handle_t *h_ptr,
                                                                                UINT32 start_bit,
                                                                                UINT32 stop_bit,
                                                                                UINT32 value,
                                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                                UINT32 max_count,
                                                                                UINT32 *num_failed_polls,
                                                                                UINT32 delay_between_polls_in_microseconds )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_RAM_BIT_SB_ECC_INT_I_poll", stop_bit, start_bit );
    if (stop_bit > 16) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_RAM_BIT_SB_ECC_INT_I_poll", stop_bit, 16 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_RAM_BIT_SB_ECC_INT_I_poll", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000000c bits 16:0) field RAM_BIT_SB_ECC_INT_I of register PMC_ETIME120_REG_SB_ECC_ERR_INT_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_start_bit = 0;
        }
        if (stop_bit < 16) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 16;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000000c bits 16:0) field RAM_BIT_SB_ECC_INT_I of register PMC_ETIME120_REG_SB_ECC_ERR_INT_REG */
        return etime_reg_SB_ECC_ERR_INT_REG_poll( b_ptr,
                                                  h_ptr,
                                                  subfield_mask << (ETIME120_REG_SB_ECC_ERR_INT_REG_BIT_RAM_BIT_SB_ECC_INT_I_OFF + subfield_offset),
                                                  value << (ETIME120_REG_SB_ECC_ERR_INT_REG_BIT_RAM_BIT_SB_ECC_INT_I_OFF + subfield_offset),
                                                  cmp,
                                                  max_count,
                                                  num_failed_polls,
                                                  delay_between_polls_in_microseconds);
    }
    return PMC_ERR_INVALID_PARAMETERS;
}

static INLINE PMC_POLL_RETURN_TYPE etime_field_RAM_BIT_SB_ECC_INT_I_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_RAM_BIT_SB_ECC_INT_I_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_RAM_BIT_SB_ECC_INT_I_poll", value );

    /* (0x0000000c bits 16:0) field RAM_BIT_SB_ECC_INT_I of register PMC_ETIME120_REG_SB_ECC_ERR_INT_REG */
    return etime_reg_SB_ECC_ERR_INT_REG_poll( b_ptr,
                                              h_ptr,
                                              ETIME120_REG_SB_ECC_ERR_INT_REG_BIT_RAM_BIT_SB_ECC_INT_I_MSK,
                                              (value<<ETIME120_REG_SB_ECC_ERR_INT_REG_BIT_RAM_BIT_SB_ECC_INT_I_OFF),
                                              cmp,
                                              max_count,
                                              num_failed_polls,
                                              delay_between_polls_in_microseconds);
}

static INLINE void etime_field_RAM_BIT_MB_ECC_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_RAM_BIT_MB_ECC_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 value )
{
    if (value > 131071)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_RAM_BIT_MB_ECC_INT_I_set_to_clear", value, 131071);
    IOLOG( "%s <= 0x%08x", "etime_field_RAM_BIT_MB_ECC_INT_I_set_to_clear", value );

    /* (0x00000010 bits 16:0) field RAM_BIT_MB_ECC_INT_I of register PMC_ETIME120_REG_MB_ECC_ERR_INT_REG */
    etime_reg_MB_ECC_ERR_INT_REG_action_on_write_field_set( b_ptr,
                                                            h_ptr,
                                                            ETIME120_REG_MB_ECC_ERR_INT_REG_BIT_RAM_BIT_MB_ECC_INT_I_MSK,
                                                            ETIME120_REG_MB_ECC_ERR_INT_REG_BIT_RAM_BIT_MB_ECC_INT_I_OFF,
                                                            value);
}

static INLINE UINT32 etime_field_RAM_BIT_MB_ECC_INT_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_RAM_BIT_MB_ECC_INT_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000010 bits 16:0) field RAM_BIT_MB_ECC_INT_I of register PMC_ETIME120_REG_MB_ECC_ERR_INT_REG */
    reg_value = etime_reg_MB_ECC_ERR_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_MB_ECC_ERR_INT_REG_BIT_RAM_BIT_MB_ECC_INT_I_MSK) >> ETIME120_REG_MB_ECC_ERR_INT_REG_BIT_RAM_BIT_MB_ECC_INT_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_RAM_BIT_MB_ECC_INT_I_get", value );

    return value;
}
static INLINE void etime_field_range_RAM_BIT_MB_ECC_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                        etime_handle_t *h_ptr,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit,
                                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_RAM_BIT_MB_ECC_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                        etime_handle_t *h_ptr,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit,
                                                                        UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_RAM_BIT_MB_ECC_INT_I_set_to_clear", stop_bit, start_bit );
    if (stop_bit > 16) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_RAM_BIT_MB_ECC_INT_I_set_to_clear", stop_bit, 16 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_RAM_BIT_MB_ECC_INT_I_set_to_clear", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000010 bits 16:0) field RAM_BIT_MB_ECC_INT_I of register PMC_ETIME120_REG_MB_ECC_ERR_INT_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 16) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 16;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000010 bits 16:0) field RAM_BIT_MB_ECC_INT_I of register PMC_ETIME120_REG_MB_ECC_ERR_INT_REG */
        etime_reg_MB_ECC_ERR_INT_REG_action_on_write_field_set( b_ptr,
                                                                h_ptr,
                                                                subfield_mask << (ETIME120_REG_MB_ECC_ERR_INT_REG_BIT_RAM_BIT_MB_ECC_INT_I_OFF + subfield_offset),
                                                                ETIME120_REG_MB_ECC_ERR_INT_REG_BIT_RAM_BIT_MB_ECC_INT_I_OFF + subfield_offset,
                                                                value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_RAM_BIT_MB_ECC_INT_I_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_RAM_BIT_MB_ECC_INT_I_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_RAM_BIT_MB_ECC_INT_I_get", stop_bit, start_bit );
    if (stop_bit > 16) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_RAM_BIT_MB_ECC_INT_I_get", stop_bit, 16 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 16) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 16;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000010 bits 16:0) field RAM_BIT_MB_ECC_INT_I of register PMC_ETIME120_REG_MB_ECC_ERR_INT_REG */
    reg_value = etime_reg_MB_ECC_ERR_INT_REG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_MB_ECC_ERR_INT_REG_BIT_RAM_BIT_MB_ECC_INT_I_MSK)
                  >> ETIME120_REG_MB_ECC_ERR_INT_REG_BIT_RAM_BIT_MB_ECC_INT_I_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_MB_ECC_ERR_INT_REG_BIT_RAM_BIT_MB_ECC_INT_I_MSK, ETIME120_REG_MB_ECC_ERR_INT_REG_BIT_RAM_BIT_MB_ECC_INT_I_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_RAM_BIT_MB_ECC_INT_I_get", start_bit, stop_bit, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_RAM_BIT_MB_ECC_INT_I_poll( etime_buffer_t *b_ptr,
                                                                                etime_handle_t *h_ptr,
                                                                                UINT32 start_bit,
                                                                                UINT32 stop_bit,
                                                                                UINT32 value,
                                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                                UINT32 max_count,
                                                                                UINT32 *num_failed_polls,
                                                                                UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_RAM_BIT_MB_ECC_INT_I_poll( etime_buffer_t *b_ptr,
                                                                                etime_handle_t *h_ptr,
                                                                                UINT32 start_bit,
                                                                                UINT32 stop_bit,
                                                                                UINT32 value,
                                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                                UINT32 max_count,
                                                                                UINT32 *num_failed_polls,
                                                                                UINT32 delay_between_polls_in_microseconds )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_RAM_BIT_MB_ECC_INT_I_poll", stop_bit, start_bit );
    if (stop_bit > 16) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_RAM_BIT_MB_ECC_INT_I_poll", stop_bit, 16 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_RAM_BIT_MB_ECC_INT_I_poll", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000010 bits 16:0) field RAM_BIT_MB_ECC_INT_I of register PMC_ETIME120_REG_MB_ECC_ERR_INT_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_start_bit = 0;
        }
        if (stop_bit < 16) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 16;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000010 bits 16:0) field RAM_BIT_MB_ECC_INT_I of register PMC_ETIME120_REG_MB_ECC_ERR_INT_REG */
        return etime_reg_MB_ECC_ERR_INT_REG_poll( b_ptr,
                                                  h_ptr,
                                                  subfield_mask << (ETIME120_REG_MB_ECC_ERR_INT_REG_BIT_RAM_BIT_MB_ECC_INT_I_OFF + subfield_offset),
                                                  value << (ETIME120_REG_MB_ECC_ERR_INT_REG_BIT_RAM_BIT_MB_ECC_INT_I_OFF + subfield_offset),
                                                  cmp,
                                                  max_count,
                                                  num_failed_polls,
                                                  delay_between_polls_in_microseconds);
    }
    return PMC_ERR_INVALID_PARAMETERS;
}

static INLINE PMC_POLL_RETURN_TYPE etime_field_RAM_BIT_MB_ECC_INT_I_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_RAM_BIT_MB_ECC_INT_I_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_RAM_BIT_MB_ECC_INT_I_poll", value );

    /* (0x00000010 bits 16:0) field RAM_BIT_MB_ECC_INT_I of register PMC_ETIME120_REG_MB_ECC_ERR_INT_REG */
    return etime_reg_MB_ECC_ERR_INT_REG_poll( b_ptr,
                                              h_ptr,
                                              ETIME120_REG_MB_ECC_ERR_INT_REG_BIT_RAM_BIT_MB_ECC_INT_I_MSK,
                                              (value<<ETIME120_REG_MB_ECC_ERR_INT_REG_BIT_RAM_BIT_MB_ECC_INT_I_OFF),
                                              cmp,
                                              max_count,
                                              num_failed_polls,
                                              delay_between_polls_in_microseconds);
}

static INLINE void etime_field_EXT_RAM_OFLOW_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EXT_RAM_OFLOW_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 value )
{
    if (value > 4095)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EXT_RAM_OFLOW_INT_I_set_to_clear", value, 4095);
    IOLOG( "%s <= 0x%08x", "etime_field_EXT_RAM_OFLOW_INT_I_set_to_clear", value );

    /* (0x00000014 bits 11:0) field EXT_RAM_OFLOW_INT_I of register PMC_ETIME120_REG_REFL_OFLOW_ERR_INT_REG */
    etime_reg_REFL_OFLOW_ERR_INT_REG_action_on_write_field_set( b_ptr,
                                                                h_ptr,
                                                                ETIME120_REG_REFL_OFLOW_ERR_INT_REG_BIT_EXT_RAM_OFLOW_INT_I_MSK,
                                                                ETIME120_REG_REFL_OFLOW_ERR_INT_REG_BIT_EXT_RAM_OFLOW_INT_I_OFF,
                                                                value);
}

static INLINE UINT32 etime_field_EXT_RAM_OFLOW_INT_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EXT_RAM_OFLOW_INT_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000014 bits 11:0) field EXT_RAM_OFLOW_INT_I of register PMC_ETIME120_REG_REFL_OFLOW_ERR_INT_REG */
    reg_value = etime_reg_REFL_OFLOW_ERR_INT_REG_read( b_ptr,
                                                       h_ptr);
    value = (reg_value & ETIME120_REG_REFL_OFLOW_ERR_INT_REG_BIT_EXT_RAM_OFLOW_INT_I_MSK) >> ETIME120_REG_REFL_OFLOW_ERR_INT_REG_BIT_EXT_RAM_OFLOW_INT_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EXT_RAM_OFLOW_INT_I_get", value );

    return value;
}
static INLINE void etime_field_range_EXT_RAM_OFLOW_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                       etime_handle_t *h_ptr,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit,
                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_EXT_RAM_OFLOW_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                       etime_handle_t *h_ptr,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit,
                                                                       UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_RAM_OFLOW_INT_I_set_to_clear", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_RAM_OFLOW_INT_I_set_to_clear", stop_bit, 11 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_RAM_OFLOW_INT_I_set_to_clear", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000014 bits 11:0) field EXT_RAM_OFLOW_INT_I of register PMC_ETIME120_REG_REFL_OFLOW_ERR_INT_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000014 bits 11:0) field EXT_RAM_OFLOW_INT_I of register PMC_ETIME120_REG_REFL_OFLOW_ERR_INT_REG */
        etime_reg_REFL_OFLOW_ERR_INT_REG_action_on_write_field_set( b_ptr,
                                                                    h_ptr,
                                                                    subfield_mask << (ETIME120_REG_REFL_OFLOW_ERR_INT_REG_BIT_EXT_RAM_OFLOW_INT_I_OFF + subfield_offset),
                                                                    ETIME120_REG_REFL_OFLOW_ERR_INT_REG_BIT_EXT_RAM_OFLOW_INT_I_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_EXT_RAM_OFLOW_INT_I_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_EXT_RAM_OFLOW_INT_I_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_RAM_OFLOW_INT_I_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_RAM_OFLOW_INT_I_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000014 bits 11:0) field EXT_RAM_OFLOW_INT_I of register PMC_ETIME120_REG_REFL_OFLOW_ERR_INT_REG */
    reg_value = etime_reg_REFL_OFLOW_ERR_INT_REG_read( b_ptr,
                                                       h_ptr);
    field_value = (reg_value & ETIME120_REG_REFL_OFLOW_ERR_INT_REG_BIT_EXT_RAM_OFLOW_INT_I_MSK)
                  >> ETIME120_REG_REFL_OFLOW_ERR_INT_REG_BIT_EXT_RAM_OFLOW_INT_I_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_REFL_OFLOW_ERR_INT_REG_BIT_EXT_RAM_OFLOW_INT_I_MSK, ETIME120_REG_REFL_OFLOW_ERR_INT_REG_BIT_EXT_RAM_OFLOW_INT_I_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_RAM_OFLOW_INT_I_get", start_bit, stop_bit, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_EXT_RAM_OFLOW_INT_I_poll( etime_buffer_t *b_ptr,
                                                                               etime_handle_t *h_ptr,
                                                                               UINT32 start_bit,
                                                                               UINT32 stop_bit,
                                                                               UINT32 value,
                                                                               PMC_POLL_COMPARISON_TYPE cmp,
                                                                               UINT32 max_count,
                                                                               UINT32 *num_failed_polls,
                                                                               UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_EXT_RAM_OFLOW_INT_I_poll( etime_buffer_t *b_ptr,
                                                                               etime_handle_t *h_ptr,
                                                                               UINT32 start_bit,
                                                                               UINT32 stop_bit,
                                                                               UINT32 value,
                                                                               PMC_POLL_COMPARISON_TYPE cmp,
                                                                               UINT32 max_count,
                                                                               UINT32 *num_failed_polls,
                                                                               UINT32 delay_between_polls_in_microseconds )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_RAM_OFLOW_INT_I_poll", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_RAM_OFLOW_INT_I_poll", stop_bit, 11 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_RAM_OFLOW_INT_I_poll", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000014 bits 11:0) field EXT_RAM_OFLOW_INT_I of register PMC_ETIME120_REG_REFL_OFLOW_ERR_INT_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000014 bits 11:0) field EXT_RAM_OFLOW_INT_I of register PMC_ETIME120_REG_REFL_OFLOW_ERR_INT_REG */
        return etime_reg_REFL_OFLOW_ERR_INT_REG_poll( b_ptr,
                                                      h_ptr,
                                                      subfield_mask << (ETIME120_REG_REFL_OFLOW_ERR_INT_REG_BIT_EXT_RAM_OFLOW_INT_I_OFF + subfield_offset),
                                                      value << (ETIME120_REG_REFL_OFLOW_ERR_INT_REG_BIT_EXT_RAM_OFLOW_INT_I_OFF + subfield_offset),
                                                      cmp,
                                                      max_count,
                                                      num_failed_polls,
                                                      delay_between_polls_in_microseconds);
    }
    return PMC_ERR_INVALID_PARAMETERS;
}

static INLINE PMC_POLL_RETURN_TYPE etime_field_EXT_RAM_OFLOW_INT_I_poll( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_EXT_RAM_OFLOW_INT_I_poll( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_EXT_RAM_OFLOW_INT_I_poll", value );

    /* (0x00000014 bits 11:0) field EXT_RAM_OFLOW_INT_I of register PMC_ETIME120_REG_REFL_OFLOW_ERR_INT_REG */
    return etime_reg_REFL_OFLOW_ERR_INT_REG_poll( b_ptr,
                                                  h_ptr,
                                                  ETIME120_REG_REFL_OFLOW_ERR_INT_REG_BIT_EXT_RAM_OFLOW_INT_I_MSK,
                                                  (value<<ETIME120_REG_REFL_OFLOW_ERR_INT_REG_BIT_EXT_RAM_OFLOW_INT_I_OFF),
                                                  cmp,
                                                  max_count,
                                                  num_failed_polls,
                                                  delay_between_polls_in_microseconds);
}

static INLINE void etime_field_TS_RAM_WR_DIS_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TS_RAM_WR_DIS_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 value )
{
    if (value > 4095)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TS_RAM_WR_DIS_INT_I_set_to_clear", value, 4095);
    IOLOG( "%s <= 0x%08x", "etime_field_TS_RAM_WR_DIS_INT_I_set_to_clear", value );

    /* (0x00000018 bits 23:12) field TS_RAM_WR_DIS_INT_I of register PMC_ETIME120_REG_TS_DIS_INT_REG */
    etime_reg_TS_DIS_INT_REG_action_on_write_field_set( b_ptr,
                                                        h_ptr,
                                                        ETIME120_REG_TS_DIS_INT_REG_BIT_TS_RAM_WR_DIS_INT_I_MSK,
                                                        ETIME120_REG_TS_DIS_INT_REG_BIT_TS_RAM_WR_DIS_INT_I_OFF,
                                                        value);
}

static INLINE UINT32 etime_field_TS_RAM_WR_DIS_INT_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TS_RAM_WR_DIS_INT_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000018 bits 23:12) field TS_RAM_WR_DIS_INT_I of register PMC_ETIME120_REG_TS_DIS_INT_REG */
    reg_value = etime_reg_TS_DIS_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TS_DIS_INT_REG_BIT_TS_RAM_WR_DIS_INT_I_MSK) >> ETIME120_REG_TS_DIS_INT_REG_BIT_TS_RAM_WR_DIS_INT_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TS_RAM_WR_DIS_INT_I_get", value );

    return value;
}
static INLINE void etime_field_range_TS_RAM_WR_DIS_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                       etime_handle_t *h_ptr,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit,
                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TS_RAM_WR_DIS_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                       etime_handle_t *h_ptr,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit,
                                                                       UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TS_RAM_WR_DIS_INT_I_set_to_clear", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TS_RAM_WR_DIS_INT_I_set_to_clear", stop_bit, 11 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TS_RAM_WR_DIS_INT_I_set_to_clear", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000018 bits 23:12) field TS_RAM_WR_DIS_INT_I of register PMC_ETIME120_REG_TS_DIS_INT_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000018 bits 23:12) field TS_RAM_WR_DIS_INT_I of register PMC_ETIME120_REG_TS_DIS_INT_REG */
        etime_reg_TS_DIS_INT_REG_action_on_write_field_set( b_ptr,
                                                            h_ptr,
                                                            subfield_mask << (ETIME120_REG_TS_DIS_INT_REG_BIT_TS_RAM_WR_DIS_INT_I_OFF + subfield_offset),
                                                            ETIME120_REG_TS_DIS_INT_REG_BIT_TS_RAM_WR_DIS_INT_I_OFF + subfield_offset,
                                                            value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TS_RAM_WR_DIS_INT_I_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TS_RAM_WR_DIS_INT_I_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TS_RAM_WR_DIS_INT_I_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TS_RAM_WR_DIS_INT_I_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000018 bits 23:12) field TS_RAM_WR_DIS_INT_I of register PMC_ETIME120_REG_TS_DIS_INT_REG */
    reg_value = etime_reg_TS_DIS_INT_REG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TS_DIS_INT_REG_BIT_TS_RAM_WR_DIS_INT_I_MSK)
                  >> ETIME120_REG_TS_DIS_INT_REG_BIT_TS_RAM_WR_DIS_INT_I_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TS_DIS_INT_REG_BIT_TS_RAM_WR_DIS_INT_I_MSK, ETIME120_REG_TS_DIS_INT_REG_BIT_TS_RAM_WR_DIS_INT_I_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TS_RAM_WR_DIS_INT_I_get", start_bit, stop_bit, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_TS_RAM_WR_DIS_INT_I_poll( etime_buffer_t *b_ptr,
                                                                               etime_handle_t *h_ptr,
                                                                               UINT32 start_bit,
                                                                               UINT32 stop_bit,
                                                                               UINT32 value,
                                                                               PMC_POLL_COMPARISON_TYPE cmp,
                                                                               UINT32 max_count,
                                                                               UINT32 *num_failed_polls,
                                                                               UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_TS_RAM_WR_DIS_INT_I_poll( etime_buffer_t *b_ptr,
                                                                               etime_handle_t *h_ptr,
                                                                               UINT32 start_bit,
                                                                               UINT32 stop_bit,
                                                                               UINT32 value,
                                                                               PMC_POLL_COMPARISON_TYPE cmp,
                                                                               UINT32 max_count,
                                                                               UINT32 *num_failed_polls,
                                                                               UINT32 delay_between_polls_in_microseconds )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TS_RAM_WR_DIS_INT_I_poll", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TS_RAM_WR_DIS_INT_I_poll", stop_bit, 11 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TS_RAM_WR_DIS_INT_I_poll", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000018 bits 23:12) field TS_RAM_WR_DIS_INT_I of register PMC_ETIME120_REG_TS_DIS_INT_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000018 bits 23:12) field TS_RAM_WR_DIS_INT_I of register PMC_ETIME120_REG_TS_DIS_INT_REG */
        return etime_reg_TS_DIS_INT_REG_poll( b_ptr,
                                              h_ptr,
                                              subfield_mask << (ETIME120_REG_TS_DIS_INT_REG_BIT_TS_RAM_WR_DIS_INT_I_OFF + subfield_offset),
                                              value << (ETIME120_REG_TS_DIS_INT_REG_BIT_TS_RAM_WR_DIS_INT_I_OFF + subfield_offset),
                                              cmp,
                                              max_count,
                                              num_failed_polls,
                                              delay_between_polls_in_microseconds);
    }
    return PMC_ERR_INVALID_PARAMETERS;
}

static INLINE PMC_POLL_RETURN_TYPE etime_field_TS_RAM_WR_DIS_INT_I_poll( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_TS_RAM_WR_DIS_INT_I_poll( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_TS_RAM_WR_DIS_INT_I_poll", value );

    /* (0x00000018 bits 23:12) field TS_RAM_WR_DIS_INT_I of register PMC_ETIME120_REG_TS_DIS_INT_REG */
    return etime_reg_TS_DIS_INT_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_TS_DIS_INT_REG_BIT_TS_RAM_WR_DIS_INT_I_MSK,
                                          (value<<ETIME120_REG_TS_DIS_INT_REG_BIT_TS_RAM_WR_DIS_INT_I_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}

static INLINE void etime_field_TS_RAM_RD_DIS_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TS_RAM_RD_DIS_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 value )
{
    if (value > 4095)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TS_RAM_RD_DIS_INT_I_set_to_clear", value, 4095);
    IOLOG( "%s <= 0x%08x", "etime_field_TS_RAM_RD_DIS_INT_I_set_to_clear", value );

    /* (0x00000018 bits 11:0) field TS_RAM_RD_DIS_INT_I of register PMC_ETIME120_REG_TS_DIS_INT_REG */
    etime_reg_TS_DIS_INT_REG_action_on_write_field_set( b_ptr,
                                                        h_ptr,
                                                        ETIME120_REG_TS_DIS_INT_REG_BIT_TS_RAM_RD_DIS_INT_I_MSK,
                                                        ETIME120_REG_TS_DIS_INT_REG_BIT_TS_RAM_RD_DIS_INT_I_OFF,
                                                        value);
}

static INLINE UINT32 etime_field_TS_RAM_RD_DIS_INT_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TS_RAM_RD_DIS_INT_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000018 bits 11:0) field TS_RAM_RD_DIS_INT_I of register PMC_ETIME120_REG_TS_DIS_INT_REG */
    reg_value = etime_reg_TS_DIS_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TS_DIS_INT_REG_BIT_TS_RAM_RD_DIS_INT_I_MSK) >> ETIME120_REG_TS_DIS_INT_REG_BIT_TS_RAM_RD_DIS_INT_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TS_RAM_RD_DIS_INT_I_get", value );

    return value;
}
static INLINE void etime_field_range_TS_RAM_RD_DIS_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                       etime_handle_t *h_ptr,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit,
                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_TS_RAM_RD_DIS_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                       etime_handle_t *h_ptr,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit,
                                                                       UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TS_RAM_RD_DIS_INT_I_set_to_clear", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TS_RAM_RD_DIS_INT_I_set_to_clear", stop_bit, 11 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TS_RAM_RD_DIS_INT_I_set_to_clear", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000018 bits 11:0) field TS_RAM_RD_DIS_INT_I of register PMC_ETIME120_REG_TS_DIS_INT_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000018 bits 11:0) field TS_RAM_RD_DIS_INT_I of register PMC_ETIME120_REG_TS_DIS_INT_REG */
        etime_reg_TS_DIS_INT_REG_action_on_write_field_set( b_ptr,
                                                            h_ptr,
                                                            subfield_mask << (ETIME120_REG_TS_DIS_INT_REG_BIT_TS_RAM_RD_DIS_INT_I_OFF + subfield_offset),
                                                            ETIME120_REG_TS_DIS_INT_REG_BIT_TS_RAM_RD_DIS_INT_I_OFF + subfield_offset,
                                                            value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_TS_RAM_RD_DIS_INT_I_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TS_RAM_RD_DIS_INT_I_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TS_RAM_RD_DIS_INT_I_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TS_RAM_RD_DIS_INT_I_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000018 bits 11:0) field TS_RAM_RD_DIS_INT_I of register PMC_ETIME120_REG_TS_DIS_INT_REG */
    reg_value = etime_reg_TS_DIS_INT_REG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TS_DIS_INT_REG_BIT_TS_RAM_RD_DIS_INT_I_MSK)
                  >> ETIME120_REG_TS_DIS_INT_REG_BIT_TS_RAM_RD_DIS_INT_I_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TS_DIS_INT_REG_BIT_TS_RAM_RD_DIS_INT_I_MSK, ETIME120_REG_TS_DIS_INT_REG_BIT_TS_RAM_RD_DIS_INT_I_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TS_RAM_RD_DIS_INT_I_get", start_bit, stop_bit, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_TS_RAM_RD_DIS_INT_I_poll( etime_buffer_t *b_ptr,
                                                                               etime_handle_t *h_ptr,
                                                                               UINT32 start_bit,
                                                                               UINT32 stop_bit,
                                                                               UINT32 value,
                                                                               PMC_POLL_COMPARISON_TYPE cmp,
                                                                               UINT32 max_count,
                                                                               UINT32 *num_failed_polls,
                                                                               UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_TS_RAM_RD_DIS_INT_I_poll( etime_buffer_t *b_ptr,
                                                                               etime_handle_t *h_ptr,
                                                                               UINT32 start_bit,
                                                                               UINT32 stop_bit,
                                                                               UINT32 value,
                                                                               PMC_POLL_COMPARISON_TYPE cmp,
                                                                               UINT32 max_count,
                                                                               UINT32 *num_failed_polls,
                                                                               UINT32 delay_between_polls_in_microseconds )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TS_RAM_RD_DIS_INT_I_poll", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TS_RAM_RD_DIS_INT_I_poll", stop_bit, 11 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TS_RAM_RD_DIS_INT_I_poll", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000018 bits 11:0) field TS_RAM_RD_DIS_INT_I of register PMC_ETIME120_REG_TS_DIS_INT_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000018 bits 11:0) field TS_RAM_RD_DIS_INT_I of register PMC_ETIME120_REG_TS_DIS_INT_REG */
        return etime_reg_TS_DIS_INT_REG_poll( b_ptr,
                                              h_ptr,
                                              subfield_mask << (ETIME120_REG_TS_DIS_INT_REG_BIT_TS_RAM_RD_DIS_INT_I_OFF + subfield_offset),
                                              value << (ETIME120_REG_TS_DIS_INT_REG_BIT_TS_RAM_RD_DIS_INT_I_OFF + subfield_offset),
                                              cmp,
                                              max_count,
                                              num_failed_polls,
                                              delay_between_polls_in_microseconds);
    }
    return PMC_ERR_INVALID_PARAMETERS;
}

static INLINE PMC_POLL_RETURN_TYPE etime_field_TS_RAM_RD_DIS_INT_I_poll( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_TS_RAM_RD_DIS_INT_I_poll( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_TS_RAM_RD_DIS_INT_I_poll", value );

    /* (0x00000018 bits 11:0) field TS_RAM_RD_DIS_INT_I of register PMC_ETIME120_REG_TS_DIS_INT_REG */
    return etime_reg_TS_DIS_INT_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_TS_DIS_INT_REG_BIT_TS_RAM_RD_DIS_INT_I_MSK,
                                          (value<<ETIME120_REG_TS_DIS_INT_REG_BIT_TS_RAM_RD_DIS_INT_I_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}

static INLINE void etime_field_PACKET_RAM_WR_DIS_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_PACKET_RAM_WR_DIS_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 value )
{
    if (value > 4095)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_PACKET_RAM_WR_DIS_INT_I_set_to_clear", value, 4095);
    IOLOG( "%s <= 0x%08x", "etime_field_PACKET_RAM_WR_DIS_INT_I_set_to_clear", value );

    /* (0x0000001c bits 23:12) field PACKET_RAM_WR_DIS_INT_I of register PMC_ETIME120_REG_PACKET_DIS_INT_REG */
    etime_reg_PACKET_DIS_INT_REG_action_on_write_field_set( b_ptr,
                                                            h_ptr,
                                                            ETIME120_REG_PACKET_DIS_INT_REG_BIT_PACKET_RAM_WR_DIS_INT_I_MSK,
                                                            ETIME120_REG_PACKET_DIS_INT_REG_BIT_PACKET_RAM_WR_DIS_INT_I_OFF,
                                                            value);
}

static INLINE UINT32 etime_field_PACKET_RAM_WR_DIS_INT_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_PACKET_RAM_WR_DIS_INT_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000001c bits 23:12) field PACKET_RAM_WR_DIS_INT_I of register PMC_ETIME120_REG_PACKET_DIS_INT_REG */
    reg_value = etime_reg_PACKET_DIS_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_PACKET_DIS_INT_REG_BIT_PACKET_RAM_WR_DIS_INT_I_MSK) >> ETIME120_REG_PACKET_DIS_INT_REG_BIT_PACKET_RAM_WR_DIS_INT_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_PACKET_RAM_WR_DIS_INT_I_get", value );

    return value;
}
static INLINE void etime_field_range_PACKET_RAM_WR_DIS_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                           etime_handle_t *h_ptr,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit,
                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_PACKET_RAM_WR_DIS_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                           etime_handle_t *h_ptr,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit,
                                                                           UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_PACKET_RAM_WR_DIS_INT_I_set_to_clear", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_PACKET_RAM_WR_DIS_INT_I_set_to_clear", stop_bit, 11 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_PACKET_RAM_WR_DIS_INT_I_set_to_clear", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000001c bits 23:12) field PACKET_RAM_WR_DIS_INT_I of register PMC_ETIME120_REG_PACKET_DIS_INT_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000001c bits 23:12) field PACKET_RAM_WR_DIS_INT_I of register PMC_ETIME120_REG_PACKET_DIS_INT_REG */
        etime_reg_PACKET_DIS_INT_REG_action_on_write_field_set( b_ptr,
                                                                h_ptr,
                                                                subfield_mask << (ETIME120_REG_PACKET_DIS_INT_REG_BIT_PACKET_RAM_WR_DIS_INT_I_OFF + subfield_offset),
                                                                ETIME120_REG_PACKET_DIS_INT_REG_BIT_PACKET_RAM_WR_DIS_INT_I_OFF + subfield_offset,
                                                                value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_PACKET_RAM_WR_DIS_INT_I_get( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_PACKET_RAM_WR_DIS_INT_I_get( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_PACKET_RAM_WR_DIS_INT_I_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_PACKET_RAM_WR_DIS_INT_I_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000001c bits 23:12) field PACKET_RAM_WR_DIS_INT_I of register PMC_ETIME120_REG_PACKET_DIS_INT_REG */
    reg_value = etime_reg_PACKET_DIS_INT_REG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_PACKET_DIS_INT_REG_BIT_PACKET_RAM_WR_DIS_INT_I_MSK)
                  >> ETIME120_REG_PACKET_DIS_INT_REG_BIT_PACKET_RAM_WR_DIS_INT_I_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_PACKET_DIS_INT_REG_BIT_PACKET_RAM_WR_DIS_INT_I_MSK, ETIME120_REG_PACKET_DIS_INT_REG_BIT_PACKET_RAM_WR_DIS_INT_I_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_PACKET_RAM_WR_DIS_INT_I_get", start_bit, stop_bit, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_PACKET_RAM_WR_DIS_INT_I_poll( etime_buffer_t *b_ptr,
                                                                                   etime_handle_t *h_ptr,
                                                                                   UINT32 start_bit,
                                                                                   UINT32 stop_bit,
                                                                                   UINT32 value,
                                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                                   UINT32 max_count,
                                                                                   UINT32 *num_failed_polls,
                                                                                   UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_PACKET_RAM_WR_DIS_INT_I_poll( etime_buffer_t *b_ptr,
                                                                                   etime_handle_t *h_ptr,
                                                                                   UINT32 start_bit,
                                                                                   UINT32 stop_bit,
                                                                                   UINT32 value,
                                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                                   UINT32 max_count,
                                                                                   UINT32 *num_failed_polls,
                                                                                   UINT32 delay_between_polls_in_microseconds )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_PACKET_RAM_WR_DIS_INT_I_poll", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_PACKET_RAM_WR_DIS_INT_I_poll", stop_bit, 11 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_PACKET_RAM_WR_DIS_INT_I_poll", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000001c bits 23:12) field PACKET_RAM_WR_DIS_INT_I of register PMC_ETIME120_REG_PACKET_DIS_INT_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000001c bits 23:12) field PACKET_RAM_WR_DIS_INT_I of register PMC_ETIME120_REG_PACKET_DIS_INT_REG */
        return etime_reg_PACKET_DIS_INT_REG_poll( b_ptr,
                                                  h_ptr,
                                                  subfield_mask << (ETIME120_REG_PACKET_DIS_INT_REG_BIT_PACKET_RAM_WR_DIS_INT_I_OFF + subfield_offset),
                                                  value << (ETIME120_REG_PACKET_DIS_INT_REG_BIT_PACKET_RAM_WR_DIS_INT_I_OFF + subfield_offset),
                                                  cmp,
                                                  max_count,
                                                  num_failed_polls,
                                                  delay_between_polls_in_microseconds);
    }
    return PMC_ERR_INVALID_PARAMETERS;
}

static INLINE PMC_POLL_RETURN_TYPE etime_field_PACKET_RAM_WR_DIS_INT_I_poll( etime_buffer_t *b_ptr,
                                                                             etime_handle_t *h_ptr,
                                                                             UINT32 value,
                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                             UINT32 max_count,
                                                                             UINT32 *num_failed_polls,
                                                                             UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_PACKET_RAM_WR_DIS_INT_I_poll( etime_buffer_t *b_ptr,
                                                                             etime_handle_t *h_ptr,
                                                                             UINT32 value,
                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                             UINT32 max_count,
                                                                             UINT32 *num_failed_polls,
                                                                             UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_PACKET_RAM_WR_DIS_INT_I_poll", value );

    /* (0x0000001c bits 23:12) field PACKET_RAM_WR_DIS_INT_I of register PMC_ETIME120_REG_PACKET_DIS_INT_REG */
    return etime_reg_PACKET_DIS_INT_REG_poll( b_ptr,
                                              h_ptr,
                                              ETIME120_REG_PACKET_DIS_INT_REG_BIT_PACKET_RAM_WR_DIS_INT_I_MSK,
                                              (value<<ETIME120_REG_PACKET_DIS_INT_REG_BIT_PACKET_RAM_WR_DIS_INT_I_OFF),
                                              cmp,
                                              max_count,
                                              num_failed_polls,
                                              delay_between_polls_in_microseconds);
}

static INLINE void etime_field_PACKET_RAM_RD_DIS_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_PACKET_RAM_RD_DIS_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 value )
{
    if (value > 4095)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_PACKET_RAM_RD_DIS_INT_I_set_to_clear", value, 4095);
    IOLOG( "%s <= 0x%08x", "etime_field_PACKET_RAM_RD_DIS_INT_I_set_to_clear", value );

    /* (0x0000001c bits 11:0) field PACKET_RAM_RD_DIS_INT_I of register PMC_ETIME120_REG_PACKET_DIS_INT_REG */
    etime_reg_PACKET_DIS_INT_REG_action_on_write_field_set( b_ptr,
                                                            h_ptr,
                                                            ETIME120_REG_PACKET_DIS_INT_REG_BIT_PACKET_RAM_RD_DIS_INT_I_MSK,
                                                            ETIME120_REG_PACKET_DIS_INT_REG_BIT_PACKET_RAM_RD_DIS_INT_I_OFF,
                                                            value);
}

static INLINE UINT32 etime_field_PACKET_RAM_RD_DIS_INT_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_PACKET_RAM_RD_DIS_INT_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000001c bits 11:0) field PACKET_RAM_RD_DIS_INT_I of register PMC_ETIME120_REG_PACKET_DIS_INT_REG */
    reg_value = etime_reg_PACKET_DIS_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_PACKET_DIS_INT_REG_BIT_PACKET_RAM_RD_DIS_INT_I_MSK) >> ETIME120_REG_PACKET_DIS_INT_REG_BIT_PACKET_RAM_RD_DIS_INT_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_PACKET_RAM_RD_DIS_INT_I_get", value );

    return value;
}
static INLINE void etime_field_range_PACKET_RAM_RD_DIS_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                           etime_handle_t *h_ptr,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit,
                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_PACKET_RAM_RD_DIS_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                           etime_handle_t *h_ptr,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit,
                                                                           UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_PACKET_RAM_RD_DIS_INT_I_set_to_clear", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_PACKET_RAM_RD_DIS_INT_I_set_to_clear", stop_bit, 11 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_PACKET_RAM_RD_DIS_INT_I_set_to_clear", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000001c bits 11:0) field PACKET_RAM_RD_DIS_INT_I of register PMC_ETIME120_REG_PACKET_DIS_INT_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000001c bits 11:0) field PACKET_RAM_RD_DIS_INT_I of register PMC_ETIME120_REG_PACKET_DIS_INT_REG */
        etime_reg_PACKET_DIS_INT_REG_action_on_write_field_set( b_ptr,
                                                                h_ptr,
                                                                subfield_mask << (ETIME120_REG_PACKET_DIS_INT_REG_BIT_PACKET_RAM_RD_DIS_INT_I_OFF + subfield_offset),
                                                                ETIME120_REG_PACKET_DIS_INT_REG_BIT_PACKET_RAM_RD_DIS_INT_I_OFF + subfield_offset,
                                                                value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_PACKET_RAM_RD_DIS_INT_I_get( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_PACKET_RAM_RD_DIS_INT_I_get( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_PACKET_RAM_RD_DIS_INT_I_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_PACKET_RAM_RD_DIS_INT_I_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000001c bits 11:0) field PACKET_RAM_RD_DIS_INT_I of register PMC_ETIME120_REG_PACKET_DIS_INT_REG */
    reg_value = etime_reg_PACKET_DIS_INT_REG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_PACKET_DIS_INT_REG_BIT_PACKET_RAM_RD_DIS_INT_I_MSK)
                  >> ETIME120_REG_PACKET_DIS_INT_REG_BIT_PACKET_RAM_RD_DIS_INT_I_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_PACKET_DIS_INT_REG_BIT_PACKET_RAM_RD_DIS_INT_I_MSK, ETIME120_REG_PACKET_DIS_INT_REG_BIT_PACKET_RAM_RD_DIS_INT_I_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_PACKET_RAM_RD_DIS_INT_I_get", start_bit, stop_bit, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_PACKET_RAM_RD_DIS_INT_I_poll( etime_buffer_t *b_ptr,
                                                                                   etime_handle_t *h_ptr,
                                                                                   UINT32 start_bit,
                                                                                   UINT32 stop_bit,
                                                                                   UINT32 value,
                                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                                   UINT32 max_count,
                                                                                   UINT32 *num_failed_polls,
                                                                                   UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_PACKET_RAM_RD_DIS_INT_I_poll( etime_buffer_t *b_ptr,
                                                                                   etime_handle_t *h_ptr,
                                                                                   UINT32 start_bit,
                                                                                   UINT32 stop_bit,
                                                                                   UINT32 value,
                                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                                   UINT32 max_count,
                                                                                   UINT32 *num_failed_polls,
                                                                                   UINT32 delay_between_polls_in_microseconds )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_PACKET_RAM_RD_DIS_INT_I_poll", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_PACKET_RAM_RD_DIS_INT_I_poll", stop_bit, 11 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_PACKET_RAM_RD_DIS_INT_I_poll", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000001c bits 11:0) field PACKET_RAM_RD_DIS_INT_I of register PMC_ETIME120_REG_PACKET_DIS_INT_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000001c bits 11:0) field PACKET_RAM_RD_DIS_INT_I of register PMC_ETIME120_REG_PACKET_DIS_INT_REG */
        return etime_reg_PACKET_DIS_INT_REG_poll( b_ptr,
                                                  h_ptr,
                                                  subfield_mask << (ETIME120_REG_PACKET_DIS_INT_REG_BIT_PACKET_RAM_RD_DIS_INT_I_OFF + subfield_offset),
                                                  value << (ETIME120_REG_PACKET_DIS_INT_REG_BIT_PACKET_RAM_RD_DIS_INT_I_OFF + subfield_offset),
                                                  cmp,
                                                  max_count,
                                                  num_failed_polls,
                                                  delay_between_polls_in_microseconds);
    }
    return PMC_ERR_INVALID_PARAMETERS;
}

static INLINE PMC_POLL_RETURN_TYPE etime_field_PACKET_RAM_RD_DIS_INT_I_poll( etime_buffer_t *b_ptr,
                                                                             etime_handle_t *h_ptr,
                                                                             UINT32 value,
                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                             UINT32 max_count,
                                                                             UINT32 *num_failed_polls,
                                                                             UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_PACKET_RAM_RD_DIS_INT_I_poll( etime_buffer_t *b_ptr,
                                                                             etime_handle_t *h_ptr,
                                                                             UINT32 value,
                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                             UINT32 max_count,
                                                                             UINT32 *num_failed_polls,
                                                                             UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_PACKET_RAM_RD_DIS_INT_I_poll", value );

    /* (0x0000001c bits 11:0) field PACKET_RAM_RD_DIS_INT_I of register PMC_ETIME120_REG_PACKET_DIS_INT_REG */
    return etime_reg_PACKET_DIS_INT_REG_poll( b_ptr,
                                              h_ptr,
                                              ETIME120_REG_PACKET_DIS_INT_REG_BIT_PACKET_RAM_RD_DIS_INT_I_MSK,
                                              (value<<ETIME120_REG_PACKET_DIS_INT_REG_BIT_PACKET_RAM_RD_DIS_INT_I_OFF),
                                              cmp,
                                              max_count,
                                              num_failed_polls,
                                              delay_between_polls_in_microseconds);
}

static INLINE void etime_field_PACKET_RAM_OSIZE_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_PACKET_RAM_OSIZE_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 value )
{
    if (value > 4095)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_PACKET_RAM_OSIZE_INT_I_set_to_clear", value, 4095);
    IOLOG( "%s <= 0x%08x", "etime_field_PACKET_RAM_OSIZE_INT_I_set_to_clear", value );

    /* (0x00000020 bits 11:0) field PACKET_RAM_OSIZE_INT_I of register PMC_ETIME120_REG_PACKET_RAM_ERR_INT_REG */
    etime_reg_PACKET_RAM_ERR_INT_REG_action_on_write_field_set( b_ptr,
                                                                h_ptr,
                                                                ETIME120_REG_PACKET_RAM_ERR_INT_REG_BIT_PACKET_RAM_OSIZE_INT_I_MSK,
                                                                ETIME120_REG_PACKET_RAM_ERR_INT_REG_BIT_PACKET_RAM_OSIZE_INT_I_OFF,
                                                                value);
}

static INLINE UINT32 etime_field_PACKET_RAM_OSIZE_INT_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_PACKET_RAM_OSIZE_INT_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000020 bits 11:0) field PACKET_RAM_OSIZE_INT_I of register PMC_ETIME120_REG_PACKET_RAM_ERR_INT_REG */
    reg_value = etime_reg_PACKET_RAM_ERR_INT_REG_read( b_ptr,
                                                       h_ptr);
    value = (reg_value & ETIME120_REG_PACKET_RAM_ERR_INT_REG_BIT_PACKET_RAM_OSIZE_INT_I_MSK) >> ETIME120_REG_PACKET_RAM_ERR_INT_REG_BIT_PACKET_RAM_OSIZE_INT_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_PACKET_RAM_OSIZE_INT_I_get", value );

    return value;
}
static INLINE void etime_field_range_PACKET_RAM_OSIZE_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_PACKET_RAM_OSIZE_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_PACKET_RAM_OSIZE_INT_I_set_to_clear", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_PACKET_RAM_OSIZE_INT_I_set_to_clear", stop_bit, 11 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_PACKET_RAM_OSIZE_INT_I_set_to_clear", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000020 bits 11:0) field PACKET_RAM_OSIZE_INT_I of register PMC_ETIME120_REG_PACKET_RAM_ERR_INT_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000020 bits 11:0) field PACKET_RAM_OSIZE_INT_I of register PMC_ETIME120_REG_PACKET_RAM_ERR_INT_REG */
        etime_reg_PACKET_RAM_ERR_INT_REG_action_on_write_field_set( b_ptr,
                                                                    h_ptr,
                                                                    subfield_mask << (ETIME120_REG_PACKET_RAM_ERR_INT_REG_BIT_PACKET_RAM_OSIZE_INT_I_OFF + subfield_offset),
                                                                    ETIME120_REG_PACKET_RAM_ERR_INT_REG_BIT_PACKET_RAM_OSIZE_INT_I_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_PACKET_RAM_OSIZE_INT_I_get( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_PACKET_RAM_OSIZE_INT_I_get( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_PACKET_RAM_OSIZE_INT_I_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_PACKET_RAM_OSIZE_INT_I_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000020 bits 11:0) field PACKET_RAM_OSIZE_INT_I of register PMC_ETIME120_REG_PACKET_RAM_ERR_INT_REG */
    reg_value = etime_reg_PACKET_RAM_ERR_INT_REG_read( b_ptr,
                                                       h_ptr);
    field_value = (reg_value & ETIME120_REG_PACKET_RAM_ERR_INT_REG_BIT_PACKET_RAM_OSIZE_INT_I_MSK)
                  >> ETIME120_REG_PACKET_RAM_ERR_INT_REG_BIT_PACKET_RAM_OSIZE_INT_I_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_PACKET_RAM_ERR_INT_REG_BIT_PACKET_RAM_OSIZE_INT_I_MSK, ETIME120_REG_PACKET_RAM_ERR_INT_REG_BIT_PACKET_RAM_OSIZE_INT_I_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_PACKET_RAM_OSIZE_INT_I_get", start_bit, stop_bit, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_PACKET_RAM_OSIZE_INT_I_poll( etime_buffer_t *b_ptr,
                                                                                  etime_handle_t *h_ptr,
                                                                                  UINT32 start_bit,
                                                                                  UINT32 stop_bit,
                                                                                  UINT32 value,
                                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                                  UINT32 max_count,
                                                                                  UINT32 *num_failed_polls,
                                                                                  UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_PACKET_RAM_OSIZE_INT_I_poll( etime_buffer_t *b_ptr,
                                                                                  etime_handle_t *h_ptr,
                                                                                  UINT32 start_bit,
                                                                                  UINT32 stop_bit,
                                                                                  UINT32 value,
                                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                                  UINT32 max_count,
                                                                                  UINT32 *num_failed_polls,
                                                                                  UINT32 delay_between_polls_in_microseconds )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_PACKET_RAM_OSIZE_INT_I_poll", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_PACKET_RAM_OSIZE_INT_I_poll", stop_bit, 11 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_PACKET_RAM_OSIZE_INT_I_poll", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000020 bits 11:0) field PACKET_RAM_OSIZE_INT_I of register PMC_ETIME120_REG_PACKET_RAM_ERR_INT_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000020 bits 11:0) field PACKET_RAM_OSIZE_INT_I of register PMC_ETIME120_REG_PACKET_RAM_ERR_INT_REG */
        return etime_reg_PACKET_RAM_ERR_INT_REG_poll( b_ptr,
                                                      h_ptr,
                                                      subfield_mask << (ETIME120_REG_PACKET_RAM_ERR_INT_REG_BIT_PACKET_RAM_OSIZE_INT_I_OFF + subfield_offset),
                                                      value << (ETIME120_REG_PACKET_RAM_ERR_INT_REG_BIT_PACKET_RAM_OSIZE_INT_I_OFF + subfield_offset),
                                                      cmp,
                                                      max_count,
                                                      num_failed_polls,
                                                      delay_between_polls_in_microseconds);
    }
    return PMC_ERR_INVALID_PARAMETERS;
}

static INLINE PMC_POLL_RETURN_TYPE etime_field_PACKET_RAM_OSIZE_INT_I_poll( etime_buffer_t *b_ptr,
                                                                            etime_handle_t *h_ptr,
                                                                            UINT32 value,
                                                                            PMC_POLL_COMPARISON_TYPE cmp,
                                                                            UINT32 max_count,
                                                                            UINT32 *num_failed_polls,
                                                                            UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_PACKET_RAM_OSIZE_INT_I_poll( etime_buffer_t *b_ptr,
                                                                            etime_handle_t *h_ptr,
                                                                            UINT32 value,
                                                                            PMC_POLL_COMPARISON_TYPE cmp,
                                                                            UINT32 max_count,
                                                                            UINT32 *num_failed_polls,
                                                                            UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_PACKET_RAM_OSIZE_INT_I_poll", value );

    /* (0x00000020 bits 11:0) field PACKET_RAM_OSIZE_INT_I of register PMC_ETIME120_REG_PACKET_RAM_ERR_INT_REG */
    return etime_reg_PACKET_RAM_ERR_INT_REG_poll( b_ptr,
                                                  h_ptr,
                                                  ETIME120_REG_PACKET_RAM_ERR_INT_REG_BIT_PACKET_RAM_OSIZE_INT_I_MSK,
                                                  (value<<ETIME120_REG_PACKET_RAM_ERR_INT_REG_BIT_PACKET_RAM_OSIZE_INT_I_OFF),
                                                  cmp,
                                                  max_count,
                                                  num_failed_polls,
                                                  delay_between_polls_in_microseconds);
}

static INLINE void etime_field_EXT_DESYNC_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_EXT_DESYNC_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 value )
{
    if (value > 4095)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_EXT_DESYNC_INT_I_set_to_clear", value, 4095);
    IOLOG( "%s <= 0x%08x", "etime_field_EXT_DESYNC_INT_I_set_to_clear", value );

    /* (0x00000024 bits 11:0) field EXT_DESYNC_INT_I of register PMC_ETIME120_REG_EXT_DESYNC_ERR_INT_REG */
    etime_reg_EXT_DESYNC_ERR_INT_REG_action_on_write_field_set( b_ptr,
                                                                h_ptr,
                                                                ETIME120_REG_EXT_DESYNC_ERR_INT_REG_BIT_EXT_DESYNC_INT_I_MSK,
                                                                ETIME120_REG_EXT_DESYNC_ERR_INT_REG_BIT_EXT_DESYNC_INT_I_OFF,
                                                                value);
}

static INLINE UINT32 etime_field_EXT_DESYNC_INT_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EXT_DESYNC_INT_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000024 bits 11:0) field EXT_DESYNC_INT_I of register PMC_ETIME120_REG_EXT_DESYNC_ERR_INT_REG */
    reg_value = etime_reg_EXT_DESYNC_ERR_INT_REG_read( b_ptr,
                                                       h_ptr);
    value = (reg_value & ETIME120_REG_EXT_DESYNC_ERR_INT_REG_BIT_EXT_DESYNC_INT_I_MSK) >> ETIME120_REG_EXT_DESYNC_ERR_INT_REG_BIT_EXT_DESYNC_INT_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EXT_DESYNC_INT_I_get", value );

    return value;
}
static INLINE void etime_field_range_EXT_DESYNC_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_range_EXT_DESYNC_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_DESYNC_INT_I_set_to_clear", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_DESYNC_INT_I_set_to_clear", stop_bit, 11 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_DESYNC_INT_I_set_to_clear", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000024 bits 11:0) field EXT_DESYNC_INT_I of register PMC_ETIME120_REG_EXT_DESYNC_ERR_INT_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000024 bits 11:0) field EXT_DESYNC_INT_I of register PMC_ETIME120_REG_EXT_DESYNC_ERR_INT_REG */
        etime_reg_EXT_DESYNC_ERR_INT_REG_action_on_write_field_set( b_ptr,
                                                                    h_ptr,
                                                                    subfield_mask << (ETIME120_REG_EXT_DESYNC_ERR_INT_REG_BIT_EXT_DESYNC_INT_I_OFF + subfield_offset),
                                                                    ETIME120_REG_EXT_DESYNC_ERR_INT_REG_BIT_EXT_DESYNC_INT_I_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 etime_field_range_EXT_DESYNC_INT_I_get( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_EXT_DESYNC_INT_I_get( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_DESYNC_INT_I_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_DESYNC_INT_I_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000024 bits 11:0) field EXT_DESYNC_INT_I of register PMC_ETIME120_REG_EXT_DESYNC_ERR_INT_REG */
    reg_value = etime_reg_EXT_DESYNC_ERR_INT_REG_read( b_ptr,
                                                       h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_DESYNC_ERR_INT_REG_BIT_EXT_DESYNC_INT_I_MSK)
                  >> ETIME120_REG_EXT_DESYNC_ERR_INT_REG_BIT_EXT_DESYNC_INT_I_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_DESYNC_ERR_INT_REG_BIT_EXT_DESYNC_INT_I_MSK, ETIME120_REG_EXT_DESYNC_ERR_INT_REG_BIT_EXT_DESYNC_INT_I_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_DESYNC_INT_I_get", start_bit, stop_bit, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_EXT_DESYNC_INT_I_poll( etime_buffer_t *b_ptr,
                                                                            etime_handle_t *h_ptr,
                                                                            UINT32 start_bit,
                                                                            UINT32 stop_bit,
                                                                            UINT32 value,
                                                                            PMC_POLL_COMPARISON_TYPE cmp,
                                                                            UINT32 max_count,
                                                                            UINT32 *num_failed_polls,
                                                                            UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_EXT_DESYNC_INT_I_poll( etime_buffer_t *b_ptr,
                                                                            etime_handle_t *h_ptr,
                                                                            UINT32 start_bit,
                                                                            UINT32 stop_bit,
                                                                            UINT32 value,
                                                                            PMC_POLL_COMPARISON_TYPE cmp,
                                                                            UINT32 max_count,
                                                                            UINT32 *num_failed_polls,
                                                                            UINT32 delay_between_polls_in_microseconds )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_DESYNC_INT_I_poll", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_DESYNC_INT_I_poll", stop_bit, 11 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_DESYNC_INT_I_poll", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000024 bits 11:0) field EXT_DESYNC_INT_I of register PMC_ETIME120_REG_EXT_DESYNC_ERR_INT_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000024 bits 11:0) field EXT_DESYNC_INT_I of register PMC_ETIME120_REG_EXT_DESYNC_ERR_INT_REG */
        return etime_reg_EXT_DESYNC_ERR_INT_REG_poll( b_ptr,
                                                      h_ptr,
                                                      subfield_mask << (ETIME120_REG_EXT_DESYNC_ERR_INT_REG_BIT_EXT_DESYNC_INT_I_OFF + subfield_offset),
                                                      value << (ETIME120_REG_EXT_DESYNC_ERR_INT_REG_BIT_EXT_DESYNC_INT_I_OFF + subfield_offset),
                                                      cmp,
                                                      max_count,
                                                      num_failed_polls,
                                                      delay_between_polls_in_microseconds);
    }
    return PMC_ERR_INVALID_PARAMETERS;
}

static INLINE PMC_POLL_RETURN_TYPE etime_field_EXT_DESYNC_INT_I_poll( etime_buffer_t *b_ptr,
                                                                      etime_handle_t *h_ptr,
                                                                      UINT32 value,
                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                      UINT32 max_count,
                                                                      UINT32 *num_failed_polls,
                                                                      UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_EXT_DESYNC_INT_I_poll( etime_buffer_t *b_ptr,
                                                                      etime_handle_t *h_ptr,
                                                                      UINT32 value,
                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                      UINT32 max_count,
                                                                      UINT32 *num_failed_polls,
                                                                      UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_EXT_DESYNC_INT_I_poll", value );

    /* (0x00000024 bits 11:0) field EXT_DESYNC_INT_I of register PMC_ETIME120_REG_EXT_DESYNC_ERR_INT_REG */
    return etime_reg_EXT_DESYNC_ERR_INT_REG_poll( b_ptr,
                                                  h_ptr,
                                                  ETIME120_REG_EXT_DESYNC_ERR_INT_REG_BIT_EXT_DESYNC_INT_I_MSK,
                                                  (value<<ETIME120_REG_EXT_DESYNC_ERR_INT_REG_BIT_EXT_DESYNC_INT_I_OFF),
                                                  cmp,
                                                  max_count,
                                                  num_failed_polls,
                                                  delay_between_polls_in_microseconds);
}

static INLINE void etime_field_ILLEGAL_1STEP_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_ILLEGAL_1STEP_INT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_ILLEGAL_1STEP_INT_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_ILLEGAL_1STEP_INT_I_set_to_clear", value );

    /* (0x00000028 bits 27) field ILLEGAL_1STEP_INT_I of register PMC_ETIME120_REG_GP_INT_REG */
    etime_reg_GP_INT_REG_action_on_write_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_GP_INT_REG_BIT_ILLEGAL_1STEP_INT_I_MSK,
                                                    ETIME120_REG_GP_INT_REG_BIT_ILLEGAL_1STEP_INT_I_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_ILLEGAL_1STEP_INT_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_ILLEGAL_1STEP_INT_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000028 bits 27) field ILLEGAL_1STEP_INT_I of register PMC_ETIME120_REG_GP_INT_REG */
    reg_value = etime_reg_GP_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_REG_BIT_ILLEGAL_1STEP_INT_I_MSK) >> ETIME120_REG_GP_INT_REG_BIT_ILLEGAL_1STEP_INT_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_ILLEGAL_1STEP_INT_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_ILLEGAL_1STEP_INT_I_poll( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_ILLEGAL_1STEP_INT_I_poll( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_ILLEGAL_1STEP_INT_I_poll", value );

    /* (0x00000028 bits 27) field ILLEGAL_1STEP_INT_I of register PMC_ETIME120_REG_GP_INT_REG */
    return etime_reg_GP_INT_REG_poll( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_GP_INT_REG_BIT_ILLEGAL_1STEP_INT_I_MSK,
                                      (value<<ETIME120_REG_GP_INT_REG_BIT_ILLEGAL_1STEP_INT_I_OFF),
                                      cmp,
                                      max_count,
                                      num_failed_polls,
                                      delay_between_polls_in_microseconds);
}

static INLINE void etime_field_LINE_REF_CPTR_EVNT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_LINE_REF_CPTR_EVNT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_LINE_REF_CPTR_EVNT_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_LINE_REF_CPTR_EVNT_I_set_to_clear", value );

    /* (0x00000028 bits 26) field LINE_REF_CPTR_EVNT_I of register PMC_ETIME120_REG_GP_INT_REG */
    etime_reg_GP_INT_REG_action_on_write_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_GP_INT_REG_BIT_LINE_REF_CPTR_EVNT_I_MSK,
                                                    ETIME120_REG_GP_INT_REG_BIT_LINE_REF_CPTR_EVNT_I_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_LINE_REF_CPTR_EVNT_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_LINE_REF_CPTR_EVNT_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000028 bits 26) field LINE_REF_CPTR_EVNT_I of register PMC_ETIME120_REG_GP_INT_REG */
    reg_value = etime_reg_GP_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_REG_BIT_LINE_REF_CPTR_EVNT_I_MSK) >> ETIME120_REG_GP_INT_REG_BIT_LINE_REF_CPTR_EVNT_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_LINE_REF_CPTR_EVNT_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_LINE_REF_CPTR_EVNT_I_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_LINE_REF_CPTR_EVNT_I_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_LINE_REF_CPTR_EVNT_I_poll", value );

    /* (0x00000028 bits 26) field LINE_REF_CPTR_EVNT_I of register PMC_ETIME120_REG_GP_INT_REG */
    return etime_reg_GP_INT_REG_poll( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_GP_INT_REG_BIT_LINE_REF_CPTR_EVNT_I_MSK,
                                      (value<<ETIME120_REG_GP_INT_REG_BIT_LINE_REF_CPTR_EVNT_I_OFF),
                                      cmp,
                                      max_count,
                                      num_failed_polls,
                                      delay_between_polls_in_microseconds);
}

static INLINE void etime_field_IRIGO_TS_CPTR_EVNT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGO_TS_CPTR_EVNT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGO_TS_CPTR_EVNT_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGO_TS_CPTR_EVNT_I_set_to_clear", value );

    /* (0x00000028 bits 25) field IRIGO_TS_CPTR_EVNT_I of register PMC_ETIME120_REG_GP_INT_REG */
    etime_reg_GP_INT_REG_action_on_write_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_GP_INT_REG_BIT_IRIGO_TS_CPTR_EVNT_I_MSK,
                                                    ETIME120_REG_GP_INT_REG_BIT_IRIGO_TS_CPTR_EVNT_I_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_IRIGO_TS_CPTR_EVNT_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGO_TS_CPTR_EVNT_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000028 bits 25) field IRIGO_TS_CPTR_EVNT_I of register PMC_ETIME120_REG_GP_INT_REG */
    reg_value = etime_reg_GP_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_REG_BIT_IRIGO_TS_CPTR_EVNT_I_MSK) >> ETIME120_REG_GP_INT_REG_BIT_IRIGO_TS_CPTR_EVNT_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGO_TS_CPTR_EVNT_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGO_TS_CPTR_EVNT_I_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGO_TS_CPTR_EVNT_I_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_IRIGO_TS_CPTR_EVNT_I_poll", value );

    /* (0x00000028 bits 25) field IRIGO_TS_CPTR_EVNT_I of register PMC_ETIME120_REG_GP_INT_REG */
    return etime_reg_GP_INT_REG_poll( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_GP_INT_REG_BIT_IRIGO_TS_CPTR_EVNT_I_MSK,
                                      (value<<ETIME120_REG_GP_INT_REG_BIT_IRIGO_TS_CPTR_EVNT_I_OFF),
                                      cmp,
                                      max_count,
                                      num_failed_polls,
                                      delay_between_polls_in_microseconds);
}

static INLINE void etime_field_IRIGO_ONE_PPSO_REALIGN_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                      etime_handle_t *h_ptr,
                                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGO_ONE_PPSO_REALIGN_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                      etime_handle_t *h_ptr,
                                                                      UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGO_ONE_PPSO_REALIGN_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGO_ONE_PPSO_REALIGN_I_set_to_clear", value );

    /* (0x00000028 bits 24) field IRIGO_ONE_PPSO_REALIGN_I of register PMC_ETIME120_REG_GP_INT_REG */
    etime_reg_GP_INT_REG_action_on_write_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_GP_INT_REG_BIT_IRIGO_ONE_PPSO_REALIGN_I_MSK,
                                                    ETIME120_REG_GP_INT_REG_BIT_IRIGO_ONE_PPSO_REALIGN_I_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_IRIGO_ONE_PPSO_REALIGN_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGO_ONE_PPSO_REALIGN_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000028 bits 24) field IRIGO_ONE_PPSO_REALIGN_I of register PMC_ETIME120_REG_GP_INT_REG */
    reg_value = etime_reg_GP_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_REG_BIT_IRIGO_ONE_PPSO_REALIGN_I_MSK) >> ETIME120_REG_GP_INT_REG_BIT_IRIGO_ONE_PPSO_REALIGN_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGO_ONE_PPSO_REALIGN_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGO_ONE_PPSO_REALIGN_I_poll( etime_buffer_t *b_ptr,
                                                                              etime_handle_t *h_ptr,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGO_ONE_PPSO_REALIGN_I_poll( etime_buffer_t *b_ptr,
                                                                              etime_handle_t *h_ptr,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_IRIGO_ONE_PPSO_REALIGN_I_poll", value );

    /* (0x00000028 bits 24) field IRIGO_ONE_PPSO_REALIGN_I of register PMC_ETIME120_REG_GP_INT_REG */
    return etime_reg_GP_INT_REG_poll( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_GP_INT_REG_BIT_IRIGO_ONE_PPSO_REALIGN_I_MSK,
                                      (value<<ETIME120_REG_GP_INT_REG_BIT_IRIGO_ONE_PPSO_REALIGN_I_OFF),
                                      cmp,
                                      max_count,
                                      num_failed_polls,
                                      delay_between_polls_in_microseconds);
}

static INLINE void etime_field_IRIGO_TX_DAT_VAL_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGO_TX_DAT_VAL_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGO_TX_DAT_VAL_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGO_TX_DAT_VAL_I_set_to_clear", value );

    /* (0x00000028 bits 23) field IRIGO_TX_DAT_VAL_I of register PMC_ETIME120_REG_GP_INT_REG */
    etime_reg_GP_INT_REG_action_on_write_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_GP_INT_REG_BIT_IRIGO_TX_DAT_VAL_I_MSK,
                                                    ETIME120_REG_GP_INT_REG_BIT_IRIGO_TX_DAT_VAL_I_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_IRIGO_TX_DAT_VAL_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGO_TX_DAT_VAL_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000028 bits 23) field IRIGO_TX_DAT_VAL_I of register PMC_ETIME120_REG_GP_INT_REG */
    reg_value = etime_reg_GP_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_REG_BIT_IRIGO_TX_DAT_VAL_I_MSK) >> ETIME120_REG_GP_INT_REG_BIT_IRIGO_TX_DAT_VAL_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGO_TX_DAT_VAL_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGO_TX_DAT_VAL_I_poll( etime_buffer_t *b_ptr,
                                                                        etime_handle_t *h_ptr,
                                                                        UINT32 value,
                                                                        PMC_POLL_COMPARISON_TYPE cmp,
                                                                        UINT32 max_count,
                                                                        UINT32 *num_failed_polls,
                                                                        UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGO_TX_DAT_VAL_I_poll( etime_buffer_t *b_ptr,
                                                                        etime_handle_t *h_ptr,
                                                                        UINT32 value,
                                                                        PMC_POLL_COMPARISON_TYPE cmp,
                                                                        UINT32 max_count,
                                                                        UINT32 *num_failed_polls,
                                                                        UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_IRIGO_TX_DAT_VAL_I_poll", value );

    /* (0x00000028 bits 23) field IRIGO_TX_DAT_VAL_I of register PMC_ETIME120_REG_GP_INT_REG */
    return etime_reg_GP_INT_REG_poll( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_GP_INT_REG_BIT_IRIGO_TX_DAT_VAL_I_MSK,
                                      (value<<ETIME120_REG_GP_INT_REG_BIT_IRIGO_TX_DAT_VAL_I_OFF),
                                      cmp,
                                      max_count,
                                      num_failed_polls,
                                      delay_between_polls_in_microseconds);
}

static INLINE void etime_field_PTP_DCSU_TSTMPR_CPTR_EVNT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_PTP_DCSU_TSTMPR_CPTR_EVNT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_PTP_DCSU_TSTMPR_CPTR_EVNT_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_PTP_DCSU_TSTMPR_CPTR_EVNT_I_set_to_clear", value );

    /* (0x00000028 bits 22) field PTP_DCSU_TSTMPR_CPTR_EVNT_I of register PMC_ETIME120_REG_GP_INT_REG */
    etime_reg_GP_INT_REG_action_on_write_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_GP_INT_REG_BIT_PTP_DCSU_TSTMPR_CPTR_EVNT_I_MSK,
                                                    ETIME120_REG_GP_INT_REG_BIT_PTP_DCSU_TSTMPR_CPTR_EVNT_I_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_PTP_DCSU_TSTMPR_CPTR_EVNT_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_PTP_DCSU_TSTMPR_CPTR_EVNT_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000028 bits 22) field PTP_DCSU_TSTMPR_CPTR_EVNT_I of register PMC_ETIME120_REG_GP_INT_REG */
    reg_value = etime_reg_GP_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_REG_BIT_PTP_DCSU_TSTMPR_CPTR_EVNT_I_MSK) >> ETIME120_REG_GP_INT_REG_BIT_PTP_DCSU_TSTMPR_CPTR_EVNT_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_PTP_DCSU_TSTMPR_CPTR_EVNT_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_PTP_DCSU_TSTMPR_CPTR_EVNT_I_poll( etime_buffer_t *b_ptr,
                                                                                 etime_handle_t *h_ptr,
                                                                                 UINT32 value,
                                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                                 UINT32 max_count,
                                                                                 UINT32 *num_failed_polls,
                                                                                 UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_PTP_DCSU_TSTMPR_CPTR_EVNT_I_poll( etime_buffer_t *b_ptr,
                                                                                 etime_handle_t *h_ptr,
                                                                                 UINT32 value,
                                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                                 UINT32 max_count,
                                                                                 UINT32 *num_failed_polls,
                                                                                 UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_PTP_DCSU_TSTMPR_CPTR_EVNT_I_poll", value );

    /* (0x00000028 bits 22) field PTP_DCSU_TSTMPR_CPTR_EVNT_I of register PMC_ETIME120_REG_GP_INT_REG */
    return etime_reg_GP_INT_REG_poll( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_GP_INT_REG_BIT_PTP_DCSU_TSTMPR_CPTR_EVNT_I_MSK,
                                      (value<<ETIME120_REG_GP_INT_REG_BIT_PTP_DCSU_TSTMPR_CPTR_EVNT_I_OFF),
                                      cmp,
                                      max_count,
                                      num_failed_polls,
                                      delay_between_polls_in_microseconds);
}

static INLINE void etime_field_IRIGI_TS_CPTR_EVNT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGI_TS_CPTR_EVNT_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGI_TS_CPTR_EVNT_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGI_TS_CPTR_EVNT_I_set_to_clear", value );

    /* (0x00000028 bits 21) field IRIGI_TS_CPTR_EVNT_I of register PMC_ETIME120_REG_GP_INT_REG */
    etime_reg_GP_INT_REG_action_on_write_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_GP_INT_REG_BIT_IRIGI_TS_CPTR_EVNT_I_MSK,
                                                    ETIME120_REG_GP_INT_REG_BIT_IRIGI_TS_CPTR_EVNT_I_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_IRIGI_TS_CPTR_EVNT_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_TS_CPTR_EVNT_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000028 bits 21) field IRIGI_TS_CPTR_EVNT_I of register PMC_ETIME120_REG_GP_INT_REG */
    reg_value = etime_reg_GP_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_REG_BIT_IRIGI_TS_CPTR_EVNT_I_MSK) >> ETIME120_REG_GP_INT_REG_BIT_IRIGI_TS_CPTR_EVNT_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_TS_CPTR_EVNT_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGI_TS_CPTR_EVNT_I_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGI_TS_CPTR_EVNT_I_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_IRIGI_TS_CPTR_EVNT_I_poll", value );

    /* (0x00000028 bits 21) field IRIGI_TS_CPTR_EVNT_I of register PMC_ETIME120_REG_GP_INT_REG */
    return etime_reg_GP_INT_REG_poll( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_GP_INT_REG_BIT_IRIGI_TS_CPTR_EVNT_I_MSK,
                                      (value<<ETIME120_REG_GP_INT_REG_BIT_IRIGI_TS_CPTR_EVNT_I_OFF),
                                      cmp,
                                      max_count,
                                      num_failed_polls,
                                      delay_between_polls_in_microseconds);
}

static INLINE void etime_field_IRIGI_RX_DAT_VAL_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGI_RX_DAT_VAL_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGI_RX_DAT_VAL_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGI_RX_DAT_VAL_I_set_to_clear", value );

    /* (0x00000028 bits 20) field IRIGI_RX_DAT_VAL_I of register PMC_ETIME120_REG_GP_INT_REG */
    etime_reg_GP_INT_REG_action_on_write_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_GP_INT_REG_BIT_IRIGI_RX_DAT_VAL_I_MSK,
                                                    ETIME120_REG_GP_INT_REG_BIT_IRIGI_RX_DAT_VAL_I_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_IRIGI_RX_DAT_VAL_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_RX_DAT_VAL_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000028 bits 20) field IRIGI_RX_DAT_VAL_I of register PMC_ETIME120_REG_GP_INT_REG */
    reg_value = etime_reg_GP_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_REG_BIT_IRIGI_RX_DAT_VAL_I_MSK) >> ETIME120_REG_GP_INT_REG_BIT_IRIGI_RX_DAT_VAL_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_RX_DAT_VAL_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGI_RX_DAT_VAL_I_poll( etime_buffer_t *b_ptr,
                                                                        etime_handle_t *h_ptr,
                                                                        UINT32 value,
                                                                        PMC_POLL_COMPARISON_TYPE cmp,
                                                                        UINT32 max_count,
                                                                        UINT32 *num_failed_polls,
                                                                        UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGI_RX_DAT_VAL_I_poll( etime_buffer_t *b_ptr,
                                                                        etime_handle_t *h_ptr,
                                                                        UINT32 value,
                                                                        PMC_POLL_COMPARISON_TYPE cmp,
                                                                        UINT32 max_count,
                                                                        UINT32 *num_failed_polls,
                                                                        UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_IRIGI_RX_DAT_VAL_I_poll", value );

    /* (0x00000028 bits 20) field IRIGI_RX_DAT_VAL_I of register PMC_ETIME120_REG_GP_INT_REG */
    return etime_reg_GP_INT_REG_poll( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_GP_INT_REG_BIT_IRIGI_RX_DAT_VAL_I_MSK,
                                      (value<<ETIME120_REG_GP_INT_REG_BIT_IRIGI_RX_DAT_VAL_I_OFF),
                                      cmp,
                                      max_count,
                                      num_failed_polls,
                                      delay_between_polls_in_microseconds);
}

static INLINE void etime_field_IRIGI_REALIGN_I_set_to_clear( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGI_REALIGN_I_set_to_clear( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGI_REALIGN_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGI_REALIGN_I_set_to_clear", value );

    /* (0x00000028 bits 19) field IRIGI_REALIGN_I of register PMC_ETIME120_REG_GP_INT_REG */
    etime_reg_GP_INT_REG_action_on_write_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_GP_INT_REG_BIT_IRIGI_REALIGN_I_MSK,
                                                    ETIME120_REG_GP_INT_REG_BIT_IRIGI_REALIGN_I_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_IRIGI_REALIGN_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_REALIGN_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000028 bits 19) field IRIGI_REALIGN_I of register PMC_ETIME120_REG_GP_INT_REG */
    reg_value = etime_reg_GP_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_REG_BIT_IRIGI_REALIGN_I_MSK) >> ETIME120_REG_GP_INT_REG_BIT_IRIGI_REALIGN_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_REALIGN_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGI_REALIGN_I_poll( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 value,
                                                                     PMC_POLL_COMPARISON_TYPE cmp,
                                                                     UINT32 max_count,
                                                                     UINT32 *num_failed_polls,
                                                                     UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGI_REALIGN_I_poll( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 value,
                                                                     PMC_POLL_COMPARISON_TYPE cmp,
                                                                     UINT32 max_count,
                                                                     UINT32 *num_failed_polls,
                                                                     UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_IRIGI_REALIGN_I_poll", value );

    /* (0x00000028 bits 19) field IRIGI_REALIGN_I of register PMC_ETIME120_REG_GP_INT_REG */
    return etime_reg_GP_INT_REG_poll( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_GP_INT_REG_BIT_IRIGI_REALIGN_I_MSK,
                                      (value<<ETIME120_REG_GP_INT_REG_BIT_IRIGI_REALIGN_I_OFF),
                                      cmp,
                                      max_count,
                                      num_failed_polls,
                                      delay_between_polls_in_microseconds);
}

static INLINE void etime_field_IRIGI_P0PR_MISSING_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGI_P0PR_MISSING_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGI_P0PR_MISSING_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGI_P0PR_MISSING_I_set_to_clear", value );

    /* (0x00000028 bits 18) field IRIGI_P0PR_MISSING_I of register PMC_ETIME120_REG_GP_INT_REG */
    etime_reg_GP_INT_REG_action_on_write_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_GP_INT_REG_BIT_IRIGI_P0PR_MISSING_I_MSK,
                                                    ETIME120_REG_GP_INT_REG_BIT_IRIGI_P0PR_MISSING_I_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_IRIGI_P0PR_MISSING_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_P0PR_MISSING_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000028 bits 18) field IRIGI_P0PR_MISSING_I of register PMC_ETIME120_REG_GP_INT_REG */
    reg_value = etime_reg_GP_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_REG_BIT_IRIGI_P0PR_MISSING_I_MSK) >> ETIME120_REG_GP_INT_REG_BIT_IRIGI_P0PR_MISSING_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_P0PR_MISSING_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGI_P0PR_MISSING_I_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGI_P0PR_MISSING_I_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_IRIGI_P0PR_MISSING_I_poll", value );

    /* (0x00000028 bits 18) field IRIGI_P0PR_MISSING_I of register PMC_ETIME120_REG_GP_INT_REG */
    return etime_reg_GP_INT_REG_poll( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_GP_INT_REG_BIT_IRIGI_P0PR_MISSING_I_MSK,
                                      (value<<ETIME120_REG_GP_INT_REG_BIT_IRIGI_P0PR_MISSING_I_OFF),
                                      cmp,
                                      max_count,
                                      num_failed_polls,
                                      delay_between_polls_in_microseconds);
}

static INLINE void etime_field_IRIGI_IDLE_I_set_to_clear( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGI_IDLE_I_set_to_clear( etime_buffer_t *b_ptr,
                                                          etime_handle_t *h_ptr,
                                                          UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGI_IDLE_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGI_IDLE_I_set_to_clear", value );

    /* (0x00000028 bits 17) field IRIGI_IDLE_I of register PMC_ETIME120_REG_GP_INT_REG */
    etime_reg_GP_INT_REG_action_on_write_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_GP_INT_REG_BIT_IRIGI_IDLE_I_MSK,
                                                    ETIME120_REG_GP_INT_REG_BIT_IRIGI_IDLE_I_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_IRIGI_IDLE_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_IDLE_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000028 bits 17) field IRIGI_IDLE_I of register PMC_ETIME120_REG_GP_INT_REG */
    reg_value = etime_reg_GP_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_REG_BIT_IRIGI_IDLE_I_MSK) >> ETIME120_REG_GP_INT_REG_BIT_IRIGI_IDLE_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_IDLE_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGI_IDLE_I_poll( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 value,
                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                  UINT32 max_count,
                                                                  UINT32 *num_failed_polls,
                                                                  UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGI_IDLE_I_poll( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 value,
                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                  UINT32 max_count,
                                                                  UINT32 *num_failed_polls,
                                                                  UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_IRIGI_IDLE_I_poll", value );

    /* (0x00000028 bits 17) field IRIGI_IDLE_I of register PMC_ETIME120_REG_GP_INT_REG */
    return etime_reg_GP_INT_REG_poll( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_GP_INT_REG_BIT_IRIGI_IDLE_I_MSK,
                                      (value<<ETIME120_REG_GP_INT_REG_BIT_IRIGI_IDLE_I_OFF),
                                      cmp,
                                      max_count,
                                      num_failed_polls,
                                      delay_between_polls_in_microseconds);
}

static INLINE void etime_field_IRIGI_ONE_PPSO_REALIGN_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                      etime_handle_t *h_ptr,
                                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGI_ONE_PPSO_REALIGN_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                      etime_handle_t *h_ptr,
                                                                      UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGI_ONE_PPSO_REALIGN_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGI_ONE_PPSO_REALIGN_I_set_to_clear", value );

    /* (0x00000028 bits 16) field IRIGI_ONE_PPSO_REALIGN_I of register PMC_ETIME120_REG_GP_INT_REG */
    etime_reg_GP_INT_REG_action_on_write_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_GP_INT_REG_BIT_IRIGI_ONE_PPSO_REALIGN_I_MSK,
                                                    ETIME120_REG_GP_INT_REG_BIT_IRIGI_ONE_PPSO_REALIGN_I_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_IRIGI_ONE_PPSO_REALIGN_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_ONE_PPSO_REALIGN_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000028 bits 16) field IRIGI_ONE_PPSO_REALIGN_I of register PMC_ETIME120_REG_GP_INT_REG */
    reg_value = etime_reg_GP_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_REG_BIT_IRIGI_ONE_PPSO_REALIGN_I_MSK) >> ETIME120_REG_GP_INT_REG_BIT_IRIGI_ONE_PPSO_REALIGN_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_ONE_PPSO_REALIGN_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGI_ONE_PPSO_REALIGN_I_poll( etime_buffer_t *b_ptr,
                                                                              etime_handle_t *h_ptr,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGI_ONE_PPSO_REALIGN_I_poll( etime_buffer_t *b_ptr,
                                                                              etime_handle_t *h_ptr,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_IRIGI_ONE_PPSO_REALIGN_I_poll", value );

    /* (0x00000028 bits 16) field IRIGI_ONE_PPSO_REALIGN_I of register PMC_ETIME120_REG_GP_INT_REG */
    return etime_reg_GP_INT_REG_poll( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_GP_INT_REG_BIT_IRIGI_ONE_PPSO_REALIGN_I_MSK,
                                      (value<<ETIME120_REG_GP_INT_REG_BIT_IRIGI_ONE_PPSO_REALIGN_I_OFF),
                                      cmp,
                                      max_count,
                                      num_failed_polls,
                                      delay_between_polls_in_microseconds);
}

static INLINE void etime_field_IRIGI_PWM_DEC_ERR_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_IRIGI_PWM_DEC_ERR_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_IRIGI_PWM_DEC_ERR_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_IRIGI_PWM_DEC_ERR_I_set_to_clear", value );

    /* (0x00000028 bits 15) field IRIGI_PWM_DEC_ERR_I of register PMC_ETIME120_REG_GP_INT_REG */
    etime_reg_GP_INT_REG_action_on_write_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_GP_INT_REG_BIT_IRIGI_PWM_DEC_ERR_I_MSK,
                                                    ETIME120_REG_GP_INT_REG_BIT_IRIGI_PWM_DEC_ERR_I_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_IRIGI_PWM_DEC_ERR_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_PWM_DEC_ERR_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000028 bits 15) field IRIGI_PWM_DEC_ERR_I of register PMC_ETIME120_REG_GP_INT_REG */
    reg_value = etime_reg_GP_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_REG_BIT_IRIGI_PWM_DEC_ERR_I_MSK) >> ETIME120_REG_GP_INT_REG_BIT_IRIGI_PWM_DEC_ERR_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_PWM_DEC_ERR_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGI_PWM_DEC_ERR_I_poll( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGI_PWM_DEC_ERR_I_poll( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_IRIGI_PWM_DEC_ERR_I_poll", value );

    /* (0x00000028 bits 15) field IRIGI_PWM_DEC_ERR_I of register PMC_ETIME120_REG_GP_INT_REG */
    return etime_reg_GP_INT_REG_poll( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_GP_INT_REG_BIT_IRIGI_PWM_DEC_ERR_I_MSK,
                                      (value<<ETIME120_REG_GP_INT_REG_BIT_IRIGI_PWM_DEC_ERR_I_OFF),
                                      cmp,
                                      max_count,
                                      num_failed_polls,
                                      delay_between_polls_in_microseconds);
}

static INLINE void etime_field_TOD_CFC_OFFS_TS_CNTR_UPDATED_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                            etime_handle_t *h_ptr,
                                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_CFC_OFFS_TS_CNTR_UPDATED_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                            etime_handle_t *h_ptr,
                                                                            UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_CFC_OFFS_TS_CNTR_UPDATED_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_CFC_OFFS_TS_CNTR_UPDATED_I_set_to_clear", value );

    /* (0x00000028 bits 14) field TOD_CFC_OFFS_TS_CNTR_UPDATED_I of register PMC_ETIME120_REG_GP_INT_REG */
    etime_reg_GP_INT_REG_action_on_write_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_GP_INT_REG_BIT_TOD_CFC_OFFS_TS_CNTR_UPDATED_I_MSK,
                                                    ETIME120_REG_GP_INT_REG_BIT_TOD_CFC_OFFS_TS_CNTR_UPDATED_I_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_TOD_CFC_OFFS_TS_CNTR_UPDATED_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_CFC_OFFS_TS_CNTR_UPDATED_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000028 bits 14) field TOD_CFC_OFFS_TS_CNTR_UPDATED_I of register PMC_ETIME120_REG_GP_INT_REG */
    reg_value = etime_reg_GP_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_REG_BIT_TOD_CFC_OFFS_TS_CNTR_UPDATED_I_MSK) >> ETIME120_REG_GP_INT_REG_BIT_TOD_CFC_OFFS_TS_CNTR_UPDATED_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_CFC_OFFS_TS_CNTR_UPDATED_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_TOD_CFC_OFFS_TS_CNTR_UPDATED_I_poll( etime_buffer_t *b_ptr,
                                                                                    etime_handle_t *h_ptr,
                                                                                    UINT32 value,
                                                                                    PMC_POLL_COMPARISON_TYPE cmp,
                                                                                    UINT32 max_count,
                                                                                    UINT32 *num_failed_polls,
                                                                                    UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_TOD_CFC_OFFS_TS_CNTR_UPDATED_I_poll( etime_buffer_t *b_ptr,
                                                                                    etime_handle_t *h_ptr,
                                                                                    UINT32 value,
                                                                                    PMC_POLL_COMPARISON_TYPE cmp,
                                                                                    UINT32 max_count,
                                                                                    UINT32 *num_failed_polls,
                                                                                    UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_TOD_CFC_OFFS_TS_CNTR_UPDATED_I_poll", value );

    /* (0x00000028 bits 14) field TOD_CFC_OFFS_TS_CNTR_UPDATED_I of register PMC_ETIME120_REG_GP_INT_REG */
    return etime_reg_GP_INT_REG_poll( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_GP_INT_REG_BIT_TOD_CFC_OFFS_TS_CNTR_UPDATED_I_MSK,
                                      (value<<ETIME120_REG_GP_INT_REG_BIT_TOD_CFC_OFFS_TS_CNTR_UPDATED_I_OFF),
                                      cmp,
                                      max_count,
                                      num_failed_polls,
                                      delay_between_polls_in_microseconds);
}

static INLINE void etime_field_TS_INTERPOLATE_CNTR_ERR_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                       etime_handle_t *h_ptr,
                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TS_INTERPOLATE_CNTR_ERR_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                       etime_handle_t *h_ptr,
                                                                       UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TS_INTERPOLATE_CNTR_ERR_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_TS_INTERPOLATE_CNTR_ERR_I_set_to_clear", value );

    /* (0x00000028 bits 13) field TS_INTERPOLATE_CNTR_ERR_I of register PMC_ETIME120_REG_GP_INT_REG */
    etime_reg_GP_INT_REG_action_on_write_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_GP_INT_REG_BIT_TS_INTERPOLATE_CNTR_ERR_I_MSK,
                                                    ETIME120_REG_GP_INT_REG_BIT_TS_INTERPOLATE_CNTR_ERR_I_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_TS_INTERPOLATE_CNTR_ERR_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TS_INTERPOLATE_CNTR_ERR_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000028 bits 13) field TS_INTERPOLATE_CNTR_ERR_I of register PMC_ETIME120_REG_GP_INT_REG */
    reg_value = etime_reg_GP_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_REG_BIT_TS_INTERPOLATE_CNTR_ERR_I_MSK) >> ETIME120_REG_GP_INT_REG_BIT_TS_INTERPOLATE_CNTR_ERR_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TS_INTERPOLATE_CNTR_ERR_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_TS_INTERPOLATE_CNTR_ERR_I_poll( etime_buffer_t *b_ptr,
                                                                               etime_handle_t *h_ptr,
                                                                               UINT32 value,
                                                                               PMC_POLL_COMPARISON_TYPE cmp,
                                                                               UINT32 max_count,
                                                                               UINT32 *num_failed_polls,
                                                                               UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_TS_INTERPOLATE_CNTR_ERR_I_poll( etime_buffer_t *b_ptr,
                                                                               etime_handle_t *h_ptr,
                                                                               UINT32 value,
                                                                               PMC_POLL_COMPARISON_TYPE cmp,
                                                                               UINT32 max_count,
                                                                               UINT32 *num_failed_polls,
                                                                               UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_TS_INTERPOLATE_CNTR_ERR_I_poll", value );

    /* (0x00000028 bits 13) field TS_INTERPOLATE_CNTR_ERR_I of register PMC_ETIME120_REG_GP_INT_REG */
    return etime_reg_GP_INT_REG_poll( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_GP_INT_REG_BIT_TS_INTERPOLATE_CNTR_ERR_I_MSK,
                                      (value<<ETIME120_REG_GP_INT_REG_BIT_TS_INTERPOLATE_CNTR_ERR_I_OFF),
                                      cmp,
                                      max_count,
                                      num_failed_polls,
                                      delay_between_polls_in_microseconds);
}

static INLINE void etime_field_TS_TOD_SIGN_OVRFL_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TS_TOD_SIGN_OVRFL_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TS_TOD_SIGN_OVRFL_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_TS_TOD_SIGN_OVRFL_I_set_to_clear", value );

    /* (0x00000028 bits 12) field TS_TOD_SIGN_OVRFL_I of register PMC_ETIME120_REG_GP_INT_REG */
    etime_reg_GP_INT_REG_action_on_write_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_GP_INT_REG_BIT_TS_TOD_SIGN_OVRFL_I_MSK,
                                                    ETIME120_REG_GP_INT_REG_BIT_TS_TOD_SIGN_OVRFL_I_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_TS_TOD_SIGN_OVRFL_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TS_TOD_SIGN_OVRFL_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000028 bits 12) field TS_TOD_SIGN_OVRFL_I of register PMC_ETIME120_REG_GP_INT_REG */
    reg_value = etime_reg_GP_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_REG_BIT_TS_TOD_SIGN_OVRFL_I_MSK) >> ETIME120_REG_GP_INT_REG_BIT_TS_TOD_SIGN_OVRFL_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TS_TOD_SIGN_OVRFL_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_TS_TOD_SIGN_OVRFL_I_poll( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_TS_TOD_SIGN_OVRFL_I_poll( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_TS_TOD_SIGN_OVRFL_I_poll", value );

    /* (0x00000028 bits 12) field TS_TOD_SIGN_OVRFL_I of register PMC_ETIME120_REG_GP_INT_REG */
    return etime_reg_GP_INT_REG_poll( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_GP_INT_REG_BIT_TS_TOD_SIGN_OVRFL_I_MSK,
                                      (value<<ETIME120_REG_GP_INT_REG_BIT_TS_TOD_SIGN_OVRFL_I_OFF),
                                      cmp,
                                      max_count,
                                      num_failed_polls,
                                      delay_between_polls_in_microseconds);
}

static INLINE void etime_field_CFC_OVRFL_I_set_to_clear( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CFC_OVRFL_I_set_to_clear( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CFC_OVRFL_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_CFC_OVRFL_I_set_to_clear", value );

    /* (0x00000028 bits 11) field CFC_OVRFL_I of register PMC_ETIME120_REG_GP_INT_REG */
    etime_reg_GP_INT_REG_action_on_write_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_GP_INT_REG_BIT_CFC_OVRFL_I_MSK,
                                                    ETIME120_REG_GP_INT_REG_BIT_CFC_OVRFL_I_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_CFC_OVRFL_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_OVRFL_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000028 bits 11) field CFC_OVRFL_I of register PMC_ETIME120_REG_GP_INT_REG */
    reg_value = etime_reg_GP_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_REG_BIT_CFC_OVRFL_I_MSK) >> ETIME120_REG_GP_INT_REG_BIT_CFC_OVRFL_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_OVRFL_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_CFC_OVRFL_I_poll( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 value,
                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                 UINT32 max_count,
                                                                 UINT32 *num_failed_polls,
                                                                 UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_CFC_OVRFL_I_poll( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 value,
                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                 UINT32 max_count,
                                                                 UINT32 *num_failed_polls,
                                                                 UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_CFC_OVRFL_I_poll", value );

    /* (0x00000028 bits 11) field CFC_OVRFL_I of register PMC_ETIME120_REG_GP_INT_REG */
    return etime_reg_GP_INT_REG_poll( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_GP_INT_REG_BIT_CFC_OVRFL_I_MSK,
                                      (value<<ETIME120_REG_GP_INT_REG_BIT_CFC_OVRFL_I_OFF),
                                      cmp,
                                      max_count,
                                      num_failed_polls,
                                      delay_between_polls_in_microseconds);
}

static INLINE void etime_field_TOD_TS_OVRFL_I_set_to_clear( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_TS_OVRFL_I_set_to_clear( etime_buffer_t *b_ptr,
                                                            etime_handle_t *h_ptr,
                                                            UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_TS_OVRFL_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_TS_OVRFL_I_set_to_clear", value );

    /* (0x00000028 bits 10) field TOD_TS_OVRFL_I of register PMC_ETIME120_REG_GP_INT_REG */
    etime_reg_GP_INT_REG_action_on_write_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_GP_INT_REG_BIT_TOD_TS_OVRFL_I_MSK,
                                                    ETIME120_REG_GP_INT_REG_BIT_TOD_TS_OVRFL_I_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_TOD_TS_OVRFL_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_TS_OVRFL_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000028 bits 10) field TOD_TS_OVRFL_I of register PMC_ETIME120_REG_GP_INT_REG */
    reg_value = etime_reg_GP_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_REG_BIT_TOD_TS_OVRFL_I_MSK) >> ETIME120_REG_GP_INT_REG_BIT_TOD_TS_OVRFL_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_TS_OVRFL_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_TOD_TS_OVRFL_I_poll( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 value,
                                                                    PMC_POLL_COMPARISON_TYPE cmp,
                                                                    UINT32 max_count,
                                                                    UINT32 *num_failed_polls,
                                                                    UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_TOD_TS_OVRFL_I_poll( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 value,
                                                                    PMC_POLL_COMPARISON_TYPE cmp,
                                                                    UINT32 max_count,
                                                                    UINT32 *num_failed_polls,
                                                                    UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_TOD_TS_OVRFL_I_poll", value );

    /* (0x00000028 bits 10) field TOD_TS_OVRFL_I of register PMC_ETIME120_REG_GP_INT_REG */
    return etime_reg_GP_INT_REG_poll( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_GP_INT_REG_BIT_TOD_TS_OVRFL_I_MSK,
                                      (value<<ETIME120_REG_GP_INT_REG_BIT_TOD_TS_OVRFL_I_OFF),
                                      cmp,
                                      max_count,
                                      num_failed_polls,
                                      delay_between_polls_in_microseconds);
}

static INLINE void etime_field_FREE_RUN_CFC_OVRFL_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_FREE_RUN_CFC_OVRFL_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_FREE_RUN_CFC_OVRFL_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_FREE_RUN_CFC_OVRFL_I_set_to_clear", value );

    /* (0x00000028 bits 9) field FREE_RUN_CFC_OVRFL_I of register PMC_ETIME120_REG_GP_INT_REG */
    etime_reg_GP_INT_REG_action_on_write_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_GP_INT_REG_BIT_FREE_RUN_CFC_OVRFL_I_MSK,
                                                    ETIME120_REG_GP_INT_REG_BIT_FREE_RUN_CFC_OVRFL_I_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_FREE_RUN_CFC_OVRFL_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_FREE_RUN_CFC_OVRFL_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000028 bits 9) field FREE_RUN_CFC_OVRFL_I of register PMC_ETIME120_REG_GP_INT_REG */
    reg_value = etime_reg_GP_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_REG_BIT_FREE_RUN_CFC_OVRFL_I_MSK) >> ETIME120_REG_GP_INT_REG_BIT_FREE_RUN_CFC_OVRFL_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_FREE_RUN_CFC_OVRFL_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_FREE_RUN_CFC_OVRFL_I_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_FREE_RUN_CFC_OVRFL_I_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_FREE_RUN_CFC_OVRFL_I_poll", value );

    /* (0x00000028 bits 9) field FREE_RUN_CFC_OVRFL_I of register PMC_ETIME120_REG_GP_INT_REG */
    return etime_reg_GP_INT_REG_poll( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_GP_INT_REG_BIT_FREE_RUN_CFC_OVRFL_I_MSK,
                                      (value<<ETIME120_REG_GP_INT_REG_BIT_FREE_RUN_CFC_OVRFL_I_OFF),
                                      cmp,
                                      max_count,
                                      num_failed_polls,
                                      delay_between_polls_in_microseconds);
}

static INLINE void etime_field_FREE_RUN_TS_OVRFL_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_FREE_RUN_TS_OVRFL_I_set_to_clear( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_FREE_RUN_TS_OVRFL_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_FREE_RUN_TS_OVRFL_I_set_to_clear", value );

    /* (0x00000028 bits 8) field FREE_RUN_TS_OVRFL_I of register PMC_ETIME120_REG_GP_INT_REG */
    etime_reg_GP_INT_REG_action_on_write_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_GP_INT_REG_BIT_FREE_RUN_TS_OVRFL_I_MSK,
                                                    ETIME120_REG_GP_INT_REG_BIT_FREE_RUN_TS_OVRFL_I_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_FREE_RUN_TS_OVRFL_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_FREE_RUN_TS_OVRFL_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000028 bits 8) field FREE_RUN_TS_OVRFL_I of register PMC_ETIME120_REG_GP_INT_REG */
    reg_value = etime_reg_GP_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_REG_BIT_FREE_RUN_TS_OVRFL_I_MSK) >> ETIME120_REG_GP_INT_REG_BIT_FREE_RUN_TS_OVRFL_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_FREE_RUN_TS_OVRFL_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_FREE_RUN_TS_OVRFL_I_poll( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_FREE_RUN_TS_OVRFL_I_poll( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_FREE_RUN_TS_OVRFL_I_poll", value );

    /* (0x00000028 bits 8) field FREE_RUN_TS_OVRFL_I of register PMC_ETIME120_REG_GP_INT_REG */
    return etime_reg_GP_INT_REG_poll( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_GP_INT_REG_BIT_FREE_RUN_TS_OVRFL_I_MSK,
                                      (value<<ETIME120_REG_GP_INT_REG_BIT_FREE_RUN_TS_OVRFL_I_OFF),
                                      cmp,
                                      max_count,
                                      num_failed_polls,
                                      delay_between_polls_in_microseconds);
}

static INLINE void etime_field_TOD_INT_1_I_set_to_clear( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_INT_1_I_set_to_clear( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_INT_1_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_INT_1_I_set_to_clear", value );

    /* (0x00000028 bits 7) field TOD_INT_1_I of register PMC_ETIME120_REG_GP_INT_REG */
    etime_reg_GP_INT_REG_action_on_write_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_GP_INT_REG_BIT_TOD_INT_1_I_MSK,
                                                    ETIME120_REG_GP_INT_REG_BIT_TOD_INT_1_I_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_TOD_INT_1_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_INT_1_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000028 bits 7) field TOD_INT_1_I of register PMC_ETIME120_REG_GP_INT_REG */
    reg_value = etime_reg_GP_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_REG_BIT_TOD_INT_1_I_MSK) >> ETIME120_REG_GP_INT_REG_BIT_TOD_INT_1_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_INT_1_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_TOD_INT_1_I_poll( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 value,
                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                 UINT32 max_count,
                                                                 UINT32 *num_failed_polls,
                                                                 UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_TOD_INT_1_I_poll( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 value,
                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                 UINT32 max_count,
                                                                 UINT32 *num_failed_polls,
                                                                 UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_TOD_INT_1_I_poll", value );

    /* (0x00000028 bits 7) field TOD_INT_1_I of register PMC_ETIME120_REG_GP_INT_REG */
    return etime_reg_GP_INT_REG_poll( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_GP_INT_REG_BIT_TOD_INT_1_I_MSK,
                                      (value<<ETIME120_REG_GP_INT_REG_BIT_TOD_INT_1_I_OFF),
                                      cmp,
                                      max_count,
                                      num_failed_polls,
                                      delay_between_polls_in_microseconds);
}

static INLINE void etime_field_TOD_INT_2_I_set_to_clear( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_TOD_INT_2_I_set_to_clear( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_TOD_INT_2_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_TOD_INT_2_I_set_to_clear", value );

    /* (0x00000028 bits 6) field TOD_INT_2_I of register PMC_ETIME120_REG_GP_INT_REG */
    etime_reg_GP_INT_REG_action_on_write_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_GP_INT_REG_BIT_TOD_INT_2_I_MSK,
                                                    ETIME120_REG_GP_INT_REG_BIT_TOD_INT_2_I_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_TOD_INT_2_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_INT_2_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000028 bits 6) field TOD_INT_2_I of register PMC_ETIME120_REG_GP_INT_REG */
    reg_value = etime_reg_GP_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_REG_BIT_TOD_INT_2_I_MSK) >> ETIME120_REG_GP_INT_REG_BIT_TOD_INT_2_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_INT_2_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_TOD_INT_2_I_poll( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 value,
                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                 UINT32 max_count,
                                                                 UINT32 *num_failed_polls,
                                                                 UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_TOD_INT_2_I_poll( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 value,
                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                 UINT32 max_count,
                                                                 UINT32 *num_failed_polls,
                                                                 UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_TOD_INT_2_I_poll", value );

    /* (0x00000028 bits 6) field TOD_INT_2_I of register PMC_ETIME120_REG_GP_INT_REG */
    return etime_reg_GP_INT_REG_poll( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_GP_INT_REG_BIT_TOD_INT_2_I_MSK,
                                      (value<<ETIME120_REG_GP_INT_REG_BIT_TOD_INT_2_I_OFF),
                                      cmp,
                                      max_count,
                                      num_failed_polls,
                                      delay_between_polls_in_microseconds);
}

static INLINE void etime_field_FREE_RUN_INT_1_I_set_to_clear( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_FREE_RUN_INT_1_I_set_to_clear( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_FREE_RUN_INT_1_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_FREE_RUN_INT_1_I_set_to_clear", value );

    /* (0x00000028 bits 5) field FREE_RUN_INT_1_I of register PMC_ETIME120_REG_GP_INT_REG */
    etime_reg_GP_INT_REG_action_on_write_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_GP_INT_REG_BIT_FREE_RUN_INT_1_I_MSK,
                                                    ETIME120_REG_GP_INT_REG_BIT_FREE_RUN_INT_1_I_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_FREE_RUN_INT_1_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_FREE_RUN_INT_1_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000028 bits 5) field FREE_RUN_INT_1_I of register PMC_ETIME120_REG_GP_INT_REG */
    reg_value = etime_reg_GP_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_REG_BIT_FREE_RUN_INT_1_I_MSK) >> ETIME120_REG_GP_INT_REG_BIT_FREE_RUN_INT_1_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_FREE_RUN_INT_1_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_FREE_RUN_INT_1_I_poll( etime_buffer_t *b_ptr,
                                                                      etime_handle_t *h_ptr,
                                                                      UINT32 value,
                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                      UINT32 max_count,
                                                                      UINT32 *num_failed_polls,
                                                                      UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_FREE_RUN_INT_1_I_poll( etime_buffer_t *b_ptr,
                                                                      etime_handle_t *h_ptr,
                                                                      UINT32 value,
                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                      UINT32 max_count,
                                                                      UINT32 *num_failed_polls,
                                                                      UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_FREE_RUN_INT_1_I_poll", value );

    /* (0x00000028 bits 5) field FREE_RUN_INT_1_I of register PMC_ETIME120_REG_GP_INT_REG */
    return etime_reg_GP_INT_REG_poll( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_GP_INT_REG_BIT_FREE_RUN_INT_1_I_MSK,
                                      (value<<ETIME120_REG_GP_INT_REG_BIT_FREE_RUN_INT_1_I_OFF),
                                      cmp,
                                      max_count,
                                      num_failed_polls,
                                      delay_between_polls_in_microseconds);
}

static INLINE void etime_field_FREE_RUN_INT_2_I_set_to_clear( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_FREE_RUN_INT_2_I_set_to_clear( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_FREE_RUN_INT_2_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_FREE_RUN_INT_2_I_set_to_clear", value );

    /* (0x00000028 bits 4) field FREE_RUN_INT_2_I of register PMC_ETIME120_REG_GP_INT_REG */
    etime_reg_GP_INT_REG_action_on_write_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_GP_INT_REG_BIT_FREE_RUN_INT_2_I_MSK,
                                                    ETIME120_REG_GP_INT_REG_BIT_FREE_RUN_INT_2_I_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_FREE_RUN_INT_2_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_FREE_RUN_INT_2_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000028 bits 4) field FREE_RUN_INT_2_I of register PMC_ETIME120_REG_GP_INT_REG */
    reg_value = etime_reg_GP_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_REG_BIT_FREE_RUN_INT_2_I_MSK) >> ETIME120_REG_GP_INT_REG_BIT_FREE_RUN_INT_2_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_FREE_RUN_INT_2_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_FREE_RUN_INT_2_I_poll( etime_buffer_t *b_ptr,
                                                                      etime_handle_t *h_ptr,
                                                                      UINT32 value,
                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                      UINT32 max_count,
                                                                      UINT32 *num_failed_polls,
                                                                      UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_FREE_RUN_INT_2_I_poll( etime_buffer_t *b_ptr,
                                                                      etime_handle_t *h_ptr,
                                                                      UINT32 value,
                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                      UINT32 max_count,
                                                                      UINT32 *num_failed_polls,
                                                                      UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_FREE_RUN_INT_2_I_poll", value );

    /* (0x00000028 bits 4) field FREE_RUN_INT_2_I of register PMC_ETIME120_REG_GP_INT_REG */
    return etime_reg_GP_INT_REG_poll( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_GP_INT_REG_BIT_FREE_RUN_INT_2_I_MSK,
                                      (value<<ETIME120_REG_GP_INT_REG_BIT_FREE_RUN_INT_2_I_OFF),
                                      cmp,
                                      max_count,
                                      num_failed_polls,
                                      delay_between_polls_in_microseconds);
}

static INLINE void etime_field_CC_INT_1_I_set_to_clear( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CC_INT_1_I_set_to_clear( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CC_INT_1_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_CC_INT_1_I_set_to_clear", value );

    /* (0x00000028 bits 3) field CC_INT_1_I of register PMC_ETIME120_REG_GP_INT_REG */
    etime_reg_GP_INT_REG_action_on_write_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_GP_INT_REG_BIT_CC_INT_1_I_MSK,
                                                    ETIME120_REG_GP_INT_REG_BIT_CC_INT_1_I_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_CC_INT_1_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CC_INT_1_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000028 bits 3) field CC_INT_1_I of register PMC_ETIME120_REG_GP_INT_REG */
    reg_value = etime_reg_GP_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_REG_BIT_CC_INT_1_I_MSK) >> ETIME120_REG_GP_INT_REG_BIT_CC_INT_1_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CC_INT_1_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_CC_INT_1_I_poll( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 value,
                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                UINT32 max_count,
                                                                UINT32 *num_failed_polls,
                                                                UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_CC_INT_1_I_poll( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 value,
                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                UINT32 max_count,
                                                                UINT32 *num_failed_polls,
                                                                UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_CC_INT_1_I_poll", value );

    /* (0x00000028 bits 3) field CC_INT_1_I of register PMC_ETIME120_REG_GP_INT_REG */
    return etime_reg_GP_INT_REG_poll( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_GP_INT_REG_BIT_CC_INT_1_I_MSK,
                                      (value<<ETIME120_REG_GP_INT_REG_BIT_CC_INT_1_I_OFF),
                                      cmp,
                                      max_count,
                                      num_failed_polls,
                                      delay_between_polls_in_microseconds);
}

static INLINE void etime_field_CC_INT_2_I_set_to_clear( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CC_INT_2_I_set_to_clear( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CC_INT_2_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_CC_INT_2_I_set_to_clear", value );

    /* (0x00000028 bits 2) field CC_INT_2_I of register PMC_ETIME120_REG_GP_INT_REG */
    etime_reg_GP_INT_REG_action_on_write_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_GP_INT_REG_BIT_CC_INT_2_I_MSK,
                                                    ETIME120_REG_GP_INT_REG_BIT_CC_INT_2_I_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_CC_INT_2_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CC_INT_2_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000028 bits 2) field CC_INT_2_I of register PMC_ETIME120_REG_GP_INT_REG */
    reg_value = etime_reg_GP_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_REG_BIT_CC_INT_2_I_MSK) >> ETIME120_REG_GP_INT_REG_BIT_CC_INT_2_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CC_INT_2_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_CC_INT_2_I_poll( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 value,
                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                UINT32 max_count,
                                                                UINT32 *num_failed_polls,
                                                                UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_CC_INT_2_I_poll( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 value,
                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                UINT32 max_count,
                                                                UINT32 *num_failed_polls,
                                                                UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_CC_INT_2_I_poll", value );

    /* (0x00000028 bits 2) field CC_INT_2_I of register PMC_ETIME120_REG_GP_INT_REG */
    return etime_reg_GP_INT_REG_poll( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_GP_INT_REG_BIT_CC_INT_2_I_MSK,
                                      (value<<ETIME120_REG_GP_INT_REG_BIT_CC_INT_2_I_OFF),
                                      cmp,
                                      max_count,
                                      num_failed_polls,
                                      delay_between_polls_in_microseconds);
}

static INLINE void etime_field_CC_INT_3_I_set_to_clear( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CC_INT_3_I_set_to_clear( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CC_INT_3_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_CC_INT_3_I_set_to_clear", value );

    /* (0x00000028 bits 1) field CC_INT_3_I of register PMC_ETIME120_REG_GP_INT_REG */
    etime_reg_GP_INT_REG_action_on_write_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_GP_INT_REG_BIT_CC_INT_3_I_MSK,
                                                    ETIME120_REG_GP_INT_REG_BIT_CC_INT_3_I_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_CC_INT_3_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CC_INT_3_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000028 bits 1) field CC_INT_3_I of register PMC_ETIME120_REG_GP_INT_REG */
    reg_value = etime_reg_GP_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_REG_BIT_CC_INT_3_I_MSK) >> ETIME120_REG_GP_INT_REG_BIT_CC_INT_3_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CC_INT_3_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_CC_INT_3_I_poll( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 value,
                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                UINT32 max_count,
                                                                UINT32 *num_failed_polls,
                                                                UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_CC_INT_3_I_poll( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 value,
                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                UINT32 max_count,
                                                                UINT32 *num_failed_polls,
                                                                UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_CC_INT_3_I_poll", value );

    /* (0x00000028 bits 1) field CC_INT_3_I of register PMC_ETIME120_REG_GP_INT_REG */
    return etime_reg_GP_INT_REG_poll( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_GP_INT_REG_BIT_CC_INT_3_I_MSK,
                                      (value<<ETIME120_REG_GP_INT_REG_BIT_CC_INT_3_I_OFF),
                                      cmp,
                                      max_count,
                                      num_failed_polls,
                                      delay_between_polls_in_microseconds);
}

static INLINE void etime_field_CC_INT_4_I_set_to_clear( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void etime_field_CC_INT_4_I_set_to_clear( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 value )
{
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "etime_field_CC_INT_4_I_set_to_clear", value, 1);
    IOLOG( "%s <= 0x%08x", "etime_field_CC_INT_4_I_set_to_clear", value );

    /* (0x00000028 bits 0) field CC_INT_4_I of register PMC_ETIME120_REG_GP_INT_REG */
    etime_reg_GP_INT_REG_action_on_write_field_set( b_ptr,
                                                    h_ptr,
                                                    ETIME120_REG_GP_INT_REG_BIT_CC_INT_4_I_MSK,
                                                    ETIME120_REG_GP_INT_REG_BIT_CC_INT_4_I_OFF,
                                                    value);
}

static INLINE UINT32 etime_field_CC_INT_4_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CC_INT_4_I_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000028 bits 0) field CC_INT_4_I of register PMC_ETIME120_REG_GP_INT_REG */
    reg_value = etime_reg_GP_INT_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_REG_BIT_CC_INT_4_I_MSK) >> ETIME120_REG_GP_INT_REG_BIT_CC_INT_4_I_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CC_INT_4_I_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_CC_INT_4_I_poll( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 value,
                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                UINT32 max_count,
                                                                UINT32 *num_failed_polls,
                                                                UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_CC_INT_4_I_poll( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 value,
                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                UINT32 max_count,
                                                                UINT32 *num_failed_polls,
                                                                UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_CC_INT_4_I_poll", value );

    /* (0x00000028 bits 0) field CC_INT_4_I of register PMC_ETIME120_REG_GP_INT_REG */
    return etime_reg_GP_INT_REG_poll( b_ptr,
                                      h_ptr,
                                      ETIME120_REG_GP_INT_REG_BIT_CC_INT_4_I_MSK,
                                      (value<<ETIME120_REG_GP_INT_REG_BIT_CC_INT_4_I_OFF),
                                      cmp,
                                      max_count,
                                      num_failed_polls,
                                      delay_between_polls_in_microseconds);
}


/*
 * ==================================================================================
 * Parameter Access Functions for Paramset int_value
 * ==================================================================================
 */
static INLINE UINT32 etime_field_RAM_BIT_SB_ECC_INT_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_RAM_BIT_SB_ECC_INT_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000004c bits 16:0) field RAM_BIT_SB_ECC_INT_V of register PMC_ETIME120_REG_SB_ECC_ERR_INT_VAL_REG */
    reg_value = etime_reg_SB_ECC_ERR_INT_VAL_REG_read( b_ptr,
                                                       h_ptr);
    value = (reg_value & ETIME120_REG_SB_ECC_ERR_INT_VAL_REG_BIT_RAM_BIT_SB_ECC_INT_V_MSK) >> ETIME120_REG_SB_ECC_ERR_INT_VAL_REG_BIT_RAM_BIT_SB_ECC_INT_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_RAM_BIT_SB_ECC_INT_V_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_RAM_BIT_SB_ECC_INT_V_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_RAM_BIT_SB_ECC_INT_V_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_RAM_BIT_SB_ECC_INT_V_get", stop_bit, start_bit );
    if (stop_bit > 16) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_RAM_BIT_SB_ECC_INT_V_get", stop_bit, 16 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 16) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 16;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000004c bits 16:0) field RAM_BIT_SB_ECC_INT_V of register PMC_ETIME120_REG_SB_ECC_ERR_INT_VAL_REG */
    reg_value = etime_reg_SB_ECC_ERR_INT_VAL_REG_read( b_ptr,
                                                       h_ptr);
    field_value = (reg_value & ETIME120_REG_SB_ECC_ERR_INT_VAL_REG_BIT_RAM_BIT_SB_ECC_INT_V_MSK)
                  >> ETIME120_REG_SB_ECC_ERR_INT_VAL_REG_BIT_RAM_BIT_SB_ECC_INT_V_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_SB_ECC_ERR_INT_VAL_REG_BIT_RAM_BIT_SB_ECC_INT_V_MSK, ETIME120_REG_SB_ECC_ERR_INT_VAL_REG_BIT_RAM_BIT_SB_ECC_INT_V_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_RAM_BIT_SB_ECC_INT_V_get", start_bit, stop_bit, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_RAM_BIT_SB_ECC_INT_V_poll( etime_buffer_t *b_ptr,
                                                                                etime_handle_t *h_ptr,
                                                                                UINT32 start_bit,
                                                                                UINT32 stop_bit,
                                                                                UINT32 value,
                                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                                UINT32 max_count,
                                                                                UINT32 *num_failed_polls,
                                                                                UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_RAM_BIT_SB_ECC_INT_V_poll( etime_buffer_t *b_ptr,
                                                                                etime_handle_t *h_ptr,
                                                                                UINT32 start_bit,
                                                                                UINT32 stop_bit,
                                                                                UINT32 value,
                                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                                UINT32 max_count,
                                                                                UINT32 *num_failed_polls,
                                                                                UINT32 delay_between_polls_in_microseconds )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_RAM_BIT_SB_ECC_INT_V_poll", stop_bit, start_bit );
    if (stop_bit > 16) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_RAM_BIT_SB_ECC_INT_V_poll", stop_bit, 16 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_RAM_BIT_SB_ECC_INT_V_poll", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000004c bits 16:0) field RAM_BIT_SB_ECC_INT_V of register PMC_ETIME120_REG_SB_ECC_ERR_INT_VAL_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_start_bit = 0;
        }
        if (stop_bit < 16) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 16;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000004c bits 16:0) field RAM_BIT_SB_ECC_INT_V of register PMC_ETIME120_REG_SB_ECC_ERR_INT_VAL_REG */
        return etime_reg_SB_ECC_ERR_INT_VAL_REG_poll( b_ptr,
                                                      h_ptr,
                                                      subfield_mask << (ETIME120_REG_SB_ECC_ERR_INT_VAL_REG_BIT_RAM_BIT_SB_ECC_INT_V_OFF + subfield_offset),
                                                      value << (ETIME120_REG_SB_ECC_ERR_INT_VAL_REG_BIT_RAM_BIT_SB_ECC_INT_V_OFF + subfield_offset),
                                                      cmp,
                                                      max_count,
                                                      num_failed_polls,
                                                      delay_between_polls_in_microseconds);
    }
    return PMC_ERR_INVALID_PARAMETERS;
}

static INLINE PMC_POLL_RETURN_TYPE etime_field_RAM_BIT_SB_ECC_INT_V_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_RAM_BIT_SB_ECC_INT_V_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_RAM_BIT_SB_ECC_INT_V_poll", value );

    /* (0x0000004c bits 16:0) field RAM_BIT_SB_ECC_INT_V of register PMC_ETIME120_REG_SB_ECC_ERR_INT_VAL_REG */
    return etime_reg_SB_ECC_ERR_INT_VAL_REG_poll( b_ptr,
                                                  h_ptr,
                                                  ETIME120_REG_SB_ECC_ERR_INT_VAL_REG_BIT_RAM_BIT_SB_ECC_INT_V_MSK,
                                                  (value<<ETIME120_REG_SB_ECC_ERR_INT_VAL_REG_BIT_RAM_BIT_SB_ECC_INT_V_OFF),
                                                  cmp,
                                                  max_count,
                                                  num_failed_polls,
                                                  delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_RAM_BIT_MB_ECC_INT_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_RAM_BIT_MB_ECC_INT_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000050 bits 16:0) field RAM_BIT_MB_ECC_INT_V of register PMC_ETIME120_REG_MB_ECC_ERR_INT_VAL_REG */
    reg_value = etime_reg_MB_ECC_ERR_INT_VAL_REG_read( b_ptr,
                                                       h_ptr);
    value = (reg_value & ETIME120_REG_MB_ECC_ERR_INT_VAL_REG_BIT_RAM_BIT_MB_ECC_INT_V_MSK) >> ETIME120_REG_MB_ECC_ERR_INT_VAL_REG_BIT_RAM_BIT_MB_ECC_INT_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_RAM_BIT_MB_ECC_INT_V_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_RAM_BIT_MB_ECC_INT_V_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_RAM_BIT_MB_ECC_INT_V_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_RAM_BIT_MB_ECC_INT_V_get", stop_bit, start_bit );
    if (stop_bit > 16) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_RAM_BIT_MB_ECC_INT_V_get", stop_bit, 16 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 16) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 16;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000050 bits 16:0) field RAM_BIT_MB_ECC_INT_V of register PMC_ETIME120_REG_MB_ECC_ERR_INT_VAL_REG */
    reg_value = etime_reg_MB_ECC_ERR_INT_VAL_REG_read( b_ptr,
                                                       h_ptr);
    field_value = (reg_value & ETIME120_REG_MB_ECC_ERR_INT_VAL_REG_BIT_RAM_BIT_MB_ECC_INT_V_MSK)
                  >> ETIME120_REG_MB_ECC_ERR_INT_VAL_REG_BIT_RAM_BIT_MB_ECC_INT_V_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_MB_ECC_ERR_INT_VAL_REG_BIT_RAM_BIT_MB_ECC_INT_V_MSK, ETIME120_REG_MB_ECC_ERR_INT_VAL_REG_BIT_RAM_BIT_MB_ECC_INT_V_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_RAM_BIT_MB_ECC_INT_V_get", start_bit, stop_bit, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_RAM_BIT_MB_ECC_INT_V_poll( etime_buffer_t *b_ptr,
                                                                                etime_handle_t *h_ptr,
                                                                                UINT32 start_bit,
                                                                                UINT32 stop_bit,
                                                                                UINT32 value,
                                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                                UINT32 max_count,
                                                                                UINT32 *num_failed_polls,
                                                                                UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_RAM_BIT_MB_ECC_INT_V_poll( etime_buffer_t *b_ptr,
                                                                                etime_handle_t *h_ptr,
                                                                                UINT32 start_bit,
                                                                                UINT32 stop_bit,
                                                                                UINT32 value,
                                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                                UINT32 max_count,
                                                                                UINT32 *num_failed_polls,
                                                                                UINT32 delay_between_polls_in_microseconds )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_RAM_BIT_MB_ECC_INT_V_poll", stop_bit, start_bit );
    if (stop_bit > 16) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_RAM_BIT_MB_ECC_INT_V_poll", stop_bit, 16 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_RAM_BIT_MB_ECC_INT_V_poll", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000050 bits 16:0) field RAM_BIT_MB_ECC_INT_V of register PMC_ETIME120_REG_MB_ECC_ERR_INT_VAL_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_start_bit = 0;
        }
        if (stop_bit < 16) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 16;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000050 bits 16:0) field RAM_BIT_MB_ECC_INT_V of register PMC_ETIME120_REG_MB_ECC_ERR_INT_VAL_REG */
        return etime_reg_MB_ECC_ERR_INT_VAL_REG_poll( b_ptr,
                                                      h_ptr,
                                                      subfield_mask << (ETIME120_REG_MB_ECC_ERR_INT_VAL_REG_BIT_RAM_BIT_MB_ECC_INT_V_OFF + subfield_offset),
                                                      value << (ETIME120_REG_MB_ECC_ERR_INT_VAL_REG_BIT_RAM_BIT_MB_ECC_INT_V_OFF + subfield_offset),
                                                      cmp,
                                                      max_count,
                                                      num_failed_polls,
                                                      delay_between_polls_in_microseconds);
    }
    return PMC_ERR_INVALID_PARAMETERS;
}

static INLINE PMC_POLL_RETURN_TYPE etime_field_RAM_BIT_MB_ECC_INT_V_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_RAM_BIT_MB_ECC_INT_V_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_RAM_BIT_MB_ECC_INT_V_poll", value );

    /* (0x00000050 bits 16:0) field RAM_BIT_MB_ECC_INT_V of register PMC_ETIME120_REG_MB_ECC_ERR_INT_VAL_REG */
    return etime_reg_MB_ECC_ERR_INT_VAL_REG_poll( b_ptr,
                                                  h_ptr,
                                                  ETIME120_REG_MB_ECC_ERR_INT_VAL_REG_BIT_RAM_BIT_MB_ECC_INT_V_MSK,
                                                  (value<<ETIME120_REG_MB_ECC_ERR_INT_VAL_REG_BIT_RAM_BIT_MB_ECC_INT_V_OFF),
                                                  cmp,
                                                  max_count,
                                                  num_failed_polls,
                                                  delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_EXT_RAM_OFLOW_INT_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EXT_RAM_OFLOW_INT_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000054 bits 11:0) field EXT_RAM_OFLOW_INT_V of register PMC_ETIME120_REG_REFL_OFLOW_ERR_INT_VAL_REG */
    reg_value = etime_reg_REFL_OFLOW_ERR_INT_VAL_REG_read( b_ptr,
                                                           h_ptr);
    value = (reg_value & ETIME120_REG_REFL_OFLOW_ERR_INT_VAL_REG_BIT_EXT_RAM_OFLOW_INT_V_MSK) >> ETIME120_REG_REFL_OFLOW_ERR_INT_VAL_REG_BIT_EXT_RAM_OFLOW_INT_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EXT_RAM_OFLOW_INT_V_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_EXT_RAM_OFLOW_INT_V_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_EXT_RAM_OFLOW_INT_V_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_RAM_OFLOW_INT_V_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_RAM_OFLOW_INT_V_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000054 bits 11:0) field EXT_RAM_OFLOW_INT_V of register PMC_ETIME120_REG_REFL_OFLOW_ERR_INT_VAL_REG */
    reg_value = etime_reg_REFL_OFLOW_ERR_INT_VAL_REG_read( b_ptr,
                                                           h_ptr);
    field_value = (reg_value & ETIME120_REG_REFL_OFLOW_ERR_INT_VAL_REG_BIT_EXT_RAM_OFLOW_INT_V_MSK)
                  >> ETIME120_REG_REFL_OFLOW_ERR_INT_VAL_REG_BIT_EXT_RAM_OFLOW_INT_V_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_REFL_OFLOW_ERR_INT_VAL_REG_BIT_EXT_RAM_OFLOW_INT_V_MSK, ETIME120_REG_REFL_OFLOW_ERR_INT_VAL_REG_BIT_EXT_RAM_OFLOW_INT_V_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_RAM_OFLOW_INT_V_get", start_bit, stop_bit, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_EXT_RAM_OFLOW_INT_V_poll( etime_buffer_t *b_ptr,
                                                                               etime_handle_t *h_ptr,
                                                                               UINT32 start_bit,
                                                                               UINT32 stop_bit,
                                                                               UINT32 value,
                                                                               PMC_POLL_COMPARISON_TYPE cmp,
                                                                               UINT32 max_count,
                                                                               UINT32 *num_failed_polls,
                                                                               UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_EXT_RAM_OFLOW_INT_V_poll( etime_buffer_t *b_ptr,
                                                                               etime_handle_t *h_ptr,
                                                                               UINT32 start_bit,
                                                                               UINT32 stop_bit,
                                                                               UINT32 value,
                                                                               PMC_POLL_COMPARISON_TYPE cmp,
                                                                               UINT32 max_count,
                                                                               UINT32 *num_failed_polls,
                                                                               UINT32 delay_between_polls_in_microseconds )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_RAM_OFLOW_INT_V_poll", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_RAM_OFLOW_INT_V_poll", stop_bit, 11 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_RAM_OFLOW_INT_V_poll", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000054 bits 11:0) field EXT_RAM_OFLOW_INT_V of register PMC_ETIME120_REG_REFL_OFLOW_ERR_INT_VAL_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000054 bits 11:0) field EXT_RAM_OFLOW_INT_V of register PMC_ETIME120_REG_REFL_OFLOW_ERR_INT_VAL_REG */
        return etime_reg_REFL_OFLOW_ERR_INT_VAL_REG_poll( b_ptr,
                                                          h_ptr,
                                                          subfield_mask << (ETIME120_REG_REFL_OFLOW_ERR_INT_VAL_REG_BIT_EXT_RAM_OFLOW_INT_V_OFF + subfield_offset),
                                                          value << (ETIME120_REG_REFL_OFLOW_ERR_INT_VAL_REG_BIT_EXT_RAM_OFLOW_INT_V_OFF + subfield_offset),
                                                          cmp,
                                                          max_count,
                                                          num_failed_polls,
                                                          delay_between_polls_in_microseconds);
    }
    return PMC_ERR_INVALID_PARAMETERS;
}

static INLINE PMC_POLL_RETURN_TYPE etime_field_EXT_RAM_OFLOW_INT_V_poll( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_EXT_RAM_OFLOW_INT_V_poll( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_EXT_RAM_OFLOW_INT_V_poll", value );

    /* (0x00000054 bits 11:0) field EXT_RAM_OFLOW_INT_V of register PMC_ETIME120_REG_REFL_OFLOW_ERR_INT_VAL_REG */
    return etime_reg_REFL_OFLOW_ERR_INT_VAL_REG_poll( b_ptr,
                                                      h_ptr,
                                                      ETIME120_REG_REFL_OFLOW_ERR_INT_VAL_REG_BIT_EXT_RAM_OFLOW_INT_V_MSK,
                                                      (value<<ETIME120_REG_REFL_OFLOW_ERR_INT_VAL_REG_BIT_EXT_RAM_OFLOW_INT_V_OFF),
                                                      cmp,
                                                      max_count,
                                                      num_failed_polls,
                                                      delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_TS_RAM_WR_DIS_INT_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TS_RAM_WR_DIS_INT_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000058 bits 23:12) field TS_RAM_WR_DIS_INT_V of register PMC_ETIME120_REG_TS_DIS_INT_VAL_REG */
    reg_value = etime_reg_TS_DIS_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TS_DIS_INT_VAL_REG_BIT_TS_RAM_WR_DIS_INT_V_MSK) >> ETIME120_REG_TS_DIS_INT_VAL_REG_BIT_TS_RAM_WR_DIS_INT_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TS_RAM_WR_DIS_INT_V_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_TS_RAM_WR_DIS_INT_V_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TS_RAM_WR_DIS_INT_V_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TS_RAM_WR_DIS_INT_V_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TS_RAM_WR_DIS_INT_V_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000058 bits 23:12) field TS_RAM_WR_DIS_INT_V of register PMC_ETIME120_REG_TS_DIS_INT_VAL_REG */
    reg_value = etime_reg_TS_DIS_INT_VAL_REG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TS_DIS_INT_VAL_REG_BIT_TS_RAM_WR_DIS_INT_V_MSK)
                  >> ETIME120_REG_TS_DIS_INT_VAL_REG_BIT_TS_RAM_WR_DIS_INT_V_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TS_DIS_INT_VAL_REG_BIT_TS_RAM_WR_DIS_INT_V_MSK, ETIME120_REG_TS_DIS_INT_VAL_REG_BIT_TS_RAM_WR_DIS_INT_V_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TS_RAM_WR_DIS_INT_V_get", start_bit, stop_bit, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_TS_RAM_WR_DIS_INT_V_poll( etime_buffer_t *b_ptr,
                                                                               etime_handle_t *h_ptr,
                                                                               UINT32 start_bit,
                                                                               UINT32 stop_bit,
                                                                               UINT32 value,
                                                                               PMC_POLL_COMPARISON_TYPE cmp,
                                                                               UINT32 max_count,
                                                                               UINT32 *num_failed_polls,
                                                                               UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_TS_RAM_WR_DIS_INT_V_poll( etime_buffer_t *b_ptr,
                                                                               etime_handle_t *h_ptr,
                                                                               UINT32 start_bit,
                                                                               UINT32 stop_bit,
                                                                               UINT32 value,
                                                                               PMC_POLL_COMPARISON_TYPE cmp,
                                                                               UINT32 max_count,
                                                                               UINT32 *num_failed_polls,
                                                                               UINT32 delay_between_polls_in_microseconds )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TS_RAM_WR_DIS_INT_V_poll", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TS_RAM_WR_DIS_INT_V_poll", stop_bit, 11 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TS_RAM_WR_DIS_INT_V_poll", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000058 bits 23:12) field TS_RAM_WR_DIS_INT_V of register PMC_ETIME120_REG_TS_DIS_INT_VAL_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000058 bits 23:12) field TS_RAM_WR_DIS_INT_V of register PMC_ETIME120_REG_TS_DIS_INT_VAL_REG */
        return etime_reg_TS_DIS_INT_VAL_REG_poll( b_ptr,
                                                  h_ptr,
                                                  subfield_mask << (ETIME120_REG_TS_DIS_INT_VAL_REG_BIT_TS_RAM_WR_DIS_INT_V_OFF + subfield_offset),
                                                  value << (ETIME120_REG_TS_DIS_INT_VAL_REG_BIT_TS_RAM_WR_DIS_INT_V_OFF + subfield_offset),
                                                  cmp,
                                                  max_count,
                                                  num_failed_polls,
                                                  delay_between_polls_in_microseconds);
    }
    return PMC_ERR_INVALID_PARAMETERS;
}

static INLINE PMC_POLL_RETURN_TYPE etime_field_TS_RAM_WR_DIS_INT_V_poll( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_TS_RAM_WR_DIS_INT_V_poll( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_TS_RAM_WR_DIS_INT_V_poll", value );

    /* (0x00000058 bits 23:12) field TS_RAM_WR_DIS_INT_V of register PMC_ETIME120_REG_TS_DIS_INT_VAL_REG */
    return etime_reg_TS_DIS_INT_VAL_REG_poll( b_ptr,
                                              h_ptr,
                                              ETIME120_REG_TS_DIS_INT_VAL_REG_BIT_TS_RAM_WR_DIS_INT_V_MSK,
                                              (value<<ETIME120_REG_TS_DIS_INT_VAL_REG_BIT_TS_RAM_WR_DIS_INT_V_OFF),
                                              cmp,
                                              max_count,
                                              num_failed_polls,
                                              delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_TS_RAM_RD_DIS_INT_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TS_RAM_RD_DIS_INT_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000058 bits 11:0) field TS_RAM_RD_DIS_INT_V of register PMC_ETIME120_REG_TS_DIS_INT_VAL_REG */
    reg_value = etime_reg_TS_DIS_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_TS_DIS_INT_VAL_REG_BIT_TS_RAM_RD_DIS_INT_V_MSK) >> ETIME120_REG_TS_DIS_INT_VAL_REG_BIT_TS_RAM_RD_DIS_INT_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TS_RAM_RD_DIS_INT_V_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_TS_RAM_RD_DIS_INT_V_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TS_RAM_RD_DIS_INT_V_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TS_RAM_RD_DIS_INT_V_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TS_RAM_RD_DIS_INT_V_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000058 bits 11:0) field TS_RAM_RD_DIS_INT_V of register PMC_ETIME120_REG_TS_DIS_INT_VAL_REG */
    reg_value = etime_reg_TS_DIS_INT_VAL_REG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_TS_DIS_INT_VAL_REG_BIT_TS_RAM_RD_DIS_INT_V_MSK)
                  >> ETIME120_REG_TS_DIS_INT_VAL_REG_BIT_TS_RAM_RD_DIS_INT_V_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TS_DIS_INT_VAL_REG_BIT_TS_RAM_RD_DIS_INT_V_MSK, ETIME120_REG_TS_DIS_INT_VAL_REG_BIT_TS_RAM_RD_DIS_INT_V_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TS_RAM_RD_DIS_INT_V_get", start_bit, stop_bit, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_TS_RAM_RD_DIS_INT_V_poll( etime_buffer_t *b_ptr,
                                                                               etime_handle_t *h_ptr,
                                                                               UINT32 start_bit,
                                                                               UINT32 stop_bit,
                                                                               UINT32 value,
                                                                               PMC_POLL_COMPARISON_TYPE cmp,
                                                                               UINT32 max_count,
                                                                               UINT32 *num_failed_polls,
                                                                               UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_TS_RAM_RD_DIS_INT_V_poll( etime_buffer_t *b_ptr,
                                                                               etime_handle_t *h_ptr,
                                                                               UINT32 start_bit,
                                                                               UINT32 stop_bit,
                                                                               UINT32 value,
                                                                               PMC_POLL_COMPARISON_TYPE cmp,
                                                                               UINT32 max_count,
                                                                               UINT32 *num_failed_polls,
                                                                               UINT32 delay_between_polls_in_microseconds )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TS_RAM_RD_DIS_INT_V_poll", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TS_RAM_RD_DIS_INT_V_poll", stop_bit, 11 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TS_RAM_RD_DIS_INT_V_poll", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000058 bits 11:0) field TS_RAM_RD_DIS_INT_V of register PMC_ETIME120_REG_TS_DIS_INT_VAL_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000058 bits 11:0) field TS_RAM_RD_DIS_INT_V of register PMC_ETIME120_REG_TS_DIS_INT_VAL_REG */
        return etime_reg_TS_DIS_INT_VAL_REG_poll( b_ptr,
                                                  h_ptr,
                                                  subfield_mask << (ETIME120_REG_TS_DIS_INT_VAL_REG_BIT_TS_RAM_RD_DIS_INT_V_OFF + subfield_offset),
                                                  value << (ETIME120_REG_TS_DIS_INT_VAL_REG_BIT_TS_RAM_RD_DIS_INT_V_OFF + subfield_offset),
                                                  cmp,
                                                  max_count,
                                                  num_failed_polls,
                                                  delay_between_polls_in_microseconds);
    }
    return PMC_ERR_INVALID_PARAMETERS;
}

static INLINE PMC_POLL_RETURN_TYPE etime_field_TS_RAM_RD_DIS_INT_V_poll( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_TS_RAM_RD_DIS_INT_V_poll( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_TS_RAM_RD_DIS_INT_V_poll", value );

    /* (0x00000058 bits 11:0) field TS_RAM_RD_DIS_INT_V of register PMC_ETIME120_REG_TS_DIS_INT_VAL_REG */
    return etime_reg_TS_DIS_INT_VAL_REG_poll( b_ptr,
                                              h_ptr,
                                              ETIME120_REG_TS_DIS_INT_VAL_REG_BIT_TS_RAM_RD_DIS_INT_V_MSK,
                                              (value<<ETIME120_REG_TS_DIS_INT_VAL_REG_BIT_TS_RAM_RD_DIS_INT_V_OFF),
                                              cmp,
                                              max_count,
                                              num_failed_polls,
                                              delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_PACKET_RAM_WR_DIS_INT_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_PACKET_RAM_WR_DIS_INT_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000005c bits 23:12) field PACKET_RAM_WR_DIS_INT_V of register PMC_ETIME120_REG_PACKET_DIS_INT_VAL_REG */
    reg_value = etime_reg_PACKET_DIS_INT_VAL_REG_read( b_ptr,
                                                       h_ptr);
    value = (reg_value & ETIME120_REG_PACKET_DIS_INT_VAL_REG_BIT_PACKET_RAM_WR_DIS_INT_V_MSK) >> ETIME120_REG_PACKET_DIS_INT_VAL_REG_BIT_PACKET_RAM_WR_DIS_INT_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_PACKET_RAM_WR_DIS_INT_V_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_PACKET_RAM_WR_DIS_INT_V_get( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_PACKET_RAM_WR_DIS_INT_V_get( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_PACKET_RAM_WR_DIS_INT_V_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_PACKET_RAM_WR_DIS_INT_V_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000005c bits 23:12) field PACKET_RAM_WR_DIS_INT_V of register PMC_ETIME120_REG_PACKET_DIS_INT_VAL_REG */
    reg_value = etime_reg_PACKET_DIS_INT_VAL_REG_read( b_ptr,
                                                       h_ptr);
    field_value = (reg_value & ETIME120_REG_PACKET_DIS_INT_VAL_REG_BIT_PACKET_RAM_WR_DIS_INT_V_MSK)
                  >> ETIME120_REG_PACKET_DIS_INT_VAL_REG_BIT_PACKET_RAM_WR_DIS_INT_V_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_PACKET_DIS_INT_VAL_REG_BIT_PACKET_RAM_WR_DIS_INT_V_MSK, ETIME120_REG_PACKET_DIS_INT_VAL_REG_BIT_PACKET_RAM_WR_DIS_INT_V_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_PACKET_RAM_WR_DIS_INT_V_get", start_bit, stop_bit, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_PACKET_RAM_WR_DIS_INT_V_poll( etime_buffer_t *b_ptr,
                                                                                   etime_handle_t *h_ptr,
                                                                                   UINT32 start_bit,
                                                                                   UINT32 stop_bit,
                                                                                   UINT32 value,
                                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                                   UINT32 max_count,
                                                                                   UINT32 *num_failed_polls,
                                                                                   UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_PACKET_RAM_WR_DIS_INT_V_poll( etime_buffer_t *b_ptr,
                                                                                   etime_handle_t *h_ptr,
                                                                                   UINT32 start_bit,
                                                                                   UINT32 stop_bit,
                                                                                   UINT32 value,
                                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                                   UINT32 max_count,
                                                                                   UINT32 *num_failed_polls,
                                                                                   UINT32 delay_between_polls_in_microseconds )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_PACKET_RAM_WR_DIS_INT_V_poll", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_PACKET_RAM_WR_DIS_INT_V_poll", stop_bit, 11 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_PACKET_RAM_WR_DIS_INT_V_poll", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000005c bits 23:12) field PACKET_RAM_WR_DIS_INT_V of register PMC_ETIME120_REG_PACKET_DIS_INT_VAL_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000005c bits 23:12) field PACKET_RAM_WR_DIS_INT_V of register PMC_ETIME120_REG_PACKET_DIS_INT_VAL_REG */
        return etime_reg_PACKET_DIS_INT_VAL_REG_poll( b_ptr,
                                                      h_ptr,
                                                      subfield_mask << (ETIME120_REG_PACKET_DIS_INT_VAL_REG_BIT_PACKET_RAM_WR_DIS_INT_V_OFF + subfield_offset),
                                                      value << (ETIME120_REG_PACKET_DIS_INT_VAL_REG_BIT_PACKET_RAM_WR_DIS_INT_V_OFF + subfield_offset),
                                                      cmp,
                                                      max_count,
                                                      num_failed_polls,
                                                      delay_between_polls_in_microseconds);
    }
    return PMC_ERR_INVALID_PARAMETERS;
}

static INLINE PMC_POLL_RETURN_TYPE etime_field_PACKET_RAM_WR_DIS_INT_V_poll( etime_buffer_t *b_ptr,
                                                                             etime_handle_t *h_ptr,
                                                                             UINT32 value,
                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                             UINT32 max_count,
                                                                             UINT32 *num_failed_polls,
                                                                             UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_PACKET_RAM_WR_DIS_INT_V_poll( etime_buffer_t *b_ptr,
                                                                             etime_handle_t *h_ptr,
                                                                             UINT32 value,
                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                             UINT32 max_count,
                                                                             UINT32 *num_failed_polls,
                                                                             UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_PACKET_RAM_WR_DIS_INT_V_poll", value );

    /* (0x0000005c bits 23:12) field PACKET_RAM_WR_DIS_INT_V of register PMC_ETIME120_REG_PACKET_DIS_INT_VAL_REG */
    return etime_reg_PACKET_DIS_INT_VAL_REG_poll( b_ptr,
                                                  h_ptr,
                                                  ETIME120_REG_PACKET_DIS_INT_VAL_REG_BIT_PACKET_RAM_WR_DIS_INT_V_MSK,
                                                  (value<<ETIME120_REG_PACKET_DIS_INT_VAL_REG_BIT_PACKET_RAM_WR_DIS_INT_V_OFF),
                                                  cmp,
                                                  max_count,
                                                  num_failed_polls,
                                                  delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_PACKET_RAM_RD_DIS_INT_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_PACKET_RAM_RD_DIS_INT_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000005c bits 11:0) field PACKET_RAM_RD_DIS_INT_V of register PMC_ETIME120_REG_PACKET_DIS_INT_VAL_REG */
    reg_value = etime_reg_PACKET_DIS_INT_VAL_REG_read( b_ptr,
                                                       h_ptr);
    value = (reg_value & ETIME120_REG_PACKET_DIS_INT_VAL_REG_BIT_PACKET_RAM_RD_DIS_INT_V_MSK) >> ETIME120_REG_PACKET_DIS_INT_VAL_REG_BIT_PACKET_RAM_RD_DIS_INT_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_PACKET_RAM_RD_DIS_INT_V_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_PACKET_RAM_RD_DIS_INT_V_get( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_PACKET_RAM_RD_DIS_INT_V_get( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_PACKET_RAM_RD_DIS_INT_V_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_PACKET_RAM_RD_DIS_INT_V_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000005c bits 11:0) field PACKET_RAM_RD_DIS_INT_V of register PMC_ETIME120_REG_PACKET_DIS_INT_VAL_REG */
    reg_value = etime_reg_PACKET_DIS_INT_VAL_REG_read( b_ptr,
                                                       h_ptr);
    field_value = (reg_value & ETIME120_REG_PACKET_DIS_INT_VAL_REG_BIT_PACKET_RAM_RD_DIS_INT_V_MSK)
                  >> ETIME120_REG_PACKET_DIS_INT_VAL_REG_BIT_PACKET_RAM_RD_DIS_INT_V_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_PACKET_DIS_INT_VAL_REG_BIT_PACKET_RAM_RD_DIS_INT_V_MSK, ETIME120_REG_PACKET_DIS_INT_VAL_REG_BIT_PACKET_RAM_RD_DIS_INT_V_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_PACKET_RAM_RD_DIS_INT_V_get", start_bit, stop_bit, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_PACKET_RAM_RD_DIS_INT_V_poll( etime_buffer_t *b_ptr,
                                                                                   etime_handle_t *h_ptr,
                                                                                   UINT32 start_bit,
                                                                                   UINT32 stop_bit,
                                                                                   UINT32 value,
                                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                                   UINT32 max_count,
                                                                                   UINT32 *num_failed_polls,
                                                                                   UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_PACKET_RAM_RD_DIS_INT_V_poll( etime_buffer_t *b_ptr,
                                                                                   etime_handle_t *h_ptr,
                                                                                   UINT32 start_bit,
                                                                                   UINT32 stop_bit,
                                                                                   UINT32 value,
                                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                                   UINT32 max_count,
                                                                                   UINT32 *num_failed_polls,
                                                                                   UINT32 delay_between_polls_in_microseconds )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_PACKET_RAM_RD_DIS_INT_V_poll", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_PACKET_RAM_RD_DIS_INT_V_poll", stop_bit, 11 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_PACKET_RAM_RD_DIS_INT_V_poll", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000005c bits 11:0) field PACKET_RAM_RD_DIS_INT_V of register PMC_ETIME120_REG_PACKET_DIS_INT_VAL_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000005c bits 11:0) field PACKET_RAM_RD_DIS_INT_V of register PMC_ETIME120_REG_PACKET_DIS_INT_VAL_REG */
        return etime_reg_PACKET_DIS_INT_VAL_REG_poll( b_ptr,
                                                      h_ptr,
                                                      subfield_mask << (ETIME120_REG_PACKET_DIS_INT_VAL_REG_BIT_PACKET_RAM_RD_DIS_INT_V_OFF + subfield_offset),
                                                      value << (ETIME120_REG_PACKET_DIS_INT_VAL_REG_BIT_PACKET_RAM_RD_DIS_INT_V_OFF + subfield_offset),
                                                      cmp,
                                                      max_count,
                                                      num_failed_polls,
                                                      delay_between_polls_in_microseconds);
    }
    return PMC_ERR_INVALID_PARAMETERS;
}

static INLINE PMC_POLL_RETURN_TYPE etime_field_PACKET_RAM_RD_DIS_INT_V_poll( etime_buffer_t *b_ptr,
                                                                             etime_handle_t *h_ptr,
                                                                             UINT32 value,
                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                             UINT32 max_count,
                                                                             UINT32 *num_failed_polls,
                                                                             UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_PACKET_RAM_RD_DIS_INT_V_poll( etime_buffer_t *b_ptr,
                                                                             etime_handle_t *h_ptr,
                                                                             UINT32 value,
                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                             UINT32 max_count,
                                                                             UINT32 *num_failed_polls,
                                                                             UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_PACKET_RAM_RD_DIS_INT_V_poll", value );

    /* (0x0000005c bits 11:0) field PACKET_RAM_RD_DIS_INT_V of register PMC_ETIME120_REG_PACKET_DIS_INT_VAL_REG */
    return etime_reg_PACKET_DIS_INT_VAL_REG_poll( b_ptr,
                                                  h_ptr,
                                                  ETIME120_REG_PACKET_DIS_INT_VAL_REG_BIT_PACKET_RAM_RD_DIS_INT_V_MSK,
                                                  (value<<ETIME120_REG_PACKET_DIS_INT_VAL_REG_BIT_PACKET_RAM_RD_DIS_INT_V_OFF),
                                                  cmp,
                                                  max_count,
                                                  num_failed_polls,
                                                  delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_PACKET_RAM_OSIZE_INT_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_PACKET_RAM_OSIZE_INT_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000060 bits 11:0) field PACKET_RAM_OSIZE_INT_V of register PMC_ETIME120_REG_PACKET_RAM_ERR_INT_VAL_REG */
    reg_value = etime_reg_PACKET_RAM_ERR_INT_VAL_REG_read( b_ptr,
                                                           h_ptr);
    value = (reg_value & ETIME120_REG_PACKET_RAM_ERR_INT_VAL_REG_BIT_PACKET_RAM_OSIZE_INT_V_MSK) >> ETIME120_REG_PACKET_RAM_ERR_INT_VAL_REG_BIT_PACKET_RAM_OSIZE_INT_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_PACKET_RAM_OSIZE_INT_V_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_PACKET_RAM_OSIZE_INT_V_get( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_PACKET_RAM_OSIZE_INT_V_get( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_PACKET_RAM_OSIZE_INT_V_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_PACKET_RAM_OSIZE_INT_V_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000060 bits 11:0) field PACKET_RAM_OSIZE_INT_V of register PMC_ETIME120_REG_PACKET_RAM_ERR_INT_VAL_REG */
    reg_value = etime_reg_PACKET_RAM_ERR_INT_VAL_REG_read( b_ptr,
                                                           h_ptr);
    field_value = (reg_value & ETIME120_REG_PACKET_RAM_ERR_INT_VAL_REG_BIT_PACKET_RAM_OSIZE_INT_V_MSK)
                  >> ETIME120_REG_PACKET_RAM_ERR_INT_VAL_REG_BIT_PACKET_RAM_OSIZE_INT_V_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_PACKET_RAM_ERR_INT_VAL_REG_BIT_PACKET_RAM_OSIZE_INT_V_MSK, ETIME120_REG_PACKET_RAM_ERR_INT_VAL_REG_BIT_PACKET_RAM_OSIZE_INT_V_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_PACKET_RAM_OSIZE_INT_V_get", start_bit, stop_bit, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_PACKET_RAM_OSIZE_INT_V_poll( etime_buffer_t *b_ptr,
                                                                                  etime_handle_t *h_ptr,
                                                                                  UINT32 start_bit,
                                                                                  UINT32 stop_bit,
                                                                                  UINT32 value,
                                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                                  UINT32 max_count,
                                                                                  UINT32 *num_failed_polls,
                                                                                  UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_PACKET_RAM_OSIZE_INT_V_poll( etime_buffer_t *b_ptr,
                                                                                  etime_handle_t *h_ptr,
                                                                                  UINT32 start_bit,
                                                                                  UINT32 stop_bit,
                                                                                  UINT32 value,
                                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                                  UINT32 max_count,
                                                                                  UINT32 *num_failed_polls,
                                                                                  UINT32 delay_between_polls_in_microseconds )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_PACKET_RAM_OSIZE_INT_V_poll", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_PACKET_RAM_OSIZE_INT_V_poll", stop_bit, 11 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_PACKET_RAM_OSIZE_INT_V_poll", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000060 bits 11:0) field PACKET_RAM_OSIZE_INT_V of register PMC_ETIME120_REG_PACKET_RAM_ERR_INT_VAL_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000060 bits 11:0) field PACKET_RAM_OSIZE_INT_V of register PMC_ETIME120_REG_PACKET_RAM_ERR_INT_VAL_REG */
        return etime_reg_PACKET_RAM_ERR_INT_VAL_REG_poll( b_ptr,
                                                          h_ptr,
                                                          subfield_mask << (ETIME120_REG_PACKET_RAM_ERR_INT_VAL_REG_BIT_PACKET_RAM_OSIZE_INT_V_OFF + subfield_offset),
                                                          value << (ETIME120_REG_PACKET_RAM_ERR_INT_VAL_REG_BIT_PACKET_RAM_OSIZE_INT_V_OFF + subfield_offset),
                                                          cmp,
                                                          max_count,
                                                          num_failed_polls,
                                                          delay_between_polls_in_microseconds);
    }
    return PMC_ERR_INVALID_PARAMETERS;
}

static INLINE PMC_POLL_RETURN_TYPE etime_field_PACKET_RAM_OSIZE_INT_V_poll( etime_buffer_t *b_ptr,
                                                                            etime_handle_t *h_ptr,
                                                                            UINT32 value,
                                                                            PMC_POLL_COMPARISON_TYPE cmp,
                                                                            UINT32 max_count,
                                                                            UINT32 *num_failed_polls,
                                                                            UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_PACKET_RAM_OSIZE_INT_V_poll( etime_buffer_t *b_ptr,
                                                                            etime_handle_t *h_ptr,
                                                                            UINT32 value,
                                                                            PMC_POLL_COMPARISON_TYPE cmp,
                                                                            UINT32 max_count,
                                                                            UINT32 *num_failed_polls,
                                                                            UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_PACKET_RAM_OSIZE_INT_V_poll", value );

    /* (0x00000060 bits 11:0) field PACKET_RAM_OSIZE_INT_V of register PMC_ETIME120_REG_PACKET_RAM_ERR_INT_VAL_REG */
    return etime_reg_PACKET_RAM_ERR_INT_VAL_REG_poll( b_ptr,
                                                      h_ptr,
                                                      ETIME120_REG_PACKET_RAM_ERR_INT_VAL_REG_BIT_PACKET_RAM_OSIZE_INT_V_MSK,
                                                      (value<<ETIME120_REG_PACKET_RAM_ERR_INT_VAL_REG_BIT_PACKET_RAM_OSIZE_INT_V_OFF),
                                                      cmp,
                                                      max_count,
                                                      num_failed_polls,
                                                      delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_EXT_DESYNC_INT_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_EXT_DESYNC_INT_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000064 bits 11:0) field EXT_DESYNC_INT_V of register PMC_ETIME120_REG_EXT_DESYNC_ERR_INT_VAL_REG */
    reg_value = etime_reg_EXT_DESYNC_ERR_INT_VAL_REG_read( b_ptr,
                                                           h_ptr);
    value = (reg_value & ETIME120_REG_EXT_DESYNC_ERR_INT_VAL_REG_BIT_EXT_DESYNC_INT_V_MSK) >> ETIME120_REG_EXT_DESYNC_ERR_INT_VAL_REG_BIT_EXT_DESYNC_INT_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_EXT_DESYNC_INT_V_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_EXT_DESYNC_INT_V_get( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_EXT_DESYNC_INT_V_get( etime_buffer_t *b_ptr,
                                                             etime_handle_t *h_ptr,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_DESYNC_INT_V_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_DESYNC_INT_V_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000064 bits 11:0) field EXT_DESYNC_INT_V of register PMC_ETIME120_REG_EXT_DESYNC_ERR_INT_VAL_REG */
    reg_value = etime_reg_EXT_DESYNC_ERR_INT_VAL_REG_read( b_ptr,
                                                           h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_DESYNC_ERR_INT_VAL_REG_BIT_EXT_DESYNC_INT_V_MSK)
                  >> ETIME120_REG_EXT_DESYNC_ERR_INT_VAL_REG_BIT_EXT_DESYNC_INT_V_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_DESYNC_ERR_INT_VAL_REG_BIT_EXT_DESYNC_INT_V_MSK, ETIME120_REG_EXT_DESYNC_ERR_INT_VAL_REG_BIT_EXT_DESYNC_INT_V_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_DESYNC_INT_V_get", start_bit, stop_bit, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_EXT_DESYNC_INT_V_poll( etime_buffer_t *b_ptr,
                                                                            etime_handle_t *h_ptr,
                                                                            UINT32 start_bit,
                                                                            UINT32 stop_bit,
                                                                            UINT32 value,
                                                                            PMC_POLL_COMPARISON_TYPE cmp,
                                                                            UINT32 max_count,
                                                                            UINT32 *num_failed_polls,
                                                                            UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_range_EXT_DESYNC_INT_V_poll( etime_buffer_t *b_ptr,
                                                                            etime_handle_t *h_ptr,
                                                                            UINT32 start_bit,
                                                                            UINT32 stop_bit,
                                                                            UINT32 value,
                                                                            PMC_POLL_COMPARISON_TYPE cmp,
                                                                            UINT32 max_count,
                                                                            UINT32 *num_failed_polls,
                                                                            UINT32 delay_between_polls_in_microseconds )
{
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_EXT_DESYNC_INT_V_poll", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_EXT_DESYNC_INT_V_poll", stop_bit, 11 );
    IOLOG( "%s <= start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_EXT_DESYNC_INT_V_poll", start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000064 bits 11:0) field EXT_DESYNC_INT_V of register PMC_ETIME120_REG_EXT_DESYNC_ERR_INT_VAL_REG */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000064 bits 11:0) field EXT_DESYNC_INT_V of register PMC_ETIME120_REG_EXT_DESYNC_ERR_INT_VAL_REG */
        return etime_reg_EXT_DESYNC_ERR_INT_VAL_REG_poll( b_ptr,
                                                          h_ptr,
                                                          subfield_mask << (ETIME120_REG_EXT_DESYNC_ERR_INT_VAL_REG_BIT_EXT_DESYNC_INT_V_OFF + subfield_offset),
                                                          value << (ETIME120_REG_EXT_DESYNC_ERR_INT_VAL_REG_BIT_EXT_DESYNC_INT_V_OFF + subfield_offset),
                                                          cmp,
                                                          max_count,
                                                          num_failed_polls,
                                                          delay_between_polls_in_microseconds);
    }
    return PMC_ERR_INVALID_PARAMETERS;
}

static INLINE PMC_POLL_RETURN_TYPE etime_field_EXT_DESYNC_INT_V_poll( etime_buffer_t *b_ptr,
                                                                      etime_handle_t *h_ptr,
                                                                      UINT32 value,
                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                      UINT32 max_count,
                                                                      UINT32 *num_failed_polls,
                                                                      UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_EXT_DESYNC_INT_V_poll( etime_buffer_t *b_ptr,
                                                                      etime_handle_t *h_ptr,
                                                                      UINT32 value,
                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                      UINT32 max_count,
                                                                      UINT32 *num_failed_polls,
                                                                      UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_EXT_DESYNC_INT_V_poll", value );

    /* (0x00000064 bits 11:0) field EXT_DESYNC_INT_V of register PMC_ETIME120_REG_EXT_DESYNC_ERR_INT_VAL_REG */
    return etime_reg_EXT_DESYNC_ERR_INT_VAL_REG_poll( b_ptr,
                                                      h_ptr,
                                                      ETIME120_REG_EXT_DESYNC_ERR_INT_VAL_REG_BIT_EXT_DESYNC_INT_V_MSK,
                                                      (value<<ETIME120_REG_EXT_DESYNC_ERR_INT_VAL_REG_BIT_EXT_DESYNC_INT_V_OFF),
                                                      cmp,
                                                      max_count,
                                                      num_failed_polls,
                                                      delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_ILLEGAL_1STEP_INT_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_ILLEGAL_1STEP_INT_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000068 bits 27) field ILLEGAL_1STEP_INT_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    reg_value = etime_reg_GP_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_VAL_REG_BIT_ILLEGAL_1STEP_INT_V_MSK) >> ETIME120_REG_GP_INT_VAL_REG_BIT_ILLEGAL_1STEP_INT_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_ILLEGAL_1STEP_INT_V_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_ILLEGAL_1STEP_INT_V_poll( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_ILLEGAL_1STEP_INT_V_poll( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_ILLEGAL_1STEP_INT_V_poll", value );

    /* (0x00000068 bits 27) field ILLEGAL_1STEP_INT_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    return etime_reg_GP_INT_VAL_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_GP_INT_VAL_REG_BIT_ILLEGAL_1STEP_INT_V_MSK,
                                          (value<<ETIME120_REG_GP_INT_VAL_REG_BIT_ILLEGAL_1STEP_INT_V_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_LINE_REF_CPTR_EVNT_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_LINE_REF_CPTR_EVNT_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000068 bits 26) field LINE_REF_CPTR_EVNT_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    reg_value = etime_reg_GP_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_VAL_REG_BIT_LINE_REF_CPTR_EVNT_V_MSK) >> ETIME120_REG_GP_INT_VAL_REG_BIT_LINE_REF_CPTR_EVNT_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_LINE_REF_CPTR_EVNT_V_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_LINE_REF_CPTR_EVNT_V_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_LINE_REF_CPTR_EVNT_V_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_LINE_REF_CPTR_EVNT_V_poll", value );

    /* (0x00000068 bits 26) field LINE_REF_CPTR_EVNT_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    return etime_reg_GP_INT_VAL_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_GP_INT_VAL_REG_BIT_LINE_REF_CPTR_EVNT_V_MSK,
                                          (value<<ETIME120_REG_GP_INT_VAL_REG_BIT_LINE_REF_CPTR_EVNT_V_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_IRIGO_TS_CPTR_EVNT_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGO_TS_CPTR_EVNT_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000068 bits 25) field IRIGO_TS_CPTR_EVNT_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    reg_value = etime_reg_GP_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGO_TS_CPTR_EVNT_V_MSK) >> ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGO_TS_CPTR_EVNT_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGO_TS_CPTR_EVNT_V_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGO_TS_CPTR_EVNT_V_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGO_TS_CPTR_EVNT_V_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_IRIGO_TS_CPTR_EVNT_V_poll", value );

    /* (0x00000068 bits 25) field IRIGO_TS_CPTR_EVNT_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    return etime_reg_GP_INT_VAL_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGO_TS_CPTR_EVNT_V_MSK,
                                          (value<<ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGO_TS_CPTR_EVNT_V_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_IRIGO_ONE_PPSO_REALIGN_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGO_ONE_PPSO_REALIGN_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000068 bits 24) field IRIGO_ONE_PPSO_REALIGN_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    reg_value = etime_reg_GP_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGO_ONE_PPSO_REALIGN_V_MSK) >> ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGO_ONE_PPSO_REALIGN_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGO_ONE_PPSO_REALIGN_V_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGO_ONE_PPSO_REALIGN_V_poll( etime_buffer_t *b_ptr,
                                                                              etime_handle_t *h_ptr,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGO_ONE_PPSO_REALIGN_V_poll( etime_buffer_t *b_ptr,
                                                                              etime_handle_t *h_ptr,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_IRIGO_ONE_PPSO_REALIGN_V_poll", value );

    /* (0x00000068 bits 24) field IRIGO_ONE_PPSO_REALIGN_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    return etime_reg_GP_INT_VAL_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGO_ONE_PPSO_REALIGN_V_MSK,
                                          (value<<ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGO_ONE_PPSO_REALIGN_V_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_IRIGO_TX_DAT_VAL_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGO_TX_DAT_VAL_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000068 bits 23) field IRIGO_TX_DAT_VAL_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    reg_value = etime_reg_GP_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGO_TX_DAT_VAL_V_MSK) >> ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGO_TX_DAT_VAL_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGO_TX_DAT_VAL_V_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGO_TX_DAT_VAL_V_poll( etime_buffer_t *b_ptr,
                                                                        etime_handle_t *h_ptr,
                                                                        UINT32 value,
                                                                        PMC_POLL_COMPARISON_TYPE cmp,
                                                                        UINT32 max_count,
                                                                        UINT32 *num_failed_polls,
                                                                        UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGO_TX_DAT_VAL_V_poll( etime_buffer_t *b_ptr,
                                                                        etime_handle_t *h_ptr,
                                                                        UINT32 value,
                                                                        PMC_POLL_COMPARISON_TYPE cmp,
                                                                        UINT32 max_count,
                                                                        UINT32 *num_failed_polls,
                                                                        UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_IRIGO_TX_DAT_VAL_V_poll", value );

    /* (0x00000068 bits 23) field IRIGO_TX_DAT_VAL_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    return etime_reg_GP_INT_VAL_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGO_TX_DAT_VAL_V_MSK,
                                          (value<<ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGO_TX_DAT_VAL_V_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_PTP_DCSU_TSTMPR_CPTR_EVNT_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_PTP_DCSU_TSTMPR_CPTR_EVNT_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000068 bits 22) field PTP_DCSU_TSTMPR_CPTR_EVNT_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    reg_value = etime_reg_GP_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_VAL_REG_BIT_PTP_DCSU_TSTMPR_CPTR_EVNT_V_MSK) >> ETIME120_REG_GP_INT_VAL_REG_BIT_PTP_DCSU_TSTMPR_CPTR_EVNT_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_PTP_DCSU_TSTMPR_CPTR_EVNT_V_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_PTP_DCSU_TSTMPR_CPTR_EVNT_V_poll( etime_buffer_t *b_ptr,
                                                                                 etime_handle_t *h_ptr,
                                                                                 UINT32 value,
                                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                                 UINT32 max_count,
                                                                                 UINT32 *num_failed_polls,
                                                                                 UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_PTP_DCSU_TSTMPR_CPTR_EVNT_V_poll( etime_buffer_t *b_ptr,
                                                                                 etime_handle_t *h_ptr,
                                                                                 UINT32 value,
                                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                                 UINT32 max_count,
                                                                                 UINT32 *num_failed_polls,
                                                                                 UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_PTP_DCSU_TSTMPR_CPTR_EVNT_V_poll", value );

    /* (0x00000068 bits 22) field PTP_DCSU_TSTMPR_CPTR_EVNT_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    return etime_reg_GP_INT_VAL_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_GP_INT_VAL_REG_BIT_PTP_DCSU_TSTMPR_CPTR_EVNT_V_MSK,
                                          (value<<ETIME120_REG_GP_INT_VAL_REG_BIT_PTP_DCSU_TSTMPR_CPTR_EVNT_V_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_IRIGI_TS_CPTR_EVNT_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_TS_CPTR_EVNT_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000068 bits 21) field IRIGI_TS_CPTR_EVNT_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    reg_value = etime_reg_GP_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGI_TS_CPTR_EVNT_V_MSK) >> ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGI_TS_CPTR_EVNT_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_TS_CPTR_EVNT_V_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGI_TS_CPTR_EVNT_V_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGI_TS_CPTR_EVNT_V_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_IRIGI_TS_CPTR_EVNT_V_poll", value );

    /* (0x00000068 bits 21) field IRIGI_TS_CPTR_EVNT_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    return etime_reg_GP_INT_VAL_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGI_TS_CPTR_EVNT_V_MSK,
                                          (value<<ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGI_TS_CPTR_EVNT_V_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_IRIGI_RX_DAT_VAL_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_RX_DAT_VAL_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000068 bits 20) field IRIGI_RX_DAT_VAL_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    reg_value = etime_reg_GP_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGI_RX_DAT_VAL_V_MSK) >> ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGI_RX_DAT_VAL_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_RX_DAT_VAL_V_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGI_RX_DAT_VAL_V_poll( etime_buffer_t *b_ptr,
                                                                        etime_handle_t *h_ptr,
                                                                        UINT32 value,
                                                                        PMC_POLL_COMPARISON_TYPE cmp,
                                                                        UINT32 max_count,
                                                                        UINT32 *num_failed_polls,
                                                                        UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGI_RX_DAT_VAL_V_poll( etime_buffer_t *b_ptr,
                                                                        etime_handle_t *h_ptr,
                                                                        UINT32 value,
                                                                        PMC_POLL_COMPARISON_TYPE cmp,
                                                                        UINT32 max_count,
                                                                        UINT32 *num_failed_polls,
                                                                        UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_IRIGI_RX_DAT_VAL_V_poll", value );

    /* (0x00000068 bits 20) field IRIGI_RX_DAT_VAL_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    return etime_reg_GP_INT_VAL_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGI_RX_DAT_VAL_V_MSK,
                                          (value<<ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGI_RX_DAT_VAL_V_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_IRIGI_REALIGN_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_REALIGN_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000068 bits 19) field IRIGI_REALIGN_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    reg_value = etime_reg_GP_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGI_REALIGN_V_MSK) >> ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGI_REALIGN_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_REALIGN_V_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGI_REALIGN_V_poll( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 value,
                                                                     PMC_POLL_COMPARISON_TYPE cmp,
                                                                     UINT32 max_count,
                                                                     UINT32 *num_failed_polls,
                                                                     UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGI_REALIGN_V_poll( etime_buffer_t *b_ptr,
                                                                     etime_handle_t *h_ptr,
                                                                     UINT32 value,
                                                                     PMC_POLL_COMPARISON_TYPE cmp,
                                                                     UINT32 max_count,
                                                                     UINT32 *num_failed_polls,
                                                                     UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_IRIGI_REALIGN_V_poll", value );

    /* (0x00000068 bits 19) field IRIGI_REALIGN_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    return etime_reg_GP_INT_VAL_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGI_REALIGN_V_MSK,
                                          (value<<ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGI_REALIGN_V_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_IRIGI_P0PR_MISSING_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_P0PR_MISSING_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000068 bits 18) field IRIGI_P0PR_MISSING_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    reg_value = etime_reg_GP_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGI_P0PR_MISSING_V_MSK) >> ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGI_P0PR_MISSING_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_P0PR_MISSING_V_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGI_P0PR_MISSING_V_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGI_P0PR_MISSING_V_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_IRIGI_P0PR_MISSING_V_poll", value );

    /* (0x00000068 bits 18) field IRIGI_P0PR_MISSING_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    return etime_reg_GP_INT_VAL_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGI_P0PR_MISSING_V_MSK,
                                          (value<<ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGI_P0PR_MISSING_V_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_IRIGI_IDLE_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_IDLE_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000068 bits 17) field IRIGI_IDLE_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    reg_value = etime_reg_GP_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGI_IDLE_V_MSK) >> ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGI_IDLE_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_IDLE_V_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGI_IDLE_V_poll( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 value,
                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                  UINT32 max_count,
                                                                  UINT32 *num_failed_polls,
                                                                  UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGI_IDLE_V_poll( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 value,
                                                                  PMC_POLL_COMPARISON_TYPE cmp,
                                                                  UINT32 max_count,
                                                                  UINT32 *num_failed_polls,
                                                                  UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_IRIGI_IDLE_V_poll", value );

    /* (0x00000068 bits 17) field IRIGI_IDLE_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    return etime_reg_GP_INT_VAL_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGI_IDLE_V_MSK,
                                          (value<<ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGI_IDLE_V_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_IRIGI_ONE_PPSO_REALIGN_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_ONE_PPSO_REALIGN_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000068 bits 16) field IRIGI_ONE_PPSO_REALIGN_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    reg_value = etime_reg_GP_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGI_ONE_PPSO_REALIGN_V_MSK) >> ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGI_ONE_PPSO_REALIGN_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_ONE_PPSO_REALIGN_V_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGI_ONE_PPSO_REALIGN_V_poll( etime_buffer_t *b_ptr,
                                                                              etime_handle_t *h_ptr,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGI_ONE_PPSO_REALIGN_V_poll( etime_buffer_t *b_ptr,
                                                                              etime_handle_t *h_ptr,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_IRIGI_ONE_PPSO_REALIGN_V_poll", value );

    /* (0x00000068 bits 16) field IRIGI_ONE_PPSO_REALIGN_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    return etime_reg_GP_INT_VAL_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGI_ONE_PPSO_REALIGN_V_MSK,
                                          (value<<ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGI_ONE_PPSO_REALIGN_V_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_IRIGI_PWM_DEC_ERR_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_IRIGI_PWM_DEC_ERR_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000068 bits 15) field IRIGI_PWM_DEC_ERR_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    reg_value = etime_reg_GP_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGI_PWM_DEC_ERR_V_MSK) >> ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGI_PWM_DEC_ERR_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_IRIGI_PWM_DEC_ERR_V_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGI_PWM_DEC_ERR_V_poll( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_IRIGI_PWM_DEC_ERR_V_poll( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_IRIGI_PWM_DEC_ERR_V_poll", value );

    /* (0x00000068 bits 15) field IRIGI_PWM_DEC_ERR_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    return etime_reg_GP_INT_VAL_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGI_PWM_DEC_ERR_V_MSK,
                                          (value<<ETIME120_REG_GP_INT_VAL_REG_BIT_IRIGI_PWM_DEC_ERR_V_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_TOD_CFC_OFFS_TS_CNTR_UPDATED_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_CFC_OFFS_TS_CNTR_UPDATED_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000068 bits 14) field TOD_CFC_OFFS_TS_CNTR_UPDATED_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    reg_value = etime_reg_GP_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_VAL_REG_BIT_TOD_CFC_OFFS_TS_CNTR_UPDATED_V_MSK) >> ETIME120_REG_GP_INT_VAL_REG_BIT_TOD_CFC_OFFS_TS_CNTR_UPDATED_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_CFC_OFFS_TS_CNTR_UPDATED_V_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_TOD_CFC_OFFS_TS_CNTR_UPDATED_V_poll( etime_buffer_t *b_ptr,
                                                                                    etime_handle_t *h_ptr,
                                                                                    UINT32 value,
                                                                                    PMC_POLL_COMPARISON_TYPE cmp,
                                                                                    UINT32 max_count,
                                                                                    UINT32 *num_failed_polls,
                                                                                    UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_TOD_CFC_OFFS_TS_CNTR_UPDATED_V_poll( etime_buffer_t *b_ptr,
                                                                                    etime_handle_t *h_ptr,
                                                                                    UINT32 value,
                                                                                    PMC_POLL_COMPARISON_TYPE cmp,
                                                                                    UINT32 max_count,
                                                                                    UINT32 *num_failed_polls,
                                                                                    UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_TOD_CFC_OFFS_TS_CNTR_UPDATED_V_poll", value );

    /* (0x00000068 bits 14) field TOD_CFC_OFFS_TS_CNTR_UPDATED_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    return etime_reg_GP_INT_VAL_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_GP_INT_VAL_REG_BIT_TOD_CFC_OFFS_TS_CNTR_UPDATED_V_MSK,
                                          (value<<ETIME120_REG_GP_INT_VAL_REG_BIT_TOD_CFC_OFFS_TS_CNTR_UPDATED_V_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_TS_INTERPOLATE_CNTR_ERR_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TS_INTERPOLATE_CNTR_ERR_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000068 bits 13) field TS_INTERPOLATE_CNTR_ERR_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    reg_value = etime_reg_GP_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_VAL_REG_BIT_TS_INTERPOLATE_CNTR_ERR_V_MSK) >> ETIME120_REG_GP_INT_VAL_REG_BIT_TS_INTERPOLATE_CNTR_ERR_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TS_INTERPOLATE_CNTR_ERR_V_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_TS_INTERPOLATE_CNTR_ERR_V_poll( etime_buffer_t *b_ptr,
                                                                               etime_handle_t *h_ptr,
                                                                               UINT32 value,
                                                                               PMC_POLL_COMPARISON_TYPE cmp,
                                                                               UINT32 max_count,
                                                                               UINT32 *num_failed_polls,
                                                                               UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_TS_INTERPOLATE_CNTR_ERR_V_poll( etime_buffer_t *b_ptr,
                                                                               etime_handle_t *h_ptr,
                                                                               UINT32 value,
                                                                               PMC_POLL_COMPARISON_TYPE cmp,
                                                                               UINT32 max_count,
                                                                               UINT32 *num_failed_polls,
                                                                               UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_TS_INTERPOLATE_CNTR_ERR_V_poll", value );

    /* (0x00000068 bits 13) field TS_INTERPOLATE_CNTR_ERR_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    return etime_reg_GP_INT_VAL_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_GP_INT_VAL_REG_BIT_TS_INTERPOLATE_CNTR_ERR_V_MSK,
                                          (value<<ETIME120_REG_GP_INT_VAL_REG_BIT_TS_INTERPOLATE_CNTR_ERR_V_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_TS_TOD_SIGN_OVRFL_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TS_TOD_SIGN_OVRFL_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000068 bits 12) field TS_TOD_SIGN_OVRFL_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    reg_value = etime_reg_GP_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_VAL_REG_BIT_TS_TOD_SIGN_OVRFL_V_MSK) >> ETIME120_REG_GP_INT_VAL_REG_BIT_TS_TOD_SIGN_OVRFL_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TS_TOD_SIGN_OVRFL_V_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_TS_TOD_SIGN_OVRFL_V_poll( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_TS_TOD_SIGN_OVRFL_V_poll( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_TS_TOD_SIGN_OVRFL_V_poll", value );

    /* (0x00000068 bits 12) field TS_TOD_SIGN_OVRFL_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    return etime_reg_GP_INT_VAL_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_GP_INT_VAL_REG_BIT_TS_TOD_SIGN_OVRFL_V_MSK,
                                          (value<<ETIME120_REG_GP_INT_VAL_REG_BIT_TS_TOD_SIGN_OVRFL_V_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_CFC_OVRFL_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_OVRFL_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000068 bits 11) field CFC_OVRFL_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    reg_value = etime_reg_GP_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_VAL_REG_BIT_CFC_OVRFL_V_MSK) >> ETIME120_REG_GP_INT_VAL_REG_BIT_CFC_OVRFL_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_OVRFL_V_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_CFC_OVRFL_V_poll( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 value,
                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                 UINT32 max_count,
                                                                 UINT32 *num_failed_polls,
                                                                 UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_CFC_OVRFL_V_poll( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 value,
                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                 UINT32 max_count,
                                                                 UINT32 *num_failed_polls,
                                                                 UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_CFC_OVRFL_V_poll", value );

    /* (0x00000068 bits 11) field CFC_OVRFL_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    return etime_reg_GP_INT_VAL_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_GP_INT_VAL_REG_BIT_CFC_OVRFL_V_MSK,
                                          (value<<ETIME120_REG_GP_INT_VAL_REG_BIT_CFC_OVRFL_V_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_TOD_TS_OVRFL_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_TS_OVRFL_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000068 bits 10) field TOD_TS_OVRFL_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    reg_value = etime_reg_GP_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_VAL_REG_BIT_TOD_TS_OVRFL_V_MSK) >> ETIME120_REG_GP_INT_VAL_REG_BIT_TOD_TS_OVRFL_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_TS_OVRFL_V_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_TOD_TS_OVRFL_V_poll( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 value,
                                                                    PMC_POLL_COMPARISON_TYPE cmp,
                                                                    UINT32 max_count,
                                                                    UINT32 *num_failed_polls,
                                                                    UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_TOD_TS_OVRFL_V_poll( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 value,
                                                                    PMC_POLL_COMPARISON_TYPE cmp,
                                                                    UINT32 max_count,
                                                                    UINT32 *num_failed_polls,
                                                                    UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_TOD_TS_OVRFL_V_poll", value );

    /* (0x00000068 bits 10) field TOD_TS_OVRFL_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    return etime_reg_GP_INT_VAL_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_GP_INT_VAL_REG_BIT_TOD_TS_OVRFL_V_MSK,
                                          (value<<ETIME120_REG_GP_INT_VAL_REG_BIT_TOD_TS_OVRFL_V_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_FREE_RUN_CFC_OVRFL_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_FREE_RUN_CFC_OVRFL_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000068 bits 9) field FREE_RUN_CFC_OVRFL_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    reg_value = etime_reg_GP_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_VAL_REG_BIT_FREE_RUN_CFC_OVRFL_V_MSK) >> ETIME120_REG_GP_INT_VAL_REG_BIT_FREE_RUN_CFC_OVRFL_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_FREE_RUN_CFC_OVRFL_V_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_FREE_RUN_CFC_OVRFL_V_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_FREE_RUN_CFC_OVRFL_V_poll( etime_buffer_t *b_ptr,
                                                                          etime_handle_t *h_ptr,
                                                                          UINT32 value,
                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                          UINT32 max_count,
                                                                          UINT32 *num_failed_polls,
                                                                          UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_FREE_RUN_CFC_OVRFL_V_poll", value );

    /* (0x00000068 bits 9) field FREE_RUN_CFC_OVRFL_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    return etime_reg_GP_INT_VAL_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_GP_INT_VAL_REG_BIT_FREE_RUN_CFC_OVRFL_V_MSK,
                                          (value<<ETIME120_REG_GP_INT_VAL_REG_BIT_FREE_RUN_CFC_OVRFL_V_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_FREE_RUN_TS_OVRFL_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_FREE_RUN_TS_OVRFL_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000068 bits 8) field FREE_RUN_TS_OVRFL_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    reg_value = etime_reg_GP_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_VAL_REG_BIT_FREE_RUN_TS_OVRFL_V_MSK) >> ETIME120_REG_GP_INT_VAL_REG_BIT_FREE_RUN_TS_OVRFL_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_FREE_RUN_TS_OVRFL_V_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_FREE_RUN_TS_OVRFL_V_poll( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_FREE_RUN_TS_OVRFL_V_poll( etime_buffer_t *b_ptr,
                                                                         etime_handle_t *h_ptr,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_FREE_RUN_TS_OVRFL_V_poll", value );

    /* (0x00000068 bits 8) field FREE_RUN_TS_OVRFL_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    return etime_reg_GP_INT_VAL_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_GP_INT_VAL_REG_BIT_FREE_RUN_TS_OVRFL_V_MSK,
                                          (value<<ETIME120_REG_GP_INT_VAL_REG_BIT_FREE_RUN_TS_OVRFL_V_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_TOD_INT_1_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_INT_1_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000068 bits 7) field TOD_INT_1_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    reg_value = etime_reg_GP_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_VAL_REG_BIT_TOD_INT_1_V_MSK) >> ETIME120_REG_GP_INT_VAL_REG_BIT_TOD_INT_1_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_INT_1_V_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_TOD_INT_1_V_poll( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 value,
                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                 UINT32 max_count,
                                                                 UINT32 *num_failed_polls,
                                                                 UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_TOD_INT_1_V_poll( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 value,
                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                 UINT32 max_count,
                                                                 UINT32 *num_failed_polls,
                                                                 UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_TOD_INT_1_V_poll", value );

    /* (0x00000068 bits 7) field TOD_INT_1_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    return etime_reg_GP_INT_VAL_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_GP_INT_VAL_REG_BIT_TOD_INT_1_V_MSK,
                                          (value<<ETIME120_REG_GP_INT_VAL_REG_BIT_TOD_INT_1_V_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_TOD_INT_2_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_INT_2_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000068 bits 6) field TOD_INT_2_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    reg_value = etime_reg_GP_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_VAL_REG_BIT_TOD_INT_2_V_MSK) >> ETIME120_REG_GP_INT_VAL_REG_BIT_TOD_INT_2_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_INT_2_V_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_TOD_INT_2_V_poll( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 value,
                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                 UINT32 max_count,
                                                                 UINT32 *num_failed_polls,
                                                                 UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_TOD_INT_2_V_poll( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 value,
                                                                 PMC_POLL_COMPARISON_TYPE cmp,
                                                                 UINT32 max_count,
                                                                 UINT32 *num_failed_polls,
                                                                 UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_TOD_INT_2_V_poll", value );

    /* (0x00000068 bits 6) field TOD_INT_2_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    return etime_reg_GP_INT_VAL_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_GP_INT_VAL_REG_BIT_TOD_INT_2_V_MSK,
                                          (value<<ETIME120_REG_GP_INT_VAL_REG_BIT_TOD_INT_2_V_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_FREE_RUN_INT_1_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_FREE_RUN_INT_1_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000068 bits 5) field FREE_RUN_INT_1_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    reg_value = etime_reg_GP_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_VAL_REG_BIT_FREE_RUN_INT_1_V_MSK) >> ETIME120_REG_GP_INT_VAL_REG_BIT_FREE_RUN_INT_1_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_FREE_RUN_INT_1_V_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_FREE_RUN_INT_1_V_poll( etime_buffer_t *b_ptr,
                                                                      etime_handle_t *h_ptr,
                                                                      UINT32 value,
                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                      UINT32 max_count,
                                                                      UINT32 *num_failed_polls,
                                                                      UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_FREE_RUN_INT_1_V_poll( etime_buffer_t *b_ptr,
                                                                      etime_handle_t *h_ptr,
                                                                      UINT32 value,
                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                      UINT32 max_count,
                                                                      UINT32 *num_failed_polls,
                                                                      UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_FREE_RUN_INT_1_V_poll", value );

    /* (0x00000068 bits 5) field FREE_RUN_INT_1_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    return etime_reg_GP_INT_VAL_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_GP_INT_VAL_REG_BIT_FREE_RUN_INT_1_V_MSK,
                                          (value<<ETIME120_REG_GP_INT_VAL_REG_BIT_FREE_RUN_INT_1_V_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_FREE_RUN_INT_2_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_FREE_RUN_INT_2_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000068 bits 4) field FREE_RUN_INT_2_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    reg_value = etime_reg_GP_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_VAL_REG_BIT_FREE_RUN_INT_2_V_MSK) >> ETIME120_REG_GP_INT_VAL_REG_BIT_FREE_RUN_INT_2_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_FREE_RUN_INT_2_V_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_FREE_RUN_INT_2_V_poll( etime_buffer_t *b_ptr,
                                                                      etime_handle_t *h_ptr,
                                                                      UINT32 value,
                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                      UINT32 max_count,
                                                                      UINT32 *num_failed_polls,
                                                                      UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_FREE_RUN_INT_2_V_poll( etime_buffer_t *b_ptr,
                                                                      etime_handle_t *h_ptr,
                                                                      UINT32 value,
                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                      UINT32 max_count,
                                                                      UINT32 *num_failed_polls,
                                                                      UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_FREE_RUN_INT_2_V_poll", value );

    /* (0x00000068 bits 4) field FREE_RUN_INT_2_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    return etime_reg_GP_INT_VAL_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_GP_INT_VAL_REG_BIT_FREE_RUN_INT_2_V_MSK,
                                          (value<<ETIME120_REG_GP_INT_VAL_REG_BIT_FREE_RUN_INT_2_V_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_CC_INT_1_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CC_INT_1_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000068 bits 3) field CC_INT_1_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    reg_value = etime_reg_GP_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_VAL_REG_BIT_CC_INT_1_V_MSK) >> ETIME120_REG_GP_INT_VAL_REG_BIT_CC_INT_1_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CC_INT_1_V_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_CC_INT_1_V_poll( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 value,
                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                UINT32 max_count,
                                                                UINT32 *num_failed_polls,
                                                                UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_CC_INT_1_V_poll( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 value,
                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                UINT32 max_count,
                                                                UINT32 *num_failed_polls,
                                                                UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_CC_INT_1_V_poll", value );

    /* (0x00000068 bits 3) field CC_INT_1_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    return etime_reg_GP_INT_VAL_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_GP_INT_VAL_REG_BIT_CC_INT_1_V_MSK,
                                          (value<<ETIME120_REG_GP_INT_VAL_REG_BIT_CC_INT_1_V_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_CC_INT_2_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CC_INT_2_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000068 bits 2) field CC_INT_2_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    reg_value = etime_reg_GP_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_VAL_REG_BIT_CC_INT_2_V_MSK) >> ETIME120_REG_GP_INT_VAL_REG_BIT_CC_INT_2_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CC_INT_2_V_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_CC_INT_2_V_poll( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 value,
                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                UINT32 max_count,
                                                                UINT32 *num_failed_polls,
                                                                UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_CC_INT_2_V_poll( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 value,
                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                UINT32 max_count,
                                                                UINT32 *num_failed_polls,
                                                                UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_CC_INT_2_V_poll", value );

    /* (0x00000068 bits 2) field CC_INT_2_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    return etime_reg_GP_INT_VAL_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_GP_INT_VAL_REG_BIT_CC_INT_2_V_MSK,
                                          (value<<ETIME120_REG_GP_INT_VAL_REG_BIT_CC_INT_2_V_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_CC_INT_3_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CC_INT_3_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000068 bits 1) field CC_INT_3_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    reg_value = etime_reg_GP_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_VAL_REG_BIT_CC_INT_3_V_MSK) >> ETIME120_REG_GP_INT_VAL_REG_BIT_CC_INT_3_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CC_INT_3_V_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_CC_INT_3_V_poll( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 value,
                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                UINT32 max_count,
                                                                UINT32 *num_failed_polls,
                                                                UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_CC_INT_3_V_poll( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 value,
                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                UINT32 max_count,
                                                                UINT32 *num_failed_polls,
                                                                UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_CC_INT_3_V_poll", value );

    /* (0x00000068 bits 1) field CC_INT_3_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    return etime_reg_GP_INT_VAL_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_GP_INT_VAL_REG_BIT_CC_INT_3_V_MSK,
                                          (value<<ETIME120_REG_GP_INT_VAL_REG_BIT_CC_INT_3_V_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}

static INLINE UINT32 etime_field_CC_INT_4_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CC_INT_4_V_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000068 bits 0) field CC_INT_4_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    reg_value = etime_reg_GP_INT_VAL_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_GP_INT_VAL_REG_BIT_CC_INT_4_V_MSK) >> ETIME120_REG_GP_INT_VAL_REG_BIT_CC_INT_4_V_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CC_INT_4_V_get", value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE etime_field_CC_INT_4_V_poll( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 value,
                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                UINT32 max_count,
                                                                UINT32 *num_failed_polls,
                                                                UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE etime_field_CC_INT_4_V_poll( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 value,
                                                                PMC_POLL_COMPARISON_TYPE cmp,
                                                                UINT32 max_count,
                                                                UINT32 *num_failed_polls,
                                                                UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  0x%08x", "etime_field_CC_INT_4_V_poll", value );

    /* (0x00000068 bits 0) field CC_INT_4_V of register PMC_ETIME120_REG_GP_INT_VAL_REG */
    return etime_reg_GP_INT_VAL_REG_poll( b_ptr,
                                          h_ptr,
                                          ETIME120_REG_GP_INT_VAL_REG_BIT_CC_INT_4_V_MSK,
                                          (value<<ETIME120_REG_GP_INT_VAL_REG_BIT_CC_INT_4_V_OFF),
                                          cmp,
                                          max_count,
                                          num_failed_polls,
                                          delay_between_polls_in_microseconds);
}


/*
 * ==================================================================================
 * Parameter Access Functions for Paramset status
 * ==================================================================================
 */
static INLINE UINT32 etime_field_LINE_REF_PTP_SEC_CNTR_FRC_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_LINE_REF_PTP_SEC_CNTR_FRC_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000188 bits 31:30) field LINE_REF_PTP_SEC_CNTR_FRC of register PMC_ETIME120_REG_PTP_CNT */
    reg_value = etime_reg_PTP_CNT_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_PTP_CNT_BIT_LINE_REF_PTP_SEC_CNTR_FRC_MSK) >> ETIME120_REG_PTP_CNT_BIT_LINE_REF_PTP_SEC_CNTR_FRC_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_LINE_REF_PTP_SEC_CNTR_FRC_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_LINE_REF_PTP_SEC_CNTR_FRC_get( etime_buffer_t *b_ptr,
                                                                      etime_handle_t *h_ptr,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_LINE_REF_PTP_SEC_CNTR_FRC_get( etime_buffer_t *b_ptr,
                                                                      etime_handle_t *h_ptr,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_LINE_REF_PTP_SEC_CNTR_FRC_get", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_LINE_REF_PTP_SEC_CNTR_FRC_get", stop_bit, 1 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 1) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 1;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000188 bits 31:30) field LINE_REF_PTP_SEC_CNTR_FRC of register PMC_ETIME120_REG_PTP_CNT */
    reg_value = etime_reg_PTP_CNT_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_PTP_CNT_BIT_LINE_REF_PTP_SEC_CNTR_FRC_MSK)
                  >> ETIME120_REG_PTP_CNT_BIT_LINE_REF_PTP_SEC_CNTR_FRC_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_PTP_CNT_BIT_LINE_REF_PTP_SEC_CNTR_FRC_MSK, ETIME120_REG_PTP_CNT_BIT_LINE_REF_PTP_SEC_CNTR_FRC_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_LINE_REF_PTP_SEC_CNTR_FRC_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_LINE_REF_PTP_NSEC_CNTR_FRC_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_LINE_REF_PTP_NSEC_CNTR_FRC_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000188 bits 29:0) field LINE_REF_PTP_NSEC_CNTR_FRC of register PMC_ETIME120_REG_PTP_CNT */
    reg_value = etime_reg_PTP_CNT_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_PTP_CNT_BIT_LINE_REF_PTP_NSEC_CNTR_FRC_MSK) >> ETIME120_REG_PTP_CNT_BIT_LINE_REF_PTP_NSEC_CNTR_FRC_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_LINE_REF_PTP_NSEC_CNTR_FRC_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_LINE_REF_PTP_NSEC_CNTR_FRC_get( etime_buffer_t *b_ptr,
                                                                       etime_handle_t *h_ptr,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_LINE_REF_PTP_NSEC_CNTR_FRC_get( etime_buffer_t *b_ptr,
                                                                       etime_handle_t *h_ptr,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_LINE_REF_PTP_NSEC_CNTR_FRC_get", stop_bit, start_bit );
    if (stop_bit > 29) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_LINE_REF_PTP_NSEC_CNTR_FRC_get", stop_bit, 29 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 29) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 29;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000188 bits 29:0) field LINE_REF_PTP_NSEC_CNTR_FRC of register PMC_ETIME120_REG_PTP_CNT */
    reg_value = etime_reg_PTP_CNT_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_PTP_CNT_BIT_LINE_REF_PTP_NSEC_CNTR_FRC_MSK)
                  >> ETIME120_REG_PTP_CNT_BIT_LINE_REF_PTP_NSEC_CNTR_FRC_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_PTP_CNT_BIT_LINE_REF_PTP_NSEC_CNTR_FRC_MSK, ETIME120_REG_PTP_CNT_BIT_LINE_REF_PTP_NSEC_CNTR_FRC_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_LINE_REF_PTP_NSEC_CNTR_FRC_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_LINE_REF_SEC_CNTR_FRC_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_LINE_REF_SEC_CNTR_FRC_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000018c bits 31:30) field LINE_REF_SEC_CNTR_FRC of register PMC_ETIME120_REG_LINE_REF_CNT */
    reg_value = etime_reg_LINE_REF_CNT_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_LINE_REF_CNT_BIT_LINE_REF_SEC_CNTR_FRC_MSK) >> ETIME120_REG_LINE_REF_CNT_BIT_LINE_REF_SEC_CNTR_FRC_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_LINE_REF_SEC_CNTR_FRC_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_LINE_REF_SEC_CNTR_FRC_get( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_LINE_REF_SEC_CNTR_FRC_get( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_LINE_REF_SEC_CNTR_FRC_get", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_LINE_REF_SEC_CNTR_FRC_get", stop_bit, 1 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 1) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 1;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000018c bits 31:30) field LINE_REF_SEC_CNTR_FRC of register PMC_ETIME120_REG_LINE_REF_CNT */
    reg_value = etime_reg_LINE_REF_CNT_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_LINE_REF_CNT_BIT_LINE_REF_SEC_CNTR_FRC_MSK)
                  >> ETIME120_REG_LINE_REF_CNT_BIT_LINE_REF_SEC_CNTR_FRC_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_LINE_REF_CNT_BIT_LINE_REF_SEC_CNTR_FRC_MSK, ETIME120_REG_LINE_REF_CNT_BIT_LINE_REF_SEC_CNTR_FRC_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_LINE_REF_SEC_CNTR_FRC_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_LINE_REF_NSEC_CNTR_FRC_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_LINE_REF_NSEC_CNTR_FRC_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000018c bits 29:0) field LINE_REF_NSEC_CNTR_FRC of register PMC_ETIME120_REG_LINE_REF_CNT */
    reg_value = etime_reg_LINE_REF_CNT_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_LINE_REF_CNT_BIT_LINE_REF_NSEC_CNTR_FRC_MSK) >> ETIME120_REG_LINE_REF_CNT_BIT_LINE_REF_NSEC_CNTR_FRC_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_LINE_REF_NSEC_CNTR_FRC_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_LINE_REF_NSEC_CNTR_FRC_get( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_LINE_REF_NSEC_CNTR_FRC_get( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_LINE_REF_NSEC_CNTR_FRC_get", stop_bit, start_bit );
    if (stop_bit > 29) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_LINE_REF_NSEC_CNTR_FRC_get", stop_bit, 29 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 29) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 29;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000018c bits 29:0) field LINE_REF_NSEC_CNTR_FRC of register PMC_ETIME120_REG_LINE_REF_CNT */
    reg_value = etime_reg_LINE_REF_CNT_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_LINE_REF_CNT_BIT_LINE_REF_NSEC_CNTR_FRC_MSK)
                  >> ETIME120_REG_LINE_REF_CNT_BIT_LINE_REF_NSEC_CNTR_FRC_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_LINE_REF_CNT_BIT_LINE_REF_NSEC_CNTR_FRC_MSK, ETIME120_REG_LINE_REF_CNT_BIT_LINE_REF_NSEC_CNTR_FRC_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_LINE_REF_NSEC_CNTR_FRC_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_TOD_TS_OUT_EXT_TS_PAGE_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_TS_OUT_EXT_TS_PAGE_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000190 bits 18:16) field TOD_TS_OUT_EXT_TS_PAGE of register PMC_ETIME120_REG_TOD_TS_OUT_EXT_SEC_HI_REG */
    reg_value = etime_reg_TOD_TS_OUT_EXT_SEC_HI_REG_read( b_ptr,
                                                          h_ptr);
    value = (reg_value & ETIME120_REG_TOD_TS_OUT_EXT_SEC_HI_REG_BIT_TOD_TS_OUT_EXT_TS_PAGE_MSK) >> ETIME120_REG_TOD_TS_OUT_EXT_SEC_HI_REG_BIT_TOD_TS_OUT_EXT_TS_PAGE_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_TS_OUT_EXT_TS_PAGE_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_TOD_TS_OUT_EXT_TS_PAGE_get( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_TS_OUT_EXT_TS_PAGE_get( etime_buffer_t *b_ptr,
                                                                   etime_handle_t *h_ptr,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_TS_OUT_EXT_TS_PAGE_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_TS_OUT_EXT_TS_PAGE_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000190 bits 18:16) field TOD_TS_OUT_EXT_TS_PAGE of register PMC_ETIME120_REG_TOD_TS_OUT_EXT_SEC_HI_REG */
    reg_value = etime_reg_TOD_TS_OUT_EXT_SEC_HI_REG_read( b_ptr,
                                                          h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_TS_OUT_EXT_SEC_HI_REG_BIT_TOD_TS_OUT_EXT_TS_PAGE_MSK)
                  >> ETIME120_REG_TOD_TS_OUT_EXT_SEC_HI_REG_BIT_TOD_TS_OUT_EXT_TS_PAGE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_TS_OUT_EXT_SEC_HI_REG_BIT_TOD_TS_OUT_EXT_TS_PAGE_MSK, ETIME120_REG_TOD_TS_OUT_EXT_SEC_HI_REG_BIT_TOD_TS_OUT_EXT_TS_PAGE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_TS_OUT_EXT_TS_PAGE_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_TOD_TS_OUT_EXT_SEC_HI_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_TS_OUT_EXT_SEC_HI_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000190 bits 15:0) field TOD_TS_OUT_EXT_SEC_HI of register PMC_ETIME120_REG_TOD_TS_OUT_EXT_SEC_HI_REG */
    reg_value = etime_reg_TOD_TS_OUT_EXT_SEC_HI_REG_read( b_ptr,
                                                          h_ptr);
    value = (reg_value & ETIME120_REG_TOD_TS_OUT_EXT_SEC_HI_REG_BIT_TOD_TS_OUT_EXT_SEC_HI_MSK) >> ETIME120_REG_TOD_TS_OUT_EXT_SEC_HI_REG_BIT_TOD_TS_OUT_EXT_SEC_HI_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_TS_OUT_EXT_SEC_HI_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_TOD_TS_OUT_EXT_SEC_HI_get( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_TS_OUT_EXT_SEC_HI_get( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_TS_OUT_EXT_SEC_HI_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_TS_OUT_EXT_SEC_HI_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000190 bits 15:0) field TOD_TS_OUT_EXT_SEC_HI of register PMC_ETIME120_REG_TOD_TS_OUT_EXT_SEC_HI_REG */
    reg_value = etime_reg_TOD_TS_OUT_EXT_SEC_HI_REG_read( b_ptr,
                                                          h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_TS_OUT_EXT_SEC_HI_REG_BIT_TOD_TS_OUT_EXT_SEC_HI_MSK)
                  >> ETIME120_REG_TOD_TS_OUT_EXT_SEC_HI_REG_BIT_TOD_TS_OUT_EXT_SEC_HI_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_TS_OUT_EXT_SEC_HI_REG_BIT_TOD_TS_OUT_EXT_SEC_HI_MSK, ETIME120_REG_TOD_TS_OUT_EXT_SEC_HI_REG_BIT_TOD_TS_OUT_EXT_SEC_HI_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_TS_OUT_EXT_SEC_HI_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_TOD_TS_OUT_EXT_SEC_LO_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_TS_OUT_EXT_SEC_LO_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000194 bits 31:0) field TOD_TS_OUT_EXT_SEC_LO of register PMC_ETIME120_REG_TOD_TS_OUT_EXT_SEC_LO_REG */
    reg_value = etime_reg_TOD_TS_OUT_EXT_SEC_LO_REG_read( b_ptr,
                                                          h_ptr);
    value = (reg_value & ETIME120_REG_TOD_TS_OUT_EXT_SEC_LO_REG_BIT_TOD_TS_OUT_EXT_SEC_LO_MSK) >> ETIME120_REG_TOD_TS_OUT_EXT_SEC_LO_REG_BIT_TOD_TS_OUT_EXT_SEC_LO_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_TS_OUT_EXT_SEC_LO_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_TOD_TS_OUT_EXT_SEC_LO_get( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_TS_OUT_EXT_SEC_LO_get( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_TS_OUT_EXT_SEC_LO_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_TS_OUT_EXT_SEC_LO_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000194 bits 31:0) field TOD_TS_OUT_EXT_SEC_LO of register PMC_ETIME120_REG_TOD_TS_OUT_EXT_SEC_LO_REG */
    reg_value = etime_reg_TOD_TS_OUT_EXT_SEC_LO_REG_read( b_ptr,
                                                          h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_TS_OUT_EXT_SEC_LO_REG_BIT_TOD_TS_OUT_EXT_SEC_LO_MSK)
                  >> ETIME120_REG_TOD_TS_OUT_EXT_SEC_LO_REG_BIT_TOD_TS_OUT_EXT_SEC_LO_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_TS_OUT_EXT_SEC_LO_REG_BIT_TOD_TS_OUT_EXT_SEC_LO_MSK, ETIME120_REG_TOD_TS_OUT_EXT_SEC_LO_REG_BIT_TOD_TS_OUT_EXT_SEC_LO_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_TS_OUT_EXT_SEC_LO_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_TOD_TS_OUT_EXT_NSEC_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_TS_OUT_EXT_NSEC_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x00000198 bits 31:0) field TOD_TS_OUT_EXT_NSEC of register PMC_ETIME120_REG_TOD_TS_OUT_EXT_NSEC_REG */
    reg_value = etime_reg_TOD_TS_OUT_EXT_NSEC_REG_read( b_ptr,
                                                        h_ptr);
    value = (reg_value & ETIME120_REG_TOD_TS_OUT_EXT_NSEC_REG_BIT_TOD_TS_OUT_EXT_NSEC_MSK) >> ETIME120_REG_TOD_TS_OUT_EXT_NSEC_REG_BIT_TOD_TS_OUT_EXT_NSEC_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_TS_OUT_EXT_NSEC_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_TOD_TS_OUT_EXT_NSEC_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_TS_OUT_EXT_NSEC_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_TS_OUT_EXT_NSEC_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_TS_OUT_EXT_NSEC_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000198 bits 31:0) field TOD_TS_OUT_EXT_NSEC of register PMC_ETIME120_REG_TOD_TS_OUT_EXT_NSEC_REG */
    reg_value = etime_reg_TOD_TS_OUT_EXT_NSEC_REG_read( b_ptr,
                                                        h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_TS_OUT_EXT_NSEC_REG_BIT_TOD_TS_OUT_EXT_NSEC_MSK)
                  >> ETIME120_REG_TOD_TS_OUT_EXT_NSEC_REG_BIT_TOD_TS_OUT_EXT_NSEC_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_TS_OUT_EXT_NSEC_REG_BIT_TOD_TS_OUT_EXT_NSEC_MSK, ETIME120_REG_TOD_TS_OUT_EXT_NSEC_REG_BIT_TOD_TS_OUT_EXT_NSEC_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_TS_OUT_EXT_NSEC_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_CFC_TS_OUT_EXT_HI_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_TS_OUT_EXT_HI_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x0000019c bits 15:0) field CFC_TS_OUT_EXT_HI of register PMC_ETIME120_REG_CFC_TS_OUT_EXT_HI_REG */
    reg_value = etime_reg_CFC_TS_OUT_EXT_HI_REG_read( b_ptr,
                                                      h_ptr);
    value = (reg_value & ETIME120_REG_CFC_TS_OUT_EXT_HI_REG_BIT_CFC_TS_OUT_EXT_HI_MSK) >> ETIME120_REG_CFC_TS_OUT_EXT_HI_REG_BIT_CFC_TS_OUT_EXT_HI_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_TS_OUT_EXT_HI_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_CFC_TS_OUT_EXT_HI_get( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_TS_OUT_EXT_HI_get( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_TS_OUT_EXT_HI_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_TS_OUT_EXT_HI_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000019c bits 15:0) field CFC_TS_OUT_EXT_HI of register PMC_ETIME120_REG_CFC_TS_OUT_EXT_HI_REG */
    reg_value = etime_reg_CFC_TS_OUT_EXT_HI_REG_read( b_ptr,
                                                      h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_TS_OUT_EXT_HI_REG_BIT_CFC_TS_OUT_EXT_HI_MSK)
                  >> ETIME120_REG_CFC_TS_OUT_EXT_HI_REG_BIT_CFC_TS_OUT_EXT_HI_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_TS_OUT_EXT_HI_REG_BIT_CFC_TS_OUT_EXT_HI_MSK, ETIME120_REG_CFC_TS_OUT_EXT_HI_REG_BIT_CFC_TS_OUT_EXT_HI_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_TS_OUT_EXT_HI_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_CFC_TS_OUT_EXT_LO_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_TS_OUT_EXT_LO_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000001a0 bits 31:0) field CFC_TS_OUT_EXT_LO of register PMC_ETIME120_REG_CFC_TS_OUT_EXT_LO_REG */
    reg_value = etime_reg_CFC_TS_OUT_EXT_LO_REG_read( b_ptr,
                                                      h_ptr);
    value = (reg_value & ETIME120_REG_CFC_TS_OUT_EXT_LO_REG_BIT_CFC_TS_OUT_EXT_LO_MSK) >> ETIME120_REG_CFC_TS_OUT_EXT_LO_REG_BIT_CFC_TS_OUT_EXT_LO_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_TS_OUT_EXT_LO_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_CFC_TS_OUT_EXT_LO_get( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_TS_OUT_EXT_LO_get( etime_buffer_t *b_ptr,
                                                              etime_handle_t *h_ptr,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_TS_OUT_EXT_LO_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_TS_OUT_EXT_LO_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000001a0 bits 31:0) field CFC_TS_OUT_EXT_LO of register PMC_ETIME120_REG_CFC_TS_OUT_EXT_LO_REG */
    reg_value = etime_reg_CFC_TS_OUT_EXT_LO_REG_read( b_ptr,
                                                      h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_TS_OUT_EXT_LO_REG_BIT_CFC_TS_OUT_EXT_LO_MSK)
                  >> ETIME120_REG_CFC_TS_OUT_EXT_LO_REG_BIT_CFC_TS_OUT_EXT_LO_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_TS_OUT_EXT_LO_REG_BIT_CFC_TS_OUT_EXT_LO_MSK, ETIME120_REG_CFC_TS_OUT_EXT_LO_REG_BIT_CFC_TS_OUT_EXT_LO_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_TS_OUT_EXT_LO_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_TS_OUT_IRIGI_TS_PAGE_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TS_OUT_IRIGI_TS_PAGE_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000001a4 bits 18:16) field TS_OUT_IRIGI_TS_PAGE of register PMC_ETIME120_REG_TOD_TS_OUT_IRIGI_SEC_HI_REG */
    reg_value = etime_reg_TOD_TS_OUT_IRIGI_SEC_HI_REG_read( b_ptr,
                                                            h_ptr);
    value = (reg_value & ETIME120_REG_TOD_TS_OUT_IRIGI_SEC_HI_REG_BIT_TS_OUT_IRIGI_TS_PAGE_MSK) >> ETIME120_REG_TOD_TS_OUT_IRIGI_SEC_HI_REG_BIT_TS_OUT_IRIGI_TS_PAGE_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TS_OUT_IRIGI_TS_PAGE_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_TS_OUT_IRIGI_TS_PAGE_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TS_OUT_IRIGI_TS_PAGE_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TS_OUT_IRIGI_TS_PAGE_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TS_OUT_IRIGI_TS_PAGE_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000001a4 bits 18:16) field TS_OUT_IRIGI_TS_PAGE of register PMC_ETIME120_REG_TOD_TS_OUT_IRIGI_SEC_HI_REG */
    reg_value = etime_reg_TOD_TS_OUT_IRIGI_SEC_HI_REG_read( b_ptr,
                                                            h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_TS_OUT_IRIGI_SEC_HI_REG_BIT_TS_OUT_IRIGI_TS_PAGE_MSK)
                  >> ETIME120_REG_TOD_TS_OUT_IRIGI_SEC_HI_REG_BIT_TS_OUT_IRIGI_TS_PAGE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_TS_OUT_IRIGI_SEC_HI_REG_BIT_TS_OUT_IRIGI_TS_PAGE_MSK, ETIME120_REG_TOD_TS_OUT_IRIGI_SEC_HI_REG_BIT_TS_OUT_IRIGI_TS_PAGE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TS_OUT_IRIGI_TS_PAGE_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_TOD_TS_OUT_IRIGI_SEC_HI_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_TS_OUT_IRIGI_SEC_HI_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000001a4 bits 15:0) field TOD_TS_OUT_IRIGI_SEC_HI of register PMC_ETIME120_REG_TOD_TS_OUT_IRIGI_SEC_HI_REG */
    reg_value = etime_reg_TOD_TS_OUT_IRIGI_SEC_HI_REG_read( b_ptr,
                                                            h_ptr);
    value = (reg_value & ETIME120_REG_TOD_TS_OUT_IRIGI_SEC_HI_REG_BIT_TOD_TS_OUT_IRIGI_SEC_HI_MSK) >> ETIME120_REG_TOD_TS_OUT_IRIGI_SEC_HI_REG_BIT_TOD_TS_OUT_IRIGI_SEC_HI_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_TS_OUT_IRIGI_SEC_HI_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_TOD_TS_OUT_IRIGI_SEC_HI_get( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_TS_OUT_IRIGI_SEC_HI_get( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_TS_OUT_IRIGI_SEC_HI_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_TS_OUT_IRIGI_SEC_HI_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000001a4 bits 15:0) field TOD_TS_OUT_IRIGI_SEC_HI of register PMC_ETIME120_REG_TOD_TS_OUT_IRIGI_SEC_HI_REG */
    reg_value = etime_reg_TOD_TS_OUT_IRIGI_SEC_HI_REG_read( b_ptr,
                                                            h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_TS_OUT_IRIGI_SEC_HI_REG_BIT_TOD_TS_OUT_IRIGI_SEC_HI_MSK)
                  >> ETIME120_REG_TOD_TS_OUT_IRIGI_SEC_HI_REG_BIT_TOD_TS_OUT_IRIGI_SEC_HI_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_TS_OUT_IRIGI_SEC_HI_REG_BIT_TOD_TS_OUT_IRIGI_SEC_HI_MSK, ETIME120_REG_TOD_TS_OUT_IRIGI_SEC_HI_REG_BIT_TOD_TS_OUT_IRIGI_SEC_HI_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_TS_OUT_IRIGI_SEC_HI_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_TOD_TS_OUT_IRIGI_SEC_LO_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_TS_OUT_IRIGI_SEC_LO_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000001a8 bits 31:0) field TOD_TS_OUT_IRIGI_SEC_LO of register PMC_ETIME120_REG_TOD_TS_OUT_IRIGI_SEC_LO_REG */
    reg_value = etime_reg_TOD_TS_OUT_IRIGI_SEC_LO_REG_read( b_ptr,
                                                            h_ptr);
    value = (reg_value & ETIME120_REG_TOD_TS_OUT_IRIGI_SEC_LO_REG_BIT_TOD_TS_OUT_IRIGI_SEC_LO_MSK) >> ETIME120_REG_TOD_TS_OUT_IRIGI_SEC_LO_REG_BIT_TOD_TS_OUT_IRIGI_SEC_LO_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_TS_OUT_IRIGI_SEC_LO_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_TOD_TS_OUT_IRIGI_SEC_LO_get( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_TS_OUT_IRIGI_SEC_LO_get( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_TS_OUT_IRIGI_SEC_LO_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_TS_OUT_IRIGI_SEC_LO_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000001a8 bits 31:0) field TOD_TS_OUT_IRIGI_SEC_LO of register PMC_ETIME120_REG_TOD_TS_OUT_IRIGI_SEC_LO_REG */
    reg_value = etime_reg_TOD_TS_OUT_IRIGI_SEC_LO_REG_read( b_ptr,
                                                            h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_TS_OUT_IRIGI_SEC_LO_REG_BIT_TOD_TS_OUT_IRIGI_SEC_LO_MSK)
                  >> ETIME120_REG_TOD_TS_OUT_IRIGI_SEC_LO_REG_BIT_TOD_TS_OUT_IRIGI_SEC_LO_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_TS_OUT_IRIGI_SEC_LO_REG_BIT_TOD_TS_OUT_IRIGI_SEC_LO_MSK, ETIME120_REG_TOD_TS_OUT_IRIGI_SEC_LO_REG_BIT_TOD_TS_OUT_IRIGI_SEC_LO_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_TS_OUT_IRIGI_SEC_LO_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_TOD_TS_OUT_IRIGI_NSEC_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_TS_OUT_IRIGI_NSEC_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000001ac bits 31:0) field TOD_TS_OUT_IRIGI_NSEC of register PMC_ETIME120_REG_TOD_TS_OUT_IRIGI_NSEC_REG */
    reg_value = etime_reg_TOD_TS_OUT_IRIGI_NSEC_REG_read( b_ptr,
                                                          h_ptr);
    value = (reg_value & ETIME120_REG_TOD_TS_OUT_IRIGI_NSEC_REG_BIT_TOD_TS_OUT_IRIGI_NSEC_MSK) >> ETIME120_REG_TOD_TS_OUT_IRIGI_NSEC_REG_BIT_TOD_TS_OUT_IRIGI_NSEC_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_TS_OUT_IRIGI_NSEC_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_TOD_TS_OUT_IRIGI_NSEC_get( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_TS_OUT_IRIGI_NSEC_get( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_TS_OUT_IRIGI_NSEC_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_TS_OUT_IRIGI_NSEC_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000001ac bits 31:0) field TOD_TS_OUT_IRIGI_NSEC of register PMC_ETIME120_REG_TOD_TS_OUT_IRIGI_NSEC_REG */
    reg_value = etime_reg_TOD_TS_OUT_IRIGI_NSEC_REG_read( b_ptr,
                                                          h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_TS_OUT_IRIGI_NSEC_REG_BIT_TOD_TS_OUT_IRIGI_NSEC_MSK)
                  >> ETIME120_REG_TOD_TS_OUT_IRIGI_NSEC_REG_BIT_TOD_TS_OUT_IRIGI_NSEC_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_TS_OUT_IRIGI_NSEC_REG_BIT_TOD_TS_OUT_IRIGI_NSEC_MSK, ETIME120_REG_TOD_TS_OUT_IRIGI_NSEC_REG_BIT_TOD_TS_OUT_IRIGI_NSEC_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_TS_OUT_IRIGI_NSEC_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_CFC_TS_OUT_IRIGI_HI_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_TS_OUT_IRIGI_HI_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000001b0 bits 15:0) field CFC_TS_OUT_IRIGI_HI of register PMC_ETIME120_REG_CFC_TS_OUT_IRIGI_HI_REG */
    reg_value = etime_reg_CFC_TS_OUT_IRIGI_HI_REG_read( b_ptr,
                                                        h_ptr);
    value = (reg_value & ETIME120_REG_CFC_TS_OUT_IRIGI_HI_REG_BIT_CFC_TS_OUT_IRIGI_HI_MSK) >> ETIME120_REG_CFC_TS_OUT_IRIGI_HI_REG_BIT_CFC_TS_OUT_IRIGI_HI_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_TS_OUT_IRIGI_HI_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_CFC_TS_OUT_IRIGI_HI_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_TS_OUT_IRIGI_HI_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_TS_OUT_IRIGI_HI_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_TS_OUT_IRIGI_HI_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000001b0 bits 15:0) field CFC_TS_OUT_IRIGI_HI of register PMC_ETIME120_REG_CFC_TS_OUT_IRIGI_HI_REG */
    reg_value = etime_reg_CFC_TS_OUT_IRIGI_HI_REG_read( b_ptr,
                                                        h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_TS_OUT_IRIGI_HI_REG_BIT_CFC_TS_OUT_IRIGI_HI_MSK)
                  >> ETIME120_REG_CFC_TS_OUT_IRIGI_HI_REG_BIT_CFC_TS_OUT_IRIGI_HI_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_TS_OUT_IRIGI_HI_REG_BIT_CFC_TS_OUT_IRIGI_HI_MSK, ETIME120_REG_CFC_TS_OUT_IRIGI_HI_REG_BIT_CFC_TS_OUT_IRIGI_HI_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_TS_OUT_IRIGI_HI_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_CFC_TS_OUT_IRIGI_LO_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_TS_OUT_IRIGI_LO_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000001b4 bits 31:0) field CFC_TS_OUT_IRIGI_LO of register PMC_ETIME120_REG_CFC_TS_OUT_IRIGI_LO_REG */
    reg_value = etime_reg_CFC_TS_OUT_IRIGI_LO_REG_read( b_ptr,
                                                        h_ptr);
    value = (reg_value & ETIME120_REG_CFC_TS_OUT_IRIGI_LO_REG_BIT_CFC_TS_OUT_IRIGI_LO_MSK) >> ETIME120_REG_CFC_TS_OUT_IRIGI_LO_REG_BIT_CFC_TS_OUT_IRIGI_LO_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_TS_OUT_IRIGI_LO_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_CFC_TS_OUT_IRIGI_LO_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_TS_OUT_IRIGI_LO_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_TS_OUT_IRIGI_LO_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_TS_OUT_IRIGI_LO_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000001b4 bits 31:0) field CFC_TS_OUT_IRIGI_LO of register PMC_ETIME120_REG_CFC_TS_OUT_IRIGI_LO_REG */
    reg_value = etime_reg_CFC_TS_OUT_IRIGI_LO_REG_read( b_ptr,
                                                        h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_TS_OUT_IRIGI_LO_REG_BIT_CFC_TS_OUT_IRIGI_LO_MSK)
                  >> ETIME120_REG_CFC_TS_OUT_IRIGI_LO_REG_BIT_CFC_TS_OUT_IRIGI_LO_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_TS_OUT_IRIGI_LO_REG_BIT_CFC_TS_OUT_IRIGI_LO_MSK, ETIME120_REG_CFC_TS_OUT_IRIGI_LO_REG_BIT_CFC_TS_OUT_IRIGI_LO_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_TS_OUT_IRIGI_LO_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_TS_OUT_IRIGO_TS_PAGE_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TS_OUT_IRIGO_TS_PAGE_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000001b8 bits 18:16) field TS_OUT_IRIGO_TS_PAGE of register PMC_ETIME120_REG_TOD_TS_OUT_IRIGO_SEC_HI_REG */
    reg_value = etime_reg_TOD_TS_OUT_IRIGO_SEC_HI_REG_read( b_ptr,
                                                            h_ptr);
    value = (reg_value & ETIME120_REG_TOD_TS_OUT_IRIGO_SEC_HI_REG_BIT_TS_OUT_IRIGO_TS_PAGE_MSK) >> ETIME120_REG_TOD_TS_OUT_IRIGO_SEC_HI_REG_BIT_TS_OUT_IRIGO_TS_PAGE_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TS_OUT_IRIGO_TS_PAGE_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_TS_OUT_IRIGO_TS_PAGE_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TS_OUT_IRIGO_TS_PAGE_get( etime_buffer_t *b_ptr,
                                                                 etime_handle_t *h_ptr,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TS_OUT_IRIGO_TS_PAGE_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TS_OUT_IRIGO_TS_PAGE_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000001b8 bits 18:16) field TS_OUT_IRIGO_TS_PAGE of register PMC_ETIME120_REG_TOD_TS_OUT_IRIGO_SEC_HI_REG */
    reg_value = etime_reg_TOD_TS_OUT_IRIGO_SEC_HI_REG_read( b_ptr,
                                                            h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_TS_OUT_IRIGO_SEC_HI_REG_BIT_TS_OUT_IRIGO_TS_PAGE_MSK)
                  >> ETIME120_REG_TOD_TS_OUT_IRIGO_SEC_HI_REG_BIT_TS_OUT_IRIGO_TS_PAGE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_TS_OUT_IRIGO_SEC_HI_REG_BIT_TS_OUT_IRIGO_TS_PAGE_MSK, ETIME120_REG_TOD_TS_OUT_IRIGO_SEC_HI_REG_BIT_TS_OUT_IRIGO_TS_PAGE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TS_OUT_IRIGO_TS_PAGE_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_TOD_TS_OUT_IRIGO_SEC_HI_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_TS_OUT_IRIGO_SEC_HI_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000001b8 bits 15:0) field TOD_TS_OUT_IRIGO_SEC_HI of register PMC_ETIME120_REG_TOD_TS_OUT_IRIGO_SEC_HI_REG */
    reg_value = etime_reg_TOD_TS_OUT_IRIGO_SEC_HI_REG_read( b_ptr,
                                                            h_ptr);
    value = (reg_value & ETIME120_REG_TOD_TS_OUT_IRIGO_SEC_HI_REG_BIT_TOD_TS_OUT_IRIGO_SEC_HI_MSK) >> ETIME120_REG_TOD_TS_OUT_IRIGO_SEC_HI_REG_BIT_TOD_TS_OUT_IRIGO_SEC_HI_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_TS_OUT_IRIGO_SEC_HI_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_TOD_TS_OUT_IRIGO_SEC_HI_get( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_TS_OUT_IRIGO_SEC_HI_get( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_TS_OUT_IRIGO_SEC_HI_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_TS_OUT_IRIGO_SEC_HI_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000001b8 bits 15:0) field TOD_TS_OUT_IRIGO_SEC_HI of register PMC_ETIME120_REG_TOD_TS_OUT_IRIGO_SEC_HI_REG */
    reg_value = etime_reg_TOD_TS_OUT_IRIGO_SEC_HI_REG_read( b_ptr,
                                                            h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_TS_OUT_IRIGO_SEC_HI_REG_BIT_TOD_TS_OUT_IRIGO_SEC_HI_MSK)
                  >> ETIME120_REG_TOD_TS_OUT_IRIGO_SEC_HI_REG_BIT_TOD_TS_OUT_IRIGO_SEC_HI_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_TS_OUT_IRIGO_SEC_HI_REG_BIT_TOD_TS_OUT_IRIGO_SEC_HI_MSK, ETIME120_REG_TOD_TS_OUT_IRIGO_SEC_HI_REG_BIT_TOD_TS_OUT_IRIGO_SEC_HI_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_TS_OUT_IRIGO_SEC_HI_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_TOD_TS_OUT_IRIGO_SEC_LO_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_TS_OUT_IRIGO_SEC_LO_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000001bc bits 31:0) field TOD_TS_OUT_IRIGO_SEC_LO of register PMC_ETIME120_REG_TOD_TS_OUT_IRIGO_SEC_LO_REG */
    reg_value = etime_reg_TOD_TS_OUT_IRIGO_SEC_LO_REG_read( b_ptr,
                                                            h_ptr);
    value = (reg_value & ETIME120_REG_TOD_TS_OUT_IRIGO_SEC_LO_REG_BIT_TOD_TS_OUT_IRIGO_SEC_LO_MSK) >> ETIME120_REG_TOD_TS_OUT_IRIGO_SEC_LO_REG_BIT_TOD_TS_OUT_IRIGO_SEC_LO_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_TS_OUT_IRIGO_SEC_LO_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_TOD_TS_OUT_IRIGO_SEC_LO_get( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_TS_OUT_IRIGO_SEC_LO_get( etime_buffer_t *b_ptr,
                                                                    etime_handle_t *h_ptr,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_TS_OUT_IRIGO_SEC_LO_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_TS_OUT_IRIGO_SEC_LO_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000001bc bits 31:0) field TOD_TS_OUT_IRIGO_SEC_LO of register PMC_ETIME120_REG_TOD_TS_OUT_IRIGO_SEC_LO_REG */
    reg_value = etime_reg_TOD_TS_OUT_IRIGO_SEC_LO_REG_read( b_ptr,
                                                            h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_TS_OUT_IRIGO_SEC_LO_REG_BIT_TOD_TS_OUT_IRIGO_SEC_LO_MSK)
                  >> ETIME120_REG_TOD_TS_OUT_IRIGO_SEC_LO_REG_BIT_TOD_TS_OUT_IRIGO_SEC_LO_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_TS_OUT_IRIGO_SEC_LO_REG_BIT_TOD_TS_OUT_IRIGO_SEC_LO_MSK, ETIME120_REG_TOD_TS_OUT_IRIGO_SEC_LO_REG_BIT_TOD_TS_OUT_IRIGO_SEC_LO_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_TS_OUT_IRIGO_SEC_LO_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_TOD_TS_OUT_IRIGO_NSEC_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_TOD_TS_OUT_IRIGO_NSEC_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000001c0 bits 31:0) field TOD_TS_OUT_IRIGO_NSEC of register PMC_ETIME120_REG_TOD_TS_OUT_IRIGO_NSEC_REG */
    reg_value = etime_reg_TOD_TS_OUT_IRIGO_NSEC_REG_read( b_ptr,
                                                          h_ptr);
    value = (reg_value & ETIME120_REG_TOD_TS_OUT_IRIGO_NSEC_REG_BIT_TOD_TS_OUT_IRIGO_NSEC_MSK) >> ETIME120_REG_TOD_TS_OUT_IRIGO_NSEC_REG_BIT_TOD_TS_OUT_IRIGO_NSEC_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_TOD_TS_OUT_IRIGO_NSEC_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_TOD_TS_OUT_IRIGO_NSEC_get( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_TOD_TS_OUT_IRIGO_NSEC_get( etime_buffer_t *b_ptr,
                                                                  etime_handle_t *h_ptr,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_TOD_TS_OUT_IRIGO_NSEC_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_TOD_TS_OUT_IRIGO_NSEC_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000001c0 bits 31:0) field TOD_TS_OUT_IRIGO_NSEC of register PMC_ETIME120_REG_TOD_TS_OUT_IRIGO_NSEC_REG */
    reg_value = etime_reg_TOD_TS_OUT_IRIGO_NSEC_REG_read( b_ptr,
                                                          h_ptr);
    field_value = (reg_value & ETIME120_REG_TOD_TS_OUT_IRIGO_NSEC_REG_BIT_TOD_TS_OUT_IRIGO_NSEC_MSK)
                  >> ETIME120_REG_TOD_TS_OUT_IRIGO_NSEC_REG_BIT_TOD_TS_OUT_IRIGO_NSEC_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_TOD_TS_OUT_IRIGO_NSEC_REG_BIT_TOD_TS_OUT_IRIGO_NSEC_MSK, ETIME120_REG_TOD_TS_OUT_IRIGO_NSEC_REG_BIT_TOD_TS_OUT_IRIGO_NSEC_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_TOD_TS_OUT_IRIGO_NSEC_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_CFC_TS_OUT_IRIGO_HI_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_TS_OUT_IRIGO_HI_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000001c4 bits 15:0) field CFC_TS_OUT_IRIGO_HI of register PMC_ETIME120_REG_CFC_TS_OUT_IRIGO_HI_REG */
    reg_value = etime_reg_CFC_TS_OUT_IRIGO_HI_REG_read( b_ptr,
                                                        h_ptr);
    value = (reg_value & ETIME120_REG_CFC_TS_OUT_IRIGO_HI_REG_BIT_CFC_TS_OUT_IRIGO_HI_MSK) >> ETIME120_REG_CFC_TS_OUT_IRIGO_HI_REG_BIT_CFC_TS_OUT_IRIGO_HI_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_TS_OUT_IRIGO_HI_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_CFC_TS_OUT_IRIGO_HI_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_TS_OUT_IRIGO_HI_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_TS_OUT_IRIGO_HI_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_TS_OUT_IRIGO_HI_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000001c4 bits 15:0) field CFC_TS_OUT_IRIGO_HI of register PMC_ETIME120_REG_CFC_TS_OUT_IRIGO_HI_REG */
    reg_value = etime_reg_CFC_TS_OUT_IRIGO_HI_REG_read( b_ptr,
                                                        h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_TS_OUT_IRIGO_HI_REG_BIT_CFC_TS_OUT_IRIGO_HI_MSK)
                  >> ETIME120_REG_CFC_TS_OUT_IRIGO_HI_REG_BIT_CFC_TS_OUT_IRIGO_HI_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_TS_OUT_IRIGO_HI_REG_BIT_CFC_TS_OUT_IRIGO_HI_MSK, ETIME120_REG_CFC_TS_OUT_IRIGO_HI_REG_BIT_CFC_TS_OUT_IRIGO_HI_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_TS_OUT_IRIGO_HI_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_CFC_TS_OUT_IRIGO_LO_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_CFC_TS_OUT_IRIGO_LO_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000001c8 bits 31:0) field CFC_TS_OUT_IRIGO_LO of register PMC_ETIME120_REG_CFC_TS_OUT_IRIGO_LO_REG */
    reg_value = etime_reg_CFC_TS_OUT_IRIGO_LO_REG_read( b_ptr,
                                                        h_ptr);
    value = (reg_value & ETIME120_REG_CFC_TS_OUT_IRIGO_LO_REG_BIT_CFC_TS_OUT_IRIGO_LO_MSK) >> ETIME120_REG_CFC_TS_OUT_IRIGO_LO_REG_BIT_CFC_TS_OUT_IRIGO_LO_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_CFC_TS_OUT_IRIGO_LO_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_CFC_TS_OUT_IRIGO_LO_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_CFC_TS_OUT_IRIGO_LO_get( etime_buffer_t *b_ptr,
                                                                etime_handle_t *h_ptr,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_CFC_TS_OUT_IRIGO_LO_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_CFC_TS_OUT_IRIGO_LO_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000001c8 bits 31:0) field CFC_TS_OUT_IRIGO_LO of register PMC_ETIME120_REG_CFC_TS_OUT_IRIGO_LO_REG */
    reg_value = etime_reg_CFC_TS_OUT_IRIGO_LO_REG_read( b_ptr,
                                                        h_ptr);
    field_value = (reg_value & ETIME120_REG_CFC_TS_OUT_IRIGO_LO_REG_BIT_CFC_TS_OUT_IRIGO_LO_MSK)
                  >> ETIME120_REG_CFC_TS_OUT_IRIGO_LO_REG_BIT_CFC_TS_OUT_IRIGO_LO_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_CFC_TS_OUT_IRIGO_LO_REG_BIT_CFC_TS_OUT_IRIGO_LO_MSK, ETIME120_REG_CFC_TS_OUT_IRIGO_LO_REG_BIT_CFC_TS_OUT_IRIGO_LO_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_CFC_TS_OUT_IRIGO_LO_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_RX_VEC_IRIGI_4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_RX_VEC_IRIGI_4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000001dc bits 31:0) field RX_VEC_IRIGI_4 of register PMC_ETIME120_REG_RX_VEC_IRIGI_4_REG */
    reg_value = etime_reg_RX_VEC_IRIGI_4_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_RX_VEC_IRIGI_4_REG_BIT_RX_VEC_IRIGI_4_MSK) >> ETIME120_REG_RX_VEC_IRIGI_4_REG_BIT_RX_VEC_IRIGI_4_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_RX_VEC_IRIGI_4_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_RX_VEC_IRIGI_4_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_RX_VEC_IRIGI_4_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_RX_VEC_IRIGI_4_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_RX_VEC_IRIGI_4_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000001dc bits 31:0) field RX_VEC_IRIGI_4 of register PMC_ETIME120_REG_RX_VEC_IRIGI_4_REG */
    reg_value = etime_reg_RX_VEC_IRIGI_4_REG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_RX_VEC_IRIGI_4_REG_BIT_RX_VEC_IRIGI_4_MSK)
                  >> ETIME120_REG_RX_VEC_IRIGI_4_REG_BIT_RX_VEC_IRIGI_4_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_RX_VEC_IRIGI_4_REG_BIT_RX_VEC_IRIGI_4_MSK, ETIME120_REG_RX_VEC_IRIGI_4_REG_BIT_RX_VEC_IRIGI_4_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_RX_VEC_IRIGI_4_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_RX_VEC_IRIGI_3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_RX_VEC_IRIGI_3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000001e0 bits 31:0) field RX_VEC_IRIGI_3 of register PMC_ETIME120_REG_RX_VEC_IRIGI_3_REG */
    reg_value = etime_reg_RX_VEC_IRIGI_3_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_RX_VEC_IRIGI_3_REG_BIT_RX_VEC_IRIGI_3_MSK) >> ETIME120_REG_RX_VEC_IRIGI_3_REG_BIT_RX_VEC_IRIGI_3_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_RX_VEC_IRIGI_3_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_RX_VEC_IRIGI_3_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_RX_VEC_IRIGI_3_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_RX_VEC_IRIGI_3_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_RX_VEC_IRIGI_3_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000001e0 bits 31:0) field RX_VEC_IRIGI_3 of register PMC_ETIME120_REG_RX_VEC_IRIGI_3_REG */
    reg_value = etime_reg_RX_VEC_IRIGI_3_REG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_RX_VEC_IRIGI_3_REG_BIT_RX_VEC_IRIGI_3_MSK)
                  >> ETIME120_REG_RX_VEC_IRIGI_3_REG_BIT_RX_VEC_IRIGI_3_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_RX_VEC_IRIGI_3_REG_BIT_RX_VEC_IRIGI_3_MSK, ETIME120_REG_RX_VEC_IRIGI_3_REG_BIT_RX_VEC_IRIGI_3_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_RX_VEC_IRIGI_3_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_RX_VEC_IRIGI_2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_RX_VEC_IRIGI_2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000001e4 bits 31:0) field RX_VEC_IRIGI_2 of register PMC_ETIME120_REG_RX_VEC_IRIGI_2_REG */
    reg_value = etime_reg_RX_VEC_IRIGI_2_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_RX_VEC_IRIGI_2_REG_BIT_RX_VEC_IRIGI_2_MSK) >> ETIME120_REG_RX_VEC_IRIGI_2_REG_BIT_RX_VEC_IRIGI_2_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_RX_VEC_IRIGI_2_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_RX_VEC_IRIGI_2_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_RX_VEC_IRIGI_2_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_RX_VEC_IRIGI_2_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_RX_VEC_IRIGI_2_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000001e4 bits 31:0) field RX_VEC_IRIGI_2 of register PMC_ETIME120_REG_RX_VEC_IRIGI_2_REG */
    reg_value = etime_reg_RX_VEC_IRIGI_2_REG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_RX_VEC_IRIGI_2_REG_BIT_RX_VEC_IRIGI_2_MSK)
                  >> ETIME120_REG_RX_VEC_IRIGI_2_REG_BIT_RX_VEC_IRIGI_2_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_RX_VEC_IRIGI_2_REG_BIT_RX_VEC_IRIGI_2_MSK, ETIME120_REG_RX_VEC_IRIGI_2_REG_BIT_RX_VEC_IRIGI_2_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_RX_VEC_IRIGI_2_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_RX_VEC_IRIGI_1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_RX_VEC_IRIGI_1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000001e8 bits 3:0) field RX_VEC_IRIGI_1 of register PMC_ETIME120_REG_RX_VEC_IRIGI_1_REG */
    reg_value = etime_reg_RX_VEC_IRIGI_1_REG_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_RX_VEC_IRIGI_1_REG_BIT_RX_VEC_IRIGI_1_MSK) >> ETIME120_REG_RX_VEC_IRIGI_1_REG_BIT_RX_VEC_IRIGI_1_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_RX_VEC_IRIGI_1_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_RX_VEC_IRIGI_1_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_RX_VEC_IRIGI_1_get( etime_buffer_t *b_ptr,
                                                           etime_handle_t *h_ptr,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_RX_VEC_IRIGI_1_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_RX_VEC_IRIGI_1_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000001e8 bits 3:0) field RX_VEC_IRIGI_1 of register PMC_ETIME120_REG_RX_VEC_IRIGI_1_REG */
    reg_value = etime_reg_RX_VEC_IRIGI_1_REG_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_RX_VEC_IRIGI_1_REG_BIT_RX_VEC_IRIGI_1_MSK)
                  >> ETIME120_REG_RX_VEC_IRIGI_1_REG_BIT_RX_VEC_IRIGI_1_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_RX_VEC_IRIGI_1_REG_BIT_RX_VEC_IRIGI_1_MSK, ETIME120_REG_RX_VEC_IRIGI_1_REG_BIT_RX_VEC_IRIGI_1_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_RX_VEC_IRIGI_1_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_REFL_PMON_0_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_PMON_0_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000002ac bits 11:0) field REFL_PMON_0 of register PMC_ETIME120_REG_EXT_PMON_LINK0 */
    reg_value = etime_reg_EXT_PMON_LINK0_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EXT_PMON_LINK0_BIT_REFL_PMON_0_MSK) >> ETIME120_REG_EXT_PMON_LINK0_BIT_REFL_PMON_0_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_PMON_0_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_REFL_PMON_0_get( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_REFL_PMON_0_get( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_REFL_PMON_0_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_REFL_PMON_0_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000002ac bits 11:0) field REFL_PMON_0 of register PMC_ETIME120_REG_EXT_PMON_LINK0 */
    reg_value = etime_reg_EXT_PMON_LINK0_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_PMON_LINK0_BIT_REFL_PMON_0_MSK)
                  >> ETIME120_REG_EXT_PMON_LINK0_BIT_REFL_PMON_0_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_PMON_LINK0_BIT_REFL_PMON_0_MSK, ETIME120_REG_EXT_PMON_LINK0_BIT_REFL_PMON_0_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_REFL_PMON_0_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_REFL_PMON_1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_PMON_1_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000002b0 bits 11:0) field REFL_PMON_1 of register PMC_ETIME120_REG_EXT_PMON_LINK1 */
    reg_value = etime_reg_EXT_PMON_LINK1_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EXT_PMON_LINK1_BIT_REFL_PMON_1_MSK) >> ETIME120_REG_EXT_PMON_LINK1_BIT_REFL_PMON_1_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_PMON_1_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_REFL_PMON_1_get( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_REFL_PMON_1_get( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_REFL_PMON_1_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_REFL_PMON_1_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000002b0 bits 11:0) field REFL_PMON_1 of register PMC_ETIME120_REG_EXT_PMON_LINK1 */
    reg_value = etime_reg_EXT_PMON_LINK1_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_PMON_LINK1_BIT_REFL_PMON_1_MSK)
                  >> ETIME120_REG_EXT_PMON_LINK1_BIT_REFL_PMON_1_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_PMON_LINK1_BIT_REFL_PMON_1_MSK, ETIME120_REG_EXT_PMON_LINK1_BIT_REFL_PMON_1_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_REFL_PMON_1_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_REFL_PMON_2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_PMON_2_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000002b4 bits 11:0) field REFL_PMON_2 of register PMC_ETIME120_REG_EXT_PMON_LINK2 */
    reg_value = etime_reg_EXT_PMON_LINK2_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EXT_PMON_LINK2_BIT_REFL_PMON_2_MSK) >> ETIME120_REG_EXT_PMON_LINK2_BIT_REFL_PMON_2_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_PMON_2_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_REFL_PMON_2_get( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_REFL_PMON_2_get( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_REFL_PMON_2_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_REFL_PMON_2_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000002b4 bits 11:0) field REFL_PMON_2 of register PMC_ETIME120_REG_EXT_PMON_LINK2 */
    reg_value = etime_reg_EXT_PMON_LINK2_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_PMON_LINK2_BIT_REFL_PMON_2_MSK)
                  >> ETIME120_REG_EXT_PMON_LINK2_BIT_REFL_PMON_2_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_PMON_LINK2_BIT_REFL_PMON_2_MSK, ETIME120_REG_EXT_PMON_LINK2_BIT_REFL_PMON_2_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_REFL_PMON_2_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_REFL_PMON_3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_PMON_3_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000002b8 bits 11:0) field REFL_PMON_3 of register PMC_ETIME120_REG_EXT_PMON_LINK3 */
    reg_value = etime_reg_EXT_PMON_LINK3_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EXT_PMON_LINK3_BIT_REFL_PMON_3_MSK) >> ETIME120_REG_EXT_PMON_LINK3_BIT_REFL_PMON_3_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_PMON_3_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_REFL_PMON_3_get( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_REFL_PMON_3_get( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_REFL_PMON_3_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_REFL_PMON_3_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000002b8 bits 11:0) field REFL_PMON_3 of register PMC_ETIME120_REG_EXT_PMON_LINK3 */
    reg_value = etime_reg_EXT_PMON_LINK3_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_PMON_LINK3_BIT_REFL_PMON_3_MSK)
                  >> ETIME120_REG_EXT_PMON_LINK3_BIT_REFL_PMON_3_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_PMON_LINK3_BIT_REFL_PMON_3_MSK, ETIME120_REG_EXT_PMON_LINK3_BIT_REFL_PMON_3_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_REFL_PMON_3_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_REFL_PMON_4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_PMON_4_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000002bc bits 11:0) field REFL_PMON_4 of register PMC_ETIME120_REG_EXT_PMON_LINK4 */
    reg_value = etime_reg_EXT_PMON_LINK4_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EXT_PMON_LINK4_BIT_REFL_PMON_4_MSK) >> ETIME120_REG_EXT_PMON_LINK4_BIT_REFL_PMON_4_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_PMON_4_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_REFL_PMON_4_get( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_REFL_PMON_4_get( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_REFL_PMON_4_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_REFL_PMON_4_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000002bc bits 11:0) field REFL_PMON_4 of register PMC_ETIME120_REG_EXT_PMON_LINK4 */
    reg_value = etime_reg_EXT_PMON_LINK4_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_PMON_LINK4_BIT_REFL_PMON_4_MSK)
                  >> ETIME120_REG_EXT_PMON_LINK4_BIT_REFL_PMON_4_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_PMON_LINK4_BIT_REFL_PMON_4_MSK, ETIME120_REG_EXT_PMON_LINK4_BIT_REFL_PMON_4_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_REFL_PMON_4_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_REFL_PMON_5_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_PMON_5_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000002c0 bits 11:0) field REFL_PMON_5 of register PMC_ETIME120_REG_EXT_PMON_LINK5 */
    reg_value = etime_reg_EXT_PMON_LINK5_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EXT_PMON_LINK5_BIT_REFL_PMON_5_MSK) >> ETIME120_REG_EXT_PMON_LINK5_BIT_REFL_PMON_5_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_PMON_5_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_REFL_PMON_5_get( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_REFL_PMON_5_get( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_REFL_PMON_5_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_REFL_PMON_5_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000002c0 bits 11:0) field REFL_PMON_5 of register PMC_ETIME120_REG_EXT_PMON_LINK5 */
    reg_value = etime_reg_EXT_PMON_LINK5_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_PMON_LINK5_BIT_REFL_PMON_5_MSK)
                  >> ETIME120_REG_EXT_PMON_LINK5_BIT_REFL_PMON_5_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_PMON_LINK5_BIT_REFL_PMON_5_MSK, ETIME120_REG_EXT_PMON_LINK5_BIT_REFL_PMON_5_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_REFL_PMON_5_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_REFL_PMON_6_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_PMON_6_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000002c4 bits 11:0) field REFL_PMON_6 of register PMC_ETIME120_REG_EXT_PMON_LINK6 */
    reg_value = etime_reg_EXT_PMON_LINK6_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EXT_PMON_LINK6_BIT_REFL_PMON_6_MSK) >> ETIME120_REG_EXT_PMON_LINK6_BIT_REFL_PMON_6_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_PMON_6_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_REFL_PMON_6_get( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_REFL_PMON_6_get( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_REFL_PMON_6_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_REFL_PMON_6_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000002c4 bits 11:0) field REFL_PMON_6 of register PMC_ETIME120_REG_EXT_PMON_LINK6 */
    reg_value = etime_reg_EXT_PMON_LINK6_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_PMON_LINK6_BIT_REFL_PMON_6_MSK)
                  >> ETIME120_REG_EXT_PMON_LINK6_BIT_REFL_PMON_6_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_PMON_LINK6_BIT_REFL_PMON_6_MSK, ETIME120_REG_EXT_PMON_LINK6_BIT_REFL_PMON_6_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_REFL_PMON_6_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_REFL_PMON_7_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_PMON_7_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000002c8 bits 11:0) field REFL_PMON_7 of register PMC_ETIME120_REG_EXT_PMON_LINK7 */
    reg_value = etime_reg_EXT_PMON_LINK7_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EXT_PMON_LINK7_BIT_REFL_PMON_7_MSK) >> ETIME120_REG_EXT_PMON_LINK7_BIT_REFL_PMON_7_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_PMON_7_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_REFL_PMON_7_get( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_REFL_PMON_7_get( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_REFL_PMON_7_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_REFL_PMON_7_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000002c8 bits 11:0) field REFL_PMON_7 of register PMC_ETIME120_REG_EXT_PMON_LINK7 */
    reg_value = etime_reg_EXT_PMON_LINK7_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_PMON_LINK7_BIT_REFL_PMON_7_MSK)
                  >> ETIME120_REG_EXT_PMON_LINK7_BIT_REFL_PMON_7_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_PMON_LINK7_BIT_REFL_PMON_7_MSK, ETIME120_REG_EXT_PMON_LINK7_BIT_REFL_PMON_7_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_REFL_PMON_7_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_REFL_PMON_8_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_PMON_8_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000002cc bits 11:0) field REFL_PMON_8 of register PMC_ETIME120_REG_EXT_PMON_LINK8 */
    reg_value = etime_reg_EXT_PMON_LINK8_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EXT_PMON_LINK8_BIT_REFL_PMON_8_MSK) >> ETIME120_REG_EXT_PMON_LINK8_BIT_REFL_PMON_8_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_PMON_8_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_REFL_PMON_8_get( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_REFL_PMON_8_get( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_REFL_PMON_8_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_REFL_PMON_8_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000002cc bits 11:0) field REFL_PMON_8 of register PMC_ETIME120_REG_EXT_PMON_LINK8 */
    reg_value = etime_reg_EXT_PMON_LINK8_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_PMON_LINK8_BIT_REFL_PMON_8_MSK)
                  >> ETIME120_REG_EXT_PMON_LINK8_BIT_REFL_PMON_8_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_PMON_LINK8_BIT_REFL_PMON_8_MSK, ETIME120_REG_EXT_PMON_LINK8_BIT_REFL_PMON_8_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_REFL_PMON_8_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_REFL_PMON_9_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_PMON_9_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000002d0 bits 11:0) field REFL_PMON_9 of register PMC_ETIME120_REG_EXT_PMON_LINK9 */
    reg_value = etime_reg_EXT_PMON_LINK9_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EXT_PMON_LINK9_BIT_REFL_PMON_9_MSK) >> ETIME120_REG_EXT_PMON_LINK9_BIT_REFL_PMON_9_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_PMON_9_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_REFL_PMON_9_get( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_REFL_PMON_9_get( etime_buffer_t *b_ptr,
                                                        etime_handle_t *h_ptr,
                                                        UINT32 start_bit,
                                                        UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_REFL_PMON_9_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_REFL_PMON_9_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000002d0 bits 11:0) field REFL_PMON_9 of register PMC_ETIME120_REG_EXT_PMON_LINK9 */
    reg_value = etime_reg_EXT_PMON_LINK9_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_PMON_LINK9_BIT_REFL_PMON_9_MSK)
                  >> ETIME120_REG_EXT_PMON_LINK9_BIT_REFL_PMON_9_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_PMON_LINK9_BIT_REFL_PMON_9_MSK, ETIME120_REG_EXT_PMON_LINK9_BIT_REFL_PMON_9_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_REFL_PMON_9_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_REFL_PMON_10_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_PMON_10_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000002d4 bits 11:0) field REFL_PMON_10 of register PMC_ETIME120_REG_EXT_PMON_LINK10 */
    reg_value = etime_reg_EXT_PMON_LINK10_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EXT_PMON_LINK10_BIT_REFL_PMON_10_MSK) >> ETIME120_REG_EXT_PMON_LINK10_BIT_REFL_PMON_10_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_PMON_10_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_REFL_PMON_10_get( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_REFL_PMON_10_get( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_REFL_PMON_10_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_REFL_PMON_10_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000002d4 bits 11:0) field REFL_PMON_10 of register PMC_ETIME120_REG_EXT_PMON_LINK10 */
    reg_value = etime_reg_EXT_PMON_LINK10_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_PMON_LINK10_BIT_REFL_PMON_10_MSK)
                  >> ETIME120_REG_EXT_PMON_LINK10_BIT_REFL_PMON_10_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_PMON_LINK10_BIT_REFL_PMON_10_MSK, ETIME120_REG_EXT_PMON_LINK10_BIT_REFL_PMON_10_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_REFL_PMON_10_get", start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 etime_field_REFL_PMON_11_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_REFL_PMON_11_get( etime_buffer_t *b_ptr, etime_handle_t *h_ptr )
{
    UINT32 value = 0;
    UINT32 reg_value;

    /* (0x000002d8 bits 11:0) field REFL_PMON_11 of register PMC_ETIME120_REG_EXT_PMON_LINK11 */
    reg_value = etime_reg_EXT_PMON_LINK11_read(  b_ptr, h_ptr);
    value = (reg_value & ETIME120_REG_EXT_PMON_LINK11_BIT_REFL_PMON_11_MSK) >> ETIME120_REG_EXT_PMON_LINK11_BIT_REFL_PMON_11_OFF;
    IOLOG( "%s -> 0x%08x", "etime_field_REFL_PMON_11_get", value );

    return value;
}
static INLINE UINT32 etime_field_range_REFL_PMON_11_get( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 etime_field_range_REFL_PMON_11_get( etime_buffer_t *b_ptr,
                                                         etime_handle_t *h_ptr,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "etime_field_range_REFL_PMON_11_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "etime_field_range_REFL_PMON_11_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000002d8 bits 11:0) field REFL_PMON_11 of register PMC_ETIME120_REG_EXT_PMON_LINK11 */
    reg_value = etime_reg_EXT_PMON_LINK11_read(  b_ptr, h_ptr);
    field_value = (reg_value & ETIME120_REG_EXT_PMON_LINK11_BIT_REFL_PMON_11_MSK)
                  >> ETIME120_REG_EXT_PMON_LINK11_BIT_REFL_PMON_11_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, ETIME120_REG_EXT_PMON_LINK11_BIT_REFL_PMON_11_MSK, ETIME120_REG_EXT_PMON_LINK11_BIT_REFL_PMON_11_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> start_bit=%d stop_bit=%d 0x%08x", "etime_field_range_REFL_PMON_11_get", start_bit, stop_bit, value );

    return value;
}

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* _ETIME_IO_INLINE_H */
