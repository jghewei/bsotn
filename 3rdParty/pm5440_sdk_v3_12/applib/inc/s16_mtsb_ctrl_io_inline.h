/******************************************************************************
 *   COPYRIGHT (C) 2013 PMC-SIERRA, INC. ALL RIGHTS RESERVED.
 * --------------------------------------------------------------------------
 *  This software embodies materials and concepts which are proprietary and
 *  confidential to PMC-Sierra, Inc.
 *  PMC-Sierra distributes this software to its customers pursuant to the
 *  terms and conditions of the Software License Agreement
 *  contained in the text file software.lic that is distributed along with
 *  the software. This software can only be utilized if all
 *  terms and conditions of the Software License Agreement are
 *  accepted. If there are any questions, concerns, or if the
 *  Software License Agreement text file, software.lic, is missing please
 *  contact PMC-Sierra for assistance.
 * -------------------------------------------------------------------------
 *   DESCRIPTION:
 *     contains the inline implementation of all the field accessor functions
 *     and register accessor functions for the s16_mtsb_ctrl block
 *****************************************************************************/
#ifndef _S16_MTSB_CTRL_IO_INLINE_H
#define _S16_MTSB_CTRL_IO_INLINE_H

#include "s16_loc.h"
#include "s16_mtsb_ctrl_regs.h"

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#define S16_MTSB_CTRL_IO_VERSION 2

/*
 * ==================================================================================
 *  tsb level structure and access functions for s16_mtsb_ctrl
 * ==================================================================================
 */
/* if logging is disabled then so is IO_LOGGING */
#ifndef NO_IO_LOGGING
# ifdef LOGGING_DISABLED
#  define NO_IO_LOGGING
# endif
#endif

/* log messages in the generated files log the caller's file/line/function instead of itself.*/
#ifndef IOLOG
# ifdef NO_IO_LOGGING
#  define IOLOG(...)
# else
#  define IOLOG(...) LOG( __VA_ARGS__)
# endif
#endif
#ifndef IO_RANGE_CHECK
# ifdef NO_IO_LOGGING
#  define IO_RANGE_CHECK(...)
# else
#  define IO_RANGE_CHECK(...) LOG( "** range check ** " __VA_ARGS__)
# endif
#endif
#ifndef IOLOG_DATA
# ifdef NO_IO_LOGGING
#  define IOLOG_DATA(...)
# else
#  define IOLOG_DATA(...) LOG_DATA( __VA_ARGS__)
# endif
#endif
typedef struct {
    coalesce_buffer_t coalesce_handle[1]; /* only used if register coalescing is enabled */
    s16_handle_t * h_ptr;
    UINT32 A;
    pmc_sys_handle_t * sys_handle;
    PMC_VAR_CONST UINT32 base_address;
    /* maybe eventually need to add some fields here per io handle */
} s16_mtsb_ctrl_buffer_t;
static INLINE void s16_mtsb_ctrl_buffer_init( s16_mtsb_ctrl_buffer_t *b_ptr,
                                              s16_handle_t *h_ptr,
                                              UINT32 A ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_buffer_init( s16_mtsb_ctrl_buffer_t *b_ptr,
                                              s16_handle_t *h_ptr,
                                              UINT32 A )
{
    b_ptr->h_ptr                    = h_ptr;
    b_ptr->A                        = A;
    b_ptr->sys_handle               = ((pmc_handle_t *)h_ptr)->sys_handle;
    *(UINT32 *)&b_ptr->base_address = (((pmc_handle_t *)h_ptr)->base_address + ((0)*0x1000) );
    /* currently this just checks that the previous function remembered to flush. */
    l1sys_init( b_ptr->coalesce_handle, b_ptr->sys_handle );
    IOLOG( "%s A=%d", "s16_mtsb_ctrl_buffer_init", A);
    
}

/* flush any changed fields to the register file and invalidate the read cache. */
static INLINE void s16_mtsb_ctrl_buffer_flush( s16_mtsb_ctrl_buffer_t *b_ptr ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_buffer_flush( s16_mtsb_ctrl_buffer_t *b_ptr )
{
    IOLOG( "s16_mtsb_ctrl_buffer_flush" );
    l1sys_flush( b_ptr->coalesce_handle );
}
static INLINE UINT32 s16_mtsb_ctrl_reg_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                             s16_handle_t *h_ptr,
                                             UINT32 A,
                                             UINT32 mem_type,
                                             UINT32 reg ) ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                             s16_handle_t *h_ptr,
                                             UINT32 A,
                                             UINT32 mem_type,
                                             UINT32 reg )
{
    UINT32 value;
    if (b_ptr != NULL)
        value = l1sys_reg_read( b_ptr->coalesce_handle,
                                mem_type,
                                (b_ptr->base_address + (b_ptr->A)*0x1000),
                                reg);
    else
        value = l2sys_reg_read( ((pmc_handle_t *)h_ptr)->sys_handle,
                                mem_type,
                                (((pmc_handle_t *)h_ptr)->base_address + (A)*0x1000) + reg);
    return value;
}
static INLINE void s16_mtsb_ctrl_reg_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                            s16_handle_t *h_ptr,
                                            UINT32 A,
                                            UINT32 mem_type,
                                            UINT32 reg,
                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                            s16_handle_t *h_ptr,
                                            UINT32 A,
                                            UINT32 mem_type,
                                            UINT32 reg,
                                            UINT32 value )
{
    if (b_ptr != NULL)
        l1sys_reg_write( b_ptr->coalesce_handle,
                         mem_type,
                         (b_ptr->base_address + (b_ptr->A)*0x1000),
                         reg,
                         value);
    else
        l2sys_reg_write( ((pmc_handle_t *)h_ptr)->sys_handle,
                         mem_type,
                         (((pmc_handle_t *)h_ptr)->base_address + (A)*0x1000) + reg,
                         value);
}

static INLINE void s16_mtsb_ctrl_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                            s16_handle_t *h_ptr,
                                            UINT32 A,
                                            UINT32 mem_type,
                                            UINT32 reg,
                                            UINT32 mask,
                                            UINT32 unused_mask,
                                            UINT32 ofs,
                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                            s16_handle_t *h_ptr,
                                            UINT32 A,
                                            UINT32 mem_type,
                                            UINT32 reg,
                                            UINT32 mask,
                                            UINT32 unused_mask,
                                            UINT32 ofs,
                                            UINT32 value )
{
    if (b_ptr != NULL)
        l1sys_field_set2( b_ptr->coalesce_handle,
                          mem_type,
                          (b_ptr->base_address + (b_ptr->A)*0x1000),
                          reg,
                          mask,
                          unused_mask,
                          ofs,
                          value);
    else
    {
        if ((mask | unused_mask) == 0xffffffff)
        {
            l2sys_reg_write( ((pmc_handle_t *)h_ptr)->sys_handle,
                             mem_type,
                             (((pmc_handle_t *)h_ptr)->base_address + (A)*0x1000) + reg,
                             value<<ofs);
        }
        else
        {
            l2sys_reg_read_modify_write( ((pmc_handle_t *)h_ptr)->sys_handle,
                                         mem_type,
                                         (((pmc_handle_t *)h_ptr)->base_address + (A)*0x1000) + reg,
                                         mask,
                                         value<<ofs);
        }
    }
}

static INLINE void s16_mtsb_ctrl_action_on_write_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 mem_type,
                                                            UINT32 reg,
                                                            UINT32 mask,
                                                            UINT32 ofs,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_action_on_write_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 mem_type,
                                                            UINT32 reg,
                                                            UINT32 mask,
                                                            UINT32 ofs,
                                                            UINT32 value )
{
    if (b_ptr != NULL)
        l1sys_action_on_write_field_set( b_ptr->coalesce_handle,
                                         mem_type,
                                         (b_ptr->base_address + (b_ptr->A)*0x1000),
                                         reg,
                                         mask,
                                         ofs,
                                         value);
    else
        l2sys_reg_write( ((pmc_handle_t *)h_ptr)->sys_handle,
                         mem_type,
                         (((pmc_handle_t *)h_ptr)->base_address + (A)*0x1000) + reg,
                         value<<ofs);
}

static INLINE void s16_mtsb_ctrl_burst_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                             s16_handle_t *h_ptr,
                                             UINT32 A,
                                             UINT32 mem_type,
                                             UINT32 reg,
                                             UINT32 len,
                                             UINT32 *value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_burst_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                             s16_handle_t *h_ptr,
                                             UINT32 A,
                                             UINT32 mem_type,
                                             UINT32 reg,
                                             UINT32 len,
                                             UINT32 *value )
{
    if (b_ptr != NULL)
        l1sys_burst_read( b_ptr->coalesce_handle,
                          mem_type,
                          (b_ptr->base_address + (b_ptr->A)*0x1000),
                          reg,
                          len,
                          value);
    else
        l2sys_burst_read( ((pmc_handle_t *)h_ptr)->sys_handle,
                          mem_type,
                          (((pmc_handle_t *)h_ptr)->base_address + (A)*0x1000) + reg,
                          len,
                          value);
}

static INLINE void s16_mtsb_ctrl_burst_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                              s16_handle_t *h_ptr,
                                              UINT32 A,
                                              UINT32 mem_type,
                                              UINT32 reg,
                                              UINT32 len,
                                              UINT32 *value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_burst_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                              s16_handle_t *h_ptr,
                                              UINT32 A,
                                              UINT32 mem_type,
                                              UINT32 reg,
                                              UINT32 len,
                                              UINT32 *value )
{
    if (b_ptr != NULL)
        l1sys_burst_write( b_ptr->coalesce_handle,
                           mem_type,
                           (b_ptr->base_address + (b_ptr->A)*0x1000),
                           reg,
                           len,
                           value);
    else
        l2sys_burst_write( ((pmc_handle_t *)h_ptr)->sys_handle,
                           mem_type,
                           (((pmc_handle_t *)h_ptr)->base_address + (A)*0x1000) + reg,
                           len,
                           value);
}

static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                       s16_handle_t *h_ptr,
                                                       UINT32 A,
                                                       UINT32 mem_type,
                                                       UINT32 reg,
                                                       UINT32 mask,
                                                       UINT32 value,
                                                       PMC_POLL_COMPARISON_TYPE cmp,
                                                       UINT32 max_count,
                                                       UINT32 *num_failed_polls,
                                                       UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                       s16_handle_t *h_ptr,
                                                       UINT32 A,
                                                       UINT32 mem_type,
                                                       UINT32 reg,
                                                       UINT32 mask,
                                                       UINT32 value,
                                                       PMC_POLL_COMPARISON_TYPE cmp,
                                                       UINT32 max_count,
                                                       UINT32 *num_failed_polls,
                                                       UINT32 delay_between_polls_in_microseconds )
{
    if (b_ptr != NULL)
        return l1sys_poll( b_ptr->coalesce_handle,
                           mem_type,
                           (b_ptr->base_address + (b_ptr->A)*0x1000),
                           reg,
                           mask,
                           value,
                           cmp,
                           max_count,
                           num_failed_polls,
                           delay_between_polls_in_microseconds);
    else
        return l2sys_poll( ((pmc_handle_t *)h_ptr)->sys_handle,
                           mem_type,
                           (((pmc_handle_t *)h_ptr)->base_address + (A)*0x1000) + reg,
                           mask,
                           value,
                           cmp,
                           max_count,
                           num_failed_polls,
                           delay_between_polls_in_microseconds);
}

/*
 * ==================================================================================
 *  register access functions for s16_mtsb_ctrl
 * ==================================================================================
 */

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_1_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_1_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_1_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                   s16_handle_t *h_ptr,
                                                                                   UINT32 A,
                                                                                   UINT32 mask,
                                                                                   UINT32 ofs,
                                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                   s16_handle_t *h_ptr,
                                                                                   UINT32 A,
                                                                                   UINT32 mask,
                                                                                   UINT32 ofs,
                                                                                   UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                s16_handle_t *h_ptr,
                                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                s16_handle_t *h_ptr,
                                                                                UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                s16_handle_t *h_ptr,
                                                                                UINT32 A,
                                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                s16_handle_t *h_ptr,
                                                                                UINT32 A,
                                                                                UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                    s16_handle_t *h_ptr,
                                                                                    UINT32 A,
                                                                                    UINT32 mask,
                                                                                    UINT32 ofs,
                                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                    s16_handle_t *h_ptr,
                                                                                    UINT32 A,
                                                                                    UINT32 mask,
                                                                                    UINT32 ofs,
                                                                                    UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A,
                                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A,
                                                                                 UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                     s16_handle_t *h_ptr,
                                                                                     UINT32 A,
                                                                                     UINT32 mask,
                                                                                     UINT32 ofs,
                                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                     s16_handle_t *h_ptr,
                                                                                     UINT32 A,
                                                                                     UINT32 mask,
                                                                                     UINT32 ofs,
                                                                                     UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                  s16_handle_t *h_ptr,
                                                                                  UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                  s16_handle_t *h_ptr,
                                                                                  UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                             s16_handle_t *h_ptr,
                                                                             UINT32 A,
                                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                             s16_handle_t *h_ptr,
                                                                             UINT32 A,
                                                                             UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                   s16_handle_t *h_ptr,
                                                                                   UINT32 A,
                                                                                   UINT32 mask,
                                                                                   UINT32 ofs,
                                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                   s16_handle_t *h_ptr,
                                                                                   UINT32 A,
                                                                                   UINT32 mask,
                                                                                   UINT32 ofs,
                                                                                   UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                s16_handle_t *h_ptr,
                                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                s16_handle_t *h_ptr,
                                                                                UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                s16_handle_t *h_ptr,
                                                                                UINT32 A,
                                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                s16_handle_t *h_ptr,
                                                                                UINT32 A,
                                                                                UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                    s16_handle_t *h_ptr,
                                                                                    UINT32 A,
                                                                                    UINT32 mask,
                                                                                    UINT32 ofs,
                                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                    s16_handle_t *h_ptr,
                                                                                    UINT32 A,
                                                                                    UINT32 mask,
                                                                                    UINT32 ofs,
                                                                                    UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 mask,
                                                                           UINT32 ofs,
                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 mask,
                                                                           UINT32 ofs,
                                                                           UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1,
                             mask,
                             PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                s16_handle_t *h_ptr,
                                                                                UINT32 A,
                                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                s16_handle_t *h_ptr,
                                                                                UINT32 A,
                                                                                UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                    s16_handle_t *h_ptr,
                                                                                    UINT32 A,
                                                                                    UINT32 mask,
                                                                                    UINT32 ofs,
                                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                    s16_handle_t *h_ptr,
                                                                                    UINT32 A,
                                                                                    UINT32 mask,
                                                                                    UINT32 ofs,
                                                                                    UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                   s16_handle_t *h_ptr,
                                                                                   UINT32 A,
                                                                                   UINT32 mask,
                                                                                   UINT32 ofs,
                                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                   s16_handle_t *h_ptr,
                                                                                   UINT32 A,
                                                                                   UINT32 mask,
                                                                                   UINT32 ofs,
                                                                                   UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                s16_handle_t *h_ptr,
                                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                s16_handle_t *h_ptr,
                                                                                UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                   s16_handle_t *h_ptr,
                                                                                   UINT32 A,
                                                                                   UINT32 mask,
                                                                                   UINT32 ofs,
                                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                   s16_handle_t *h_ptr,
                                                                                   UINT32 A,
                                                                                   UINT32 mask,
                                                                                   UINT32 ofs,
                                                                                   UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                s16_handle_t *h_ptr,
                                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                s16_handle_t *h_ptr,
                                                                                UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A,
                                                                              UINT32 mask,
                                                                              UINT32 ofs,
                                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A,
                                                                              UINT32 mask,
                                                                              UINT32 ofs,
                                                                              UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_2_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_2_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_2_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_2_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A,
                                                                              UINT32 mask,
                                                                              UINT32 ofs,
                                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_2_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A,
                                                                              UINT32 mask,
                                                                              UINT32 ofs,
                                                                              UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_2_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_2_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_2_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_2_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                             s16_handle_t *h_ptr,
                                                                             UINT32 A,
                                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                             s16_handle_t *h_ptr,
                                                                             UINT32 A,
                                                                             UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                             s16_handle_t *h_ptr,
                                                                             UINT32 A,
                                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                             s16_handle_t *h_ptr,
                                                                             UINT32 A,
                                                                             UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                             s16_handle_t *h_ptr,
                                                                             UINT32 A,
                                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                             s16_handle_t *h_ptr,
                                                                             UINT32 A,
                                                                             UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                             s16_handle_t *h_ptr,
                                                                             UINT32 A,
                                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                             s16_handle_t *h_ptr,
                                                                             UINT32 A,
                                                                             UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A,
                                                                                 UINT32 mask,
                                                                                 UINT32 ofs,
                                                                                 UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_9_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_9_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_9_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_9,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_9_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A,
                                                                              UINT32 mask,
                                                                              UINT32 ofs,
                                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_9_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A,
                                                                              UINT32 mask,
                                                                              UINT32 ofs,
                                                                              UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_9_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_9,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_9_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_9_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_9_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_9);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_9_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_10_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_10_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_10_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_10,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_10_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_10_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_10_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_10,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_10_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_10_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_10_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_10);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_10_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_11_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_11_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_11_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_11,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_11_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_11_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_11_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_11,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_11_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_11_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_11_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_11);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_11_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_12_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_12_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_12_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_12,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_12_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_12_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_12_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_12,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_12_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_12_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_12_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_12);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_12_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_13_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_13_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_13_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_13,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_13_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_13_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_13_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_13,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_13_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_13_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_13_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_13);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_13_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_14_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_14_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_14_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_14,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_14_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_14_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_14_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_14,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_14_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_14_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_14_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_14);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_14_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_15_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_15_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_15_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_15,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_15_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_15_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_15_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_15,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_15_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_15_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_15_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_15);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_15_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_16_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_16_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_16_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_16,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_16_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_16_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 mask,
                                                                               UINT32 ofs,
                                                                               UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_16_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_16,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_16_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_16_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_16_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_16);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_16_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                s16_handle_t *h_ptr,
                                                                                UINT32 A,
                                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                s16_handle_t *h_ptr,
                                                                                UINT32 A,
                                                                                UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                    s16_handle_t *h_ptr,
                                                                                    UINT32 A,
                                                                                    UINT32 mask,
                                                                                    UINT32 ofs,
                                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                    s16_handle_t *h_ptr,
                                                                                    UINT32 A,
                                                                                    UINT32 mask,
                                                                                    UINT32 ofs,
                                                                                    UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A,
                                                                               UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                   s16_handle_t *h_ptr,
                                                                                   UINT32 A,
                                                                                   UINT32 mask,
                                                                                   UINT32 ofs,
                                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                   s16_handle_t *h_ptr,
                                                                                   UINT32 A,
                                                                                   UINT32 mask,
                                                                                   UINT32 ofs,
                                                                                   UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                s16_handle_t *h_ptr,
                                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                s16_handle_t *h_ptr,
                                                                                UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A,
                                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A,
                                                                                 UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                     s16_handle_t *h_ptr,
                                                                                     UINT32 A,
                                                                                     UINT32 mask,
                                                                                     UINT32 ofs,
                                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                     s16_handle_t *h_ptr,
                                                                                     UINT32 A,
                                                                                     UINT32 mask,
                                                                                     UINT32 ofs,
                                                                                     UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                  s16_handle_t *h_ptr,
                                                                                  UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                  s16_handle_t *h_ptr,
                                                                                  UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A,
                                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A,
                                                                                 UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                     s16_handle_t *h_ptr,
                                                                                     UINT32 A,
                                                                                     UINT32 mask,
                                                                                     UINT32 ofs,
                                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                     s16_handle_t *h_ptr,
                                                                                     UINT32 A,
                                                                                     UINT32 mask,
                                                                                     UINT32 ofs,
                                                                                     UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                  s16_handle_t *h_ptr,
                                                                                  UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                  s16_handle_t *h_ptr,
                                                                                  UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A,
                                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A,
                                                                                 UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                     s16_handle_t *h_ptr,
                                                                                     UINT32 A,
                                                                                     UINT32 mask,
                                                                                     UINT32 ofs,
                                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                     s16_handle_t *h_ptr,
                                                                                     UINT32 A,
                                                                                     UINT32 mask,
                                                                                     UINT32 ofs,
                                                                                     UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                  s16_handle_t *h_ptr,
                                                                                  UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                  s16_handle_t *h_ptr,
                                                                                  UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A,
                                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A,
                                                                                 UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                     s16_handle_t *h_ptr,
                                                                                     UINT32 A,
                                                                                     UINT32 mask,
                                                                                     UINT32 ofs,
                                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                     s16_handle_t *h_ptr,
                                                                                     UINT32 A,
                                                                                     UINT32 mask,
                                                                                     UINT32 ofs,
                                                                                     UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                  s16_handle_t *h_ptr,
                                                                                  UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                  s16_handle_t *h_ptr,
                                                                                  UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                    s16_handle_t *h_ptr,
                                                                                    UINT32 A,
                                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                    s16_handle_t *h_ptr,
                                                                                    UINT32 A,
                                                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                        s16_handle_t *h_ptr,
                                                                                        UINT32 A,
                                                                                        UINT32 mask,
                                                                                        UINT32 ofs,
                                                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                        s16_handle_t *h_ptr,
                                                                                        UINT32 A,
                                                                                        UINT32 mask,
                                                                                        UINT32 ofs,
                                                                                        UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                     s16_handle_t *h_ptr,
                                                                                     UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                     s16_handle_t *h_ptr,
                                                                                     UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                    s16_handle_t *h_ptr,
                                                                                    UINT32 A,
                                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                    s16_handle_t *h_ptr,
                                                                                    UINT32 A,
                                                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                        s16_handle_t *h_ptr,
                                                                                        UINT32 A,
                                                                                        UINT32 mask,
                                                                                        UINT32 ofs,
                                                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                        s16_handle_t *h_ptr,
                                                                                        UINT32 A,
                                                                                        UINT32 mask,
                                                                                        UINT32 ofs,
                                                                                        UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                     s16_handle_t *h_ptr,
                                                                                     UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                     s16_handle_t *h_ptr,
                                                                                     UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                    s16_handle_t *h_ptr,
                                                                                    UINT32 A,
                                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                    s16_handle_t *h_ptr,
                                                                                    UINT32 A,
                                                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                        s16_handle_t *h_ptr,
                                                                                        UINT32 A,
                                                                                        UINT32 mask,
                                                                                        UINT32 ofs,
                                                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                        s16_handle_t *h_ptr,
                                                                                        UINT32 A,
                                                                                        UINT32 mask,
                                                                                        UINT32 ofs,
                                                                                        UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                     s16_handle_t *h_ptr,
                                                                                     UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                     s16_handle_t *h_ptr,
                                                                                     UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                    s16_handle_t *h_ptr,
                                                                                    UINT32 A,
                                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                    s16_handle_t *h_ptr,
                                                                                    UINT32 A,
                                                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                        s16_handle_t *h_ptr,
                                                                                        UINT32 A,
                                                                                        UINT32 mask,
                                                                                        UINT32 ofs,
                                                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                        s16_handle_t *h_ptr,
                                                                                        UINT32 A,
                                                                                        UINT32 mask,
                                                                                        UINT32 ofs,
                                                                                        UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                     s16_handle_t *h_ptr,
                                                                                     UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                     s16_handle_t *h_ptr,
                                                                                     UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                      s16_handle_t *h_ptr,
                                                                                      UINT32 A,
                                                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                      s16_handle_t *h_ptr,
                                                                                      UINT32 A,
                                                                                      UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                          s16_handle_t *h_ptr,
                                                                                          UINT32 A,
                                                                                          UINT32 mask,
                                                                                          UINT32 ofs,
                                                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                          s16_handle_t *h_ptr,
                                                                                          UINT32 A,
                                                                                          UINT32 mask,
                                                                                          UINT32 ofs,
                                                                                          UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                       s16_handle_t *h_ptr,
                                                                                       UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                       s16_handle_t *h_ptr,
                                                                                       UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A,
                                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A,
                                                                                 UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                     s16_handle_t *h_ptr,
                                                                                     UINT32 A,
                                                                                     UINT32 mask,
                                                                                     UINT32 ofs,
                                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                     s16_handle_t *h_ptr,
                                                                                     UINT32 A,
                                                                                     UINT32 mask,
                                                                                     UINT32 ofs,
                                                                                     UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                  s16_handle_t *h_ptr,
                                                                                  UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                  s16_handle_t *h_ptr,
                                                                                  UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_VGP_STRT_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                    s16_handle_t *h_ptr,
                                                                                    UINT32 A,
                                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_VGP_STRT_CFG_1_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                    s16_handle_t *h_ptr,
                                                                                    UINT32 A,
                                                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_VGP_STRT_CFG_1_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_VGP_STRT_CFG_1,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_VGP_STRT_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                        s16_handle_t *h_ptr,
                                                                                        UINT32 A,
                                                                                        UINT32 mask,
                                                                                        UINT32 ofs,
                                                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_VGP_STRT_CFG_1_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                        s16_handle_t *h_ptr,
                                                                                        UINT32 A,
                                                                                        UINT32 mask,
                                                                                        UINT32 ofs,
                                                                                        UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_VGP_STRT_CFG_1_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_CONFIG,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_VGP_STRT_CFG_1,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_VGP_STRT_CFG_1_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_VGP_STRT_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                     s16_handle_t *h_ptr,
                                                                                     UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_VGP_STRT_CFG_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                     s16_handle_t *h_ptr,
                                                                                     UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_CONFIG,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_VGP_STRT_CFG_1);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_VGP_STRT_CFG_1_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                    s16_handle_t *h_ptr,
                                                                                    UINT32 A,
                                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                    s16_handle_t *h_ptr,
                                                                                    UINT32 A,
                                                                                    UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_STATUS,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_action_on_write_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                                        s16_handle_t *h_ptr,
                                                                                                        UINT32 A,
                                                                                                        UINT32 mask,
                                                                                                        UINT32 ofs,
                                                                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_action_on_write_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                                        s16_handle_t *h_ptr,
                                                                                                        UINT32 A,
                                                                                                        UINT32 mask,
                                                                                                        UINT32 ofs,
                                                                                                        UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_action_on_write_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_action_on_write_field_set( b_ptr,
                                             h_ptr,
                                             A,
                                             MEM_TYPE_STATUS,
                                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT,
                                             mask,
                                             ofs,
                                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                     s16_handle_t *h_ptr,
                                                                                     UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                     s16_handle_t *h_ptr,
                                                                                     UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_STATUS,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_read", reg_value, A);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                                   s16_handle_t *h_ptr,
                                                                                                   UINT32 A,
                                                                                                   UINT32 mask,
                                                                                                   UINT32 value,
                                                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                                                   UINT32 max_count,
                                                                                                   UINT32 *num_failed_polls,
                                                                                                   UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                                   s16_handle_t *h_ptr,
                                                                                                   UINT32 A,
                                                                                                   UINT32 mask,
                                                                                                   UINT32 value,
                                                                                                   PMC_POLL_COMPARISON_TYPE cmp,
                                                                                                   UINT32 max_count,
                                                                                                   UINT32 *num_failed_polls,
                                                                                                   UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return s16_mtsb_ctrl_poll( b_ptr,
                               h_ptr,
                               A,
                               MEM_TYPE_STATUS,
                               PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT,
                               mask,
                               value,
                               cmp,
                               max_count,
                               num_failed_polls,
                               delay_between_polls_in_microseconds);

}


static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_E_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_E_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_E_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_STATUS,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_E_action_on_write_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                               s16_handle_t *h_ptr,
                                                                                               UINT32 A,
                                                                                               UINT32 mask,
                                                                                               UINT32 ofs,
                                                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_E_action_on_write_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                               s16_handle_t *h_ptr,
                                                                                               UINT32 A,
                                                                                               UINT32 mask,
                                                                                               UINT32 ofs,
                                                                                               UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_E_action_on_write_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_action_on_write_field_set( b_ptr,
                                             h_ptr,
                                             A,
                                             MEM_TYPE_STATUS,
                                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E,
                                             mask,
                                             ofs,
                                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_E_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_E_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_STATUS,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_E_read", reg_value, A);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_E_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                          s16_handle_t *h_ptr,
                                                                                          UINT32 A,
                                                                                          UINT32 mask,
                                                                                          UINT32 value,
                                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                                          UINT32 max_count,
                                                                                          UINT32 *num_failed_polls,
                                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_E_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                          s16_handle_t *h_ptr,
                                                                                          UINT32 A,
                                                                                          UINT32 mask,
                                                                                          UINT32 value,
                                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                                          UINT32 max_count,
                                                                                          UINT32 *num_failed_polls,
                                                                                          UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_E_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return s16_mtsb_ctrl_poll( b_ptr,
                               h_ptr,
                               A,
                               MEM_TYPE_STATUS,
                               PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E,
                               mask,
                               value,
                               cmp,
                               max_count,
                               num_failed_polls,
                               delay_between_polls_in_microseconds);

}


static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A,
                                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A,
                                                                                 UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_STATUS,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                     s16_handle_t *h_ptr,
                                                                                     UINT32 A,
                                                                                     UINT32 mask,
                                                                                     UINT32 ofs,
                                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                     s16_handle_t *h_ptr,
                                                                                     UINT32 A,
                                                                                     UINT32 mask,
                                                                                     UINT32 ofs,
                                                                                     UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_STATUS,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                  s16_handle_t *h_ptr,
                                                                                  UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                  s16_handle_t *h_ptr,
                                                                                  UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_STATUS,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN_read", reg_value, A);
    return reg_value;
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_write( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 value )
{
    IOLOG( "%s <- 0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_write", value );
    s16_mtsb_ctrl_reg_write( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_STATUS,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT,
                             value);
}

static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                             s16_handle_t *h_ptr,
                                                                             UINT32 A,
                                                                             UINT32 mask,
                                                                             UINT32 ofs,
                                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_field_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                             s16_handle_t *h_ptr,
                                                                             UINT32 A,
                                                                             UINT32 mask,
                                                                             UINT32 ofs,
                                                                             UINT32 value )
{
    IOLOG( "%s <- A=%d mask=0x%08x ofs=%d value=0x%08x", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_field_set", A, mask, ofs, value );
    s16_mtsb_ctrl_field_set( b_ptr,
                             h_ptr,
                             A,
                             MEM_TYPE_STATUS,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT,
                             mask,
                             PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_UNUSED_MASK,
                             ofs,
                             value);

}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_STATUS,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_read", reg_value, A);
    return reg_value;
}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                               s16_handle_t *h_ptr,
                                                                               UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_STATUS,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_read", reg_value, A);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                             s16_handle_t *h_ptr,
                                                                                             UINT32 A,
                                                                                             UINT32 mask,
                                                                                             UINT32 value,
                                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                                             UINT32 max_count,
                                                                                             UINT32 *num_failed_polls,
                                                                                             UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                             s16_handle_t *h_ptr,
                                                                                             UINT32 A,
                                                                                             UINT32 mask,
                                                                                             UINT32 value,
                                                                                             PMC_POLL_COMPARISON_TYPE cmp,
                                                                                             UINT32 max_count,
                                                                                             UINT32 *num_failed_polls,
                                                                                             UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return s16_mtsb_ctrl_poll( b_ptr,
                               h_ptr,
                               A,
                               MEM_TYPE_STATUS,
                               PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT,
                               mask,
                               value,
                               cmp,
                               max_count,
                               num_failed_polls,
                               delay_between_polls_in_microseconds);

}


static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_V_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_V_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_STATUS,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_V_read", reg_value, A);
    return reg_value;
}
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_V_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                          s16_handle_t *h_ptr,
                                                                                          UINT32 A,
                                                                                          UINT32 mask,
                                                                                          UINT32 value,
                                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                                          UINT32 max_count,
                                                                                          UINT32 *num_failed_polls,
                                                                                          UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_V_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                          s16_handle_t *h_ptr,
                                                                                          UINT32 A,
                                                                                          UINT32 mask,
                                                                                          UINT32 value,
                                                                                          PMC_POLL_COMPARISON_TYPE cmp,
                                                                                          UINT32 max_count,
                                                                                          UINT32 *num_failed_polls,
                                                                                          UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s mask=0x%08x, value=0x%08x, cmp=%d, max_count=%d, delay_between_polls_in_microseconds=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_V_poll", mask, value, cmp, max_count, delay_between_polls_in_microseconds );
    return s16_mtsb_ctrl_poll( b_ptr,
                               h_ptr,
                               A,
                               MEM_TYPE_STATUS,
                               PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V,
                               mask,
                               value,
                               cmp,
                               max_count,
                               num_failed_polls,
                               delay_between_polls_in_microseconds);

}


static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                s16_handle_t *h_ptr,
                                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                s16_handle_t *h_ptr,
                                                                                UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_STATUS,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_read", reg_value, A);
    return reg_value;
}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_STS_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                s16_handle_t *h_ptr,
                                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_STS_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                s16_handle_t *h_ptr,
                                                                                UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_STATUS,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_STS_1);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_STS_1_read", reg_value, A);
    return reg_value;
}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_PGA_LUT_TBL_STS_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_PGA_LUT_TBL_STS_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_STATUS,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_STS_1);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_PGA_LUT_TBL_STS_1_read", reg_value, A);
    return reg_value;
}

static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                  s16_handle_t *h_ptr,
                                                                                  UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_read( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                  s16_handle_t *h_ptr,
                                                                                  UINT32 A )
{
    UINT32 reg_value;

    reg_value = s16_mtsb_ctrl_reg_read( b_ptr,
                                        h_ptr,
                                        A,
                                        MEM_TYPE_STATUS,
                                        PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1);

    IOLOG( "%s -> 0x%08x; A=%d", "s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_read", reg_value, A);
    return reg_value;
}

/*
 * ==================================================================================
 * Parameter Access Functions for Paramset config
 * ==================================================================================
 */
static INLINE void s16_mtsb_ctrl_field_CTRL_INITCAL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_CTRL_INITCAL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A,
                                                         UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_CTRL_INITCAL_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_CTRL_INITCAL_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_CTRL_INITCAL_set", A, value );

    /* (0x00000400 bits 6) field CTRL_INITCAL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_1_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1_BIT_CTRL_INITCAL_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1_BIT_CTRL_INITCAL_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_CTRL_INITCAL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_CTRL_INITCAL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_CTRL_INITCAL_get", A, 15);
    /* (0x00000400 bits 6) field CTRL_INITCAL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_1_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1_BIT_CTRL_INITCAL_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1_BIT_CTRL_INITCAL_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_CTRL_INITCAL_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_CONTINUOUS_ADAPT_SNW_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_CONTINUOUS_ADAPT_SNW_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_CONTINUOUS_ADAPT_SNW_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_CONTINUOUS_ADAPT_SNW_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_CONTINUOUS_ADAPT_SNW_set", A, value );

    /* (0x00000400 bits 5) field CONTINUOUS_ADAPT_SNW of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_1_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1_BIT_CONTINUOUS_ADAPT_SNW_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1_BIT_CONTINUOUS_ADAPT_SNW_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_CONTINUOUS_ADAPT_SNW_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_CONTINUOUS_ADAPT_SNW_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_CONTINUOUS_ADAPT_SNW_get", A, 15);
    /* (0x00000400 bits 5) field CONTINUOUS_ADAPT_SNW of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_1_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1_BIT_CONTINUOUS_ADAPT_SNW_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1_BIT_CONTINUOUS_ADAPT_SNW_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_CONTINUOUS_ADAPT_SNW_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADAPT_INIT_FORCE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADAPT_INIT_FORCE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_INIT_FORCE_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADAPT_INIT_FORCE_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_INIT_FORCE_set", A, value );

    /* (0x00000400 bits 4) field ADAPT_INIT_FORCE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_1_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1_BIT_ADAPT_INIT_FORCE_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1_BIT_ADAPT_INIT_FORCE_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_INIT_FORCE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_INIT_FORCE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_INIT_FORCE_get", A, 15);
    /* (0x00000400 bits 4) field ADAPT_INIT_FORCE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_1_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1_BIT_ADAPT_INIT_FORCE_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1_BIT_ADAPT_INIT_FORCE_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_INIT_FORCE_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_RESET_CLBRT_FSM_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_RESET_CLBRT_FSM_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RESET_CLBRT_FSM_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_RESET_CLBRT_FSM_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_RESET_CLBRT_FSM_set", A, value );

    /* (0x00000400 bits 2) field RESET_CLBRT_FSM of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_1_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1_BIT_RESET_CLBRT_FSM_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1_BIT_RESET_CLBRT_FSM_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_RESET_CLBRT_FSM_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_RESET_CLBRT_FSM_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RESET_CLBRT_FSM_get", A, 15);
    /* (0x00000400 bits 2) field RESET_CLBRT_FSM of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_1_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1_BIT_RESET_CLBRT_FSM_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1_BIT_RESET_CLBRT_FSM_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_RESET_CLBRT_FSM_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_RESET_ADPT_FSM_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_RESET_ADPT_FSM_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A,
                                                           UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RESET_ADPT_FSM_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_RESET_ADPT_FSM_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_RESET_ADPT_FSM_set", A, value );

    /* (0x00000400 bits 1) field RESET_ADPT_FSM of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_1_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1_BIT_RESET_ADPT_FSM_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1_BIT_RESET_ADPT_FSM_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_RESET_ADPT_FSM_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_RESET_ADPT_FSM_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RESET_ADPT_FSM_get", A, 15);
    /* (0x00000400 bits 1) field RESET_ADPT_FSM of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_1_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1_BIT_RESET_ADPT_FSM_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1_BIT_RESET_ADPT_FSM_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_RESET_ADPT_FSM_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_RESET_SYNCR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_RESET_SYNCR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A,
                                                        UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RESET_SYNCR_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_RESET_SYNCR_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_RESET_SYNCR_set", A, value );

    /* (0x00000400 bits 0) field RESET_SYNCR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_1_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1_BIT_RESET_SYNCR_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1_BIT_RESET_SYNCR_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_RESET_SYNCR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_RESET_SYNCR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RESET_SYNCR_get", A, 15);
    /* (0x00000400 bits 0) field RESET_SYNCR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_1_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1_BIT_RESET_SYNCR_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_1_BIT_RESET_SYNCR_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_RESET_SYNCR_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_RX_CM_STG2_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                       s16_handle_t *h_ptr,
                                                       UINT32 A,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_RX_CM_STG2_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                       s16_handle_t *h_ptr,
                                                       UINT32 A,
                                                       UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RX_CM_STG2_set", A, 15);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_RX_CM_STG2_set", value, 15);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_RX_CM_STG2_set", A, value );

    /* (0x00000404 bits 27:24) field RX_CM_STG2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_STG2_MSK,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_STG2_OFF,
                                                                    value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_RX_CM_STG2_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_RX_CM_STG2_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RX_CM_STG2_get", A, 15);
    /* (0x00000404 bits 27:24) field RX_CM_STG2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_STG2_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_STG2_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_RX_CM_STG2_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_RX_CM_STG2_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_RX_CM_STG2_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_RX_CM_STG2_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_RX_CM_STG2_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_RX_CM_STG2_set", stop_bit, 3 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_RX_CM_STG2_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000404 bits 27:24) field RX_CM_STG2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000404 bits 27:24) field RX_CM_STG2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_field_set( b_ptr,
                                                                        h_ptr,
                                                                        A,
                                                                        subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_STG2_OFF + subfield_offset),
                                                                        PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_STG2_OFF + subfield_offset,
                                                                        value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_RX_CM_STG2_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_RX_CM_STG2_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_RX_CM_STG2_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_RX_CM_STG2_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_RX_CM_STG2_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000404 bits 27:24) field RX_CM_STG2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_STG2_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_STG2_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_STG2_MSK, PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_STG2_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_RX_CM_STG2_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_RX_CM_STG1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                       s16_handle_t *h_ptr,
                                                       UINT32 A,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_RX_CM_STG1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                       s16_handle_t *h_ptr,
                                                       UINT32 A,
                                                       UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RX_CM_STG1_set", A, 15);
    if (value > 31)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_RX_CM_STG1_set", value, 31);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_RX_CM_STG1_set", A, value );

    /* (0x00000404 bits 23:19) field RX_CM_STG1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_STG1_MSK,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_STG1_OFF,
                                                                    value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_RX_CM_STG1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_RX_CM_STG1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RX_CM_STG1_get", A, 15);
    /* (0x00000404 bits 23:19) field RX_CM_STG1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_STG1_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_STG1_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_RX_CM_STG1_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_RX_CM_STG1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_RX_CM_STG1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_RX_CM_STG1_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_RX_CM_STG1_set", stop_bit, start_bit );
    if (stop_bit > 4) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_RX_CM_STG1_set", stop_bit, 4 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_RX_CM_STG1_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000404 bits 23:19) field RX_CM_STG1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 4) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 4;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000404 bits 23:19) field RX_CM_STG1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_field_set( b_ptr,
                                                                        h_ptr,
                                                                        A,
                                                                        subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_STG1_OFF + subfield_offset),
                                                                        PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_STG1_OFF + subfield_offset,
                                                                        value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_RX_CM_STG1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_RX_CM_STG1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_RX_CM_STG1_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_RX_CM_STG1_get", stop_bit, start_bit );
    if (stop_bit > 4) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_RX_CM_STG1_get", stop_bit, 4 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 4) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 4;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000404 bits 23:19) field RX_CM_STG1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_STG1_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_STG1_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_STG1_MSK, PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_STG1_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_RX_CM_STG1_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_RX_CM_TERM_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                       s16_handle_t *h_ptr,
                                                       UINT32 A,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_RX_CM_TERM_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                       s16_handle_t *h_ptr,
                                                       UINT32 A,
                                                       UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RX_CM_TERM_set", A, 15);
    if (value > 31)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_RX_CM_TERM_set", value, 31);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_RX_CM_TERM_set", A, value );

    /* (0x00000404 bits 18:14) field RX_CM_TERM of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_TERM_MSK,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_TERM_OFF,
                                                                    value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_RX_CM_TERM_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_RX_CM_TERM_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RX_CM_TERM_get", A, 15);
    /* (0x00000404 bits 18:14) field RX_CM_TERM of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_TERM_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_TERM_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_RX_CM_TERM_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_RX_CM_TERM_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_RX_CM_TERM_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_RX_CM_TERM_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_RX_CM_TERM_set", stop_bit, start_bit );
    if (stop_bit > 4) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_RX_CM_TERM_set", stop_bit, 4 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_RX_CM_TERM_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000404 bits 18:14) field RX_CM_TERM of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 4) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 4;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000404 bits 18:14) field RX_CM_TERM of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_field_set( b_ptr,
                                                                        h_ptr,
                                                                        A,
                                                                        subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_TERM_OFF + subfield_offset),
                                                                        PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_TERM_OFF + subfield_offset,
                                                                        value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_RX_CM_TERM_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_RX_CM_TERM_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_RX_CM_TERM_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_RX_CM_TERM_get", stop_bit, start_bit );
    if (stop_bit > 4) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_RX_CM_TERM_get", stop_bit, 4 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 4) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 4;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000404 bits 18:14) field RX_CM_TERM of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_TERM_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_TERM_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_TERM_MSK, PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_CM_TERM_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_RX_CM_TERM_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PGA_GAIN_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PGA_GAIN_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PGA_GAIN_PRELOAD_set", A, 15);
    if (value > 31)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PGA_GAIN_PRELOAD_set", value, 31);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PGA_GAIN_PRELOAD_set", A, value );

    /* (0x00000404 bits 8:4) field PGA_GAIN_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_PGA_GAIN_PRELOAD_MSK,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_PGA_GAIN_PRELOAD_OFF,
                                                                    value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PGA_GAIN_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PGA_GAIN_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PGA_GAIN_PRELOAD_get", A, 15);
    /* (0x00000404 bits 8:4) field PGA_GAIN_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_PGA_GAIN_PRELOAD_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_PGA_GAIN_PRELOAD_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PGA_GAIN_PRELOAD_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PGA_GAIN_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PGA_GAIN_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PGA_GAIN_PRELOAD_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PGA_GAIN_PRELOAD_set", stop_bit, start_bit );
    if (stop_bit > 4) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PGA_GAIN_PRELOAD_set", stop_bit, 4 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PGA_GAIN_PRELOAD_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000404 bits 8:4) field PGA_GAIN_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 4) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 4;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000404 bits 8:4) field PGA_GAIN_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_field_set( b_ptr,
                                                                        h_ptr,
                                                                        A,
                                                                        subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_PGA_GAIN_PRELOAD_OFF + subfield_offset),
                                                                        PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_PGA_GAIN_PRELOAD_OFF + subfield_offset,
                                                                        value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PGA_GAIN_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PGA_GAIN_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PGA_GAIN_PRELOAD_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PGA_GAIN_PRELOAD_get", stop_bit, start_bit );
    if (stop_bit > 4) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PGA_GAIN_PRELOAD_get", stop_bit, 4 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 4) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 4;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000404 bits 8:4) field PGA_GAIN_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_PGA_GAIN_PRELOAD_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_PGA_GAIN_PRELOAD_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_PGA_GAIN_PRELOAD_MSK, PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_PGA_GAIN_PRELOAD_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PGA_GAIN_PRELOAD_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_RX_PEAK_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_RX_PEAK_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A,
                                                        UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RX_PEAK_ENB_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_RX_PEAK_ENB_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_RX_PEAK_ENB_set", A, value );

    /* (0x00000404 bits 3) field RX_PEAK_ENB of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_PEAK_ENB_MSK,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_PEAK_ENB_OFF,
                                                                    value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_RX_PEAK_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_RX_PEAK_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RX_PEAK_ENB_get", A, 15);
    /* (0x00000404 bits 3) field RX_PEAK_ENB of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_PEAK_ENB_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_PEAK_ENB_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_RX_PEAK_ENB_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_RX_PEAK_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                    s16_handle_t *h_ptr,
                                                    UINT32 A,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_RX_PEAK_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                    s16_handle_t *h_ptr,
                                                    UINT32 A,
                                                    UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RX_PEAK_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_RX_PEAK_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_RX_PEAK_set", A, value );

    /* (0x00000404 bits 2:0) field RX_PEAK of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_PEAK_MSK,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_PEAK_OFF,
                                                                    value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_RX_PEAK_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                      s16_handle_t *h_ptr,
                                                      UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_RX_PEAK_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                      s16_handle_t *h_ptr,
                                                      UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RX_PEAK_get", A, 15);
    /* (0x00000404 bits 2:0) field RX_PEAK of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_PEAK_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_PEAK_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_RX_PEAK_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_RX_PEAK_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_RX_PEAK_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_RX_PEAK_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_RX_PEAK_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_RX_PEAK_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_RX_PEAK_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000404 bits 2:0) field RX_PEAK of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000404 bits 2:0) field RX_PEAK of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_field_set( b_ptr,
                                                                        h_ptr,
                                                                        A,
                                                                        subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_PEAK_OFF + subfield_offset),
                                                                        PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_PEAK_OFF + subfield_offset,
                                                                        value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_RX_PEAK_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_RX_PEAK_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_RX_PEAK_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_RX_PEAK_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_RX_PEAK_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000404 bits 2:0) field RX_PEAK of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_PEAK_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_PEAK_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_PEAK_MSK, PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PGA_CFG_1_BIT_RX_PEAK_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_RX_PEAK_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PRECURSOR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                      s16_handle_t *h_ptr,
                                                      UINT32 A,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PRECURSOR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                      s16_handle_t *h_ptr,
                                                      UINT32 A,
                                                      UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PRECURSOR_set", A, 15);
    if (value > 63)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PRECURSOR_set", value, 63);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PRECURSOR_set", A, value );

    /* (0x00000408 bits 31:26) field PRECURSOR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_field_set( b_ptr,
                                                                     h_ptr,
                                                                     A,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_PRECURSOR_MSK,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_PRECURSOR_OFF,
                                                                     value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PRECURSOR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PRECURSOR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PRECURSOR_get", A, 15);
    /* (0x00000408 bits 31:26) field PRECURSOR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_PRECURSOR_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_PRECURSOR_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PRECURSOR_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PRECURSOR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PRECURSOR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit,
                                                            UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PRECURSOR_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PRECURSOR_set", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PRECURSOR_set", stop_bit, 5 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PRECURSOR_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000408 bits 31:26) field PRECURSOR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 5) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 5;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000408 bits 31:26) field PRECURSOR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_field_set( b_ptr,
                                                                         h_ptr,
                                                                         A,
                                                                         subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_PRECURSOR_OFF + subfield_offset),
                                                                         PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_PRECURSOR_OFF + subfield_offset,
                                                                         value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PRECURSOR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PRECURSOR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PRECURSOR_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PRECURSOR_get", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PRECURSOR_get", stop_bit, 5 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 5) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 5;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000408 bits 31:26) field PRECURSOR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_PRECURSOR_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_PRECURSOR_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_PRECURSOR_MSK, PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_PRECURSOR_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PRECURSOR_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_POSTCURSOR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                       s16_handle_t *h_ptr,
                                                       UINT32 A,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_POSTCURSOR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                       s16_handle_t *h_ptr,
                                                       UINT32 A,
                                                       UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_POSTCURSOR_set", A, 15);
    if (value > 63)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_POSTCURSOR_set", value, 63);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_POSTCURSOR_set", A, value );

    /* (0x00000408 bits 23:18) field POSTCURSOR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_field_set( b_ptr,
                                                                     h_ptr,
                                                                     A,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_POSTCURSOR_MSK,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_POSTCURSOR_OFF,
                                                                     value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_POSTCURSOR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_POSTCURSOR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_POSTCURSOR_get", A, 15);
    /* (0x00000408 bits 23:18) field POSTCURSOR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_POSTCURSOR_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_POSTCURSOR_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_POSTCURSOR_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_POSTCURSOR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_POSTCURSOR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_POSTCURSOR_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_POSTCURSOR_set", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_POSTCURSOR_set", stop_bit, 5 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_POSTCURSOR_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000408 bits 23:18) field POSTCURSOR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 5) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 5;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000408 bits 23:18) field POSTCURSOR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_field_set( b_ptr,
                                                                         h_ptr,
                                                                         A,
                                                                         subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_POSTCURSOR_OFF + subfield_offset),
                                                                         PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_POSTCURSOR_OFF + subfield_offset,
                                                                         value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_POSTCURSOR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_POSTCURSOR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_POSTCURSOR_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_POSTCURSOR_get", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_POSTCURSOR_get", stop_bit, 5 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 5) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 5;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000408 bits 23:18) field POSTCURSOR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_POSTCURSOR_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_POSTCURSOR_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_POSTCURSOR_MSK, PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_POSTCURSOR_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_POSTCURSOR_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_AMPLITUDE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                      s16_handle_t *h_ptr,
                                                      UINT32 A,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_AMPLITUDE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                      s16_handle_t *h_ptr,
                                                      UINT32 A,
                                                      UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_AMPLITUDE_set", A, 15);
    if (value > 127)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_AMPLITUDE_set", value, 127);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_AMPLITUDE_set", A, value );

    /* (0x00000408 bits 14:8) field AMPLITUDE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_field_set( b_ptr,
                                                                     h_ptr,
                                                                     A,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_AMPLITUDE_MSK,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_AMPLITUDE_OFF,
                                                                     value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_AMPLITUDE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_AMPLITUDE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_AMPLITUDE_get", A, 15);
    /* (0x00000408 bits 14:8) field AMPLITUDE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_AMPLITUDE_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_AMPLITUDE_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_AMPLITUDE_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_AMPLITUDE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_AMPLITUDE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit,
                                                            UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_AMPLITUDE_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_AMPLITUDE_set", stop_bit, start_bit );
    if (stop_bit > 6) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_AMPLITUDE_set", stop_bit, 6 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_AMPLITUDE_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000408 bits 14:8) field AMPLITUDE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 6) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 6;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000408 bits 14:8) field AMPLITUDE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_field_set( b_ptr,
                                                                         h_ptr,
                                                                         A,
                                                                         subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_AMPLITUDE_OFF + subfield_offset),
                                                                         PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_AMPLITUDE_OFF + subfield_offset,
                                                                         value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_AMPLITUDE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_AMPLITUDE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_AMPLITUDE_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_AMPLITUDE_get", stop_bit, start_bit );
    if (stop_bit > 6) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_AMPLITUDE_get", stop_bit, 6 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 6) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 6;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000408 bits 14:8) field AMPLITUDE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_AMPLITUDE_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_AMPLITUDE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_AMPLITUDE_MSK, PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_AMPLITUDE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_AMPLITUDE_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_T_PISO_PRE2_SEL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_T_PISO_PRE2_SEL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_T_PISO_PRE2_SEL_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_T_PISO_PRE2_SEL_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_T_PISO_PRE2_SEL_set", A, value );

    /* (0x00000408 bits 4) field T_PISO_PRE2_SEL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_field_set( b_ptr,
                                                                     h_ptr,
                                                                     A,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_T_PISO_PRE2_SEL_MSK,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_T_PISO_PRE2_SEL_OFF,
                                                                     value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_T_PISO_PRE2_SEL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_T_PISO_PRE2_SEL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_T_PISO_PRE2_SEL_get", A, 15);
    /* (0x00000408 bits 4) field T_PISO_PRE2_SEL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_T_PISO_PRE2_SEL_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_T_PISO_PRE2_SEL_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_T_PISO_PRE2_SEL_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_T_PISO_EDGE_DELAY_SEL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_T_PISO_EDGE_DELAY_SEL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_T_PISO_EDGE_DELAY_SEL_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_T_PISO_EDGE_DELAY_SEL_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_T_PISO_EDGE_DELAY_SEL_set", A, value );

    /* (0x00000408 bits 3) field T_PISO_EDGE_DELAY_SEL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_field_set( b_ptr,
                                                                     h_ptr,
                                                                     A,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_T_PISO_EDGE_DELAY_SEL_MSK,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_T_PISO_EDGE_DELAY_SEL_OFF,
                                                                     value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_T_PISO_EDGE_DELAY_SEL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_T_PISO_EDGE_DELAY_SEL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_T_PISO_EDGE_DELAY_SEL_get", A, 15);
    /* (0x00000408 bits 3) field T_PISO_EDGE_DELAY_SEL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_T_PISO_EDGE_DELAY_SEL_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_T_PISO_EDGE_DELAY_SEL_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_T_PISO_EDGE_DELAY_SEL_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_T_PISO_PRE2_MODE1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_T_PISO_PRE2_MODE1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_T_PISO_PRE2_MODE1_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_T_PISO_PRE2_MODE1_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_T_PISO_PRE2_MODE1_set", A, value );

    /* (0x00000408 bits 2) field T_PISO_PRE2_MODE1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_field_set( b_ptr,
                                                                     h_ptr,
                                                                     A,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_T_PISO_PRE2_MODE1_MSK,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_T_PISO_PRE2_MODE1_OFF,
                                                                     value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_T_PISO_PRE2_MODE1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_T_PISO_PRE2_MODE1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_T_PISO_PRE2_MODE1_get", A, 15);
    /* (0x00000408 bits 2) field T_PISO_PRE2_MODE1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_T_PISO_PRE2_MODE1_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_T_PISO_PRE2_MODE1_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_T_PISO_PRE2_MODE1_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_T_PISO_PRE2_MODE0_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_T_PISO_PRE2_MODE0_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_T_PISO_PRE2_MODE0_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_T_PISO_PRE2_MODE0_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_T_PISO_PRE2_MODE0_set", A, value );

    /* (0x00000408 bits 1) field T_PISO_PRE2_MODE0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_field_set( b_ptr,
                                                                     h_ptr,
                                                                     A,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_T_PISO_PRE2_MODE0_MSK,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_T_PISO_PRE2_MODE0_OFF,
                                                                     value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_T_PISO_PRE2_MODE0_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_T_PISO_PRE2_MODE0_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_T_PISO_PRE2_MODE0_get", A, 15);
    /* (0x00000408 bits 1) field T_PISO_PRE2_MODE0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_T_PISO_PRE2_MODE0_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_T_PISO_PRE2_MODE0_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_T_PISO_PRE2_MODE0_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_IMPEDANCE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                      s16_handle_t *h_ptr,
                                                      UINT32 A,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_IMPEDANCE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                      s16_handle_t *h_ptr,
                                                      UINT32 A,
                                                      UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_IMPEDANCE_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_IMPEDANCE_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_IMPEDANCE_set", A, value );

    /* (0x00000408 bits 0) field IMPEDANCE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_field_set( b_ptr,
                                                                     h_ptr,
                                                                     A,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_IMPEDANCE_MSK,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_IMPEDANCE_OFF,
                                                                     value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_IMPEDANCE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_IMPEDANCE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_IMPEDANCE_get", A, 15);
    /* (0x00000408 bits 0) field IMPEDANCE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_IMPEDANCE_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_PISO_CFG_1_BIT_IMPEDANCE_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_IMPEDANCE_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_DP_FFE_M_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_DP_FFE_M_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_DP_FFE_M_PRELOAD_set", A, 15);
    if (value > 63)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_DP_FFE_M_PRELOAD_set", value, 63);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_DP_FFE_M_PRELOAD_set", A, value );

    /* (0x0000040c bits 5:0) field DP_FFE_M_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1_BIT_DP_FFE_M_PRELOAD_MSK,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1_BIT_DP_FFE_M_PRELOAD_OFF,
                                                                      value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_DP_FFE_M_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_DP_FFE_M_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_DP_FFE_M_PRELOAD_get", A, 15);
    /* (0x0000040c bits 5:0) field DP_FFE_M_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1_BIT_DP_FFE_M_PRELOAD_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1_BIT_DP_FFE_M_PRELOAD_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_DP_FFE_M_PRELOAD_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_DP_FFE_M_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_DP_FFE_M_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_DP_FFE_M_PRELOAD_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_DP_FFE_M_PRELOAD_set", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_DP_FFE_M_PRELOAD_set", stop_bit, 5 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_DP_FFE_M_PRELOAD_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000040c bits 5:0) field DP_FFE_M_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 5) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 5;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000040c bits 5:0) field DP_FFE_M_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1_field_set( b_ptr,
                                                                          h_ptr,
                                                                          A,
                                                                          subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1_BIT_DP_FFE_M_PRELOAD_OFF + subfield_offset),
                                                                          PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1_BIT_DP_FFE_M_PRELOAD_OFF + subfield_offset,
                                                                          value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_DP_FFE_M_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_DP_FFE_M_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_DP_FFE_M_PRELOAD_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_DP_FFE_M_PRELOAD_get", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_DP_FFE_M_PRELOAD_get", stop_bit, 5 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 5) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 5;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000040c bits 5:0) field DP_FFE_M_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1_BIT_DP_FFE_M_PRELOAD_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1_BIT_DP_FFE_M_PRELOAD_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1_BIT_DP_FFE_M_PRELOAD_MSK, PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_ADAPT_CFG_1_BIT_DP_FFE_M_PRELOAD_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_DP_FFE_M_PRELOAD_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PISO_CLK_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PISO_CLK_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A,
                                                        UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PISO_CLK_EN_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PISO_CLK_EN_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PISO_CLK_EN_set", A, value );

    /* (0x0000041c bits 28) field PISO_CLK_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_field_set( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_PISO_CLK_EN_MSK,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_PISO_CLK_EN_OFF,
                                                                  value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PISO_CLK_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PISO_CLK_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PISO_CLK_EN_get", A, 15);
    /* (0x0000041c bits 28) field PISO_CLK_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_PISO_CLK_EN_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_PISO_CLK_EN_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PISO_CLK_EN_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_FIFO_HW_RESET_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_FIFO_HW_RESET_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A,
                                                          UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_FIFO_HW_RESET_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_FIFO_HW_RESET_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_FIFO_HW_RESET_set", A, value );

    /* (0x0000041c bits 27) field FIFO_HW_RESET of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_field_set( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_FIFO_HW_RESET_MSK,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_FIFO_HW_RESET_OFF,
                                                                  value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_FIFO_HW_RESET_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_FIFO_HW_RESET_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_FIFO_HW_RESET_get", A, 15);
    /* (0x0000041c bits 27) field FIFO_HW_RESET of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_FIFO_HW_RESET_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_FIFO_HW_RESET_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_FIFO_HW_RESET_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MDSP_CLK_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MDSP_CLK_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A,
                                                        UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MDSP_CLK_EN_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MDSP_CLK_EN_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MDSP_CLK_EN_set", A, value );

    /* (0x0000041c bits 26) field MDSP_CLK_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_field_set( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_MDSP_CLK_EN_MSK,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_MDSP_CLK_EN_OFF,
                                                                  value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MDSP_CLK_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MDSP_CLK_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MDSP_CLK_EN_get", A, 15);
    /* (0x0000041c bits 26) field MDSP_CLK_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_MDSP_CLK_EN_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_MDSP_CLK_EN_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MDSP_CLK_EN_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_CLR_OCDAC_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                      s16_handle_t *h_ptr,
                                                      UINT32 A,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_CLR_OCDAC_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                      s16_handle_t *h_ptr,
                                                      UINT32 A,
                                                      UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_CLR_OCDAC_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_CLR_OCDAC_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_CLR_OCDAC_set", A, value );

    /* (0x0000041c bits 7) field CLR_OCDAC of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_field_set( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_CLR_OCDAC_MSK,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_CLR_OCDAC_OFF,
                                                                  value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_CLR_OCDAC_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_CLR_OCDAC_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_CLR_OCDAC_get", A, 15);
    /* (0x0000041c bits 7) field CLR_OCDAC of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_CLR_OCDAC_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_CLR_OCDAC_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_CLR_OCDAC_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_CLR_OCDAC_DIV3_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_CLR_OCDAC_DIV3_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A,
                                                           UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_CLR_OCDAC_DIV3_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_CLR_OCDAC_DIV3_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_CLR_OCDAC_DIV3_set", A, value );

    /* (0x0000041c bits 6) field CLR_OCDAC_DIV3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_field_set( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_CLR_OCDAC_DIV3_MSK,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_CLR_OCDAC_DIV3_OFF,
                                                                  value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_CLR_OCDAC_DIV3_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_CLR_OCDAC_DIV3_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_CLR_OCDAC_DIV3_get", A, 15);
    /* (0x0000041c bits 6) field CLR_OCDAC_DIV3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_CLR_OCDAC_DIV3_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_CLR_OCDAC_DIV3_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_CLR_OCDAC_DIV3_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADAPT_CLK_ENB_OVR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADAPT_CLK_ENB_OVR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_CLK_ENB_OVR_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADAPT_CLK_ENB_OVR_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_CLK_ENB_OVR_set", A, value );

    /* (0x0000041c bits 5) field ADAPT_CLK_ENB_OVR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_field_set( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADAPT_CLK_ENB_OVR_MSK,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADAPT_CLK_ENB_OVR_OFF,
                                                                  value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_CLK_ENB_OVR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_CLK_ENB_OVR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_CLK_ENB_OVR_get", A, 15);
    /* (0x0000041c bits 5) field ADAPT_CLK_ENB_OVR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADAPT_CLK_ENB_OVR_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADAPT_CLK_ENB_OVR_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_CLK_ENB_OVR_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADAPT_CLK_ENB_OVR_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADAPT_CLK_ENB_OVR_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_CLK_ENB_OVR_EN_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADAPT_CLK_ENB_OVR_EN_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_CLK_ENB_OVR_EN_set", A, value );

    /* (0x0000041c bits 4) field ADAPT_CLK_ENB_OVR_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_field_set( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADAPT_CLK_ENB_OVR_EN_MSK,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADAPT_CLK_ENB_OVR_EN_OFF,
                                                                  value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_CLK_ENB_OVR_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_CLK_ENB_OVR_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_CLK_ENB_OVR_EN_get", A, 15);
    /* (0x0000041c bits 4) field ADAPT_CLK_ENB_OVR_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADAPT_CLK_ENB_OVR_EN_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADAPT_CLK_ENB_OVR_EN_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_CLK_ENB_OVR_EN_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADAPT_ENB_OVR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADAPT_ENB_OVR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A,
                                                          UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_ENB_OVR_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADAPT_ENB_OVR_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_ENB_OVR_set", A, value );

    /* (0x0000041c bits 3) field ADAPT_ENB_OVR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_field_set( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADAPT_ENB_OVR_MSK,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADAPT_ENB_OVR_OFF,
                                                                  value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_ENB_OVR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_ENB_OVR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_ENB_OVR_get", A, 15);
    /* (0x0000041c bits 3) field ADAPT_ENB_OVR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADAPT_ENB_OVR_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADAPT_ENB_OVR_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_ENB_OVR_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADAPT_ENB_OVR_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADAPT_ENB_OVR_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_ENB_OVR_EN_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADAPT_ENB_OVR_EN_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_ENB_OVR_EN_set", A, value );

    /* (0x0000041c bits 2) field ADAPT_ENB_OVR_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_field_set( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADAPT_ENB_OVR_EN_MSK,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADAPT_ENB_OVR_EN_OFF,
                                                                  value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_ENB_OVR_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_ENB_OVR_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_ENB_OVR_EN_get", A, 15);
    /* (0x0000041c bits 2) field ADAPT_ENB_OVR_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADAPT_ENB_OVR_EN_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADAPT_ENB_OVR_EN_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_ENB_OVR_EN_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADAPT_STATUS_0_OVR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADAPT_STATUS_0_OVR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_STATUS_0_OVR_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADAPT_STATUS_0_OVR_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_STATUS_0_OVR_set", A, value );

    /* (0x0000041c bits 1) field ADAPT_STATUS_0_OVR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_field_set( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADAPT_STATUS_0_OVR_MSK,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADAPT_STATUS_0_OVR_OFF,
                                                                  value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_STATUS_0_OVR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_STATUS_0_OVR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_STATUS_0_OVR_get", A, 15);
    /* (0x0000041c bits 1) field ADAPT_STATUS_0_OVR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADAPT_STATUS_0_OVR_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADAPT_STATUS_0_OVR_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_STATUS_0_OVR_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADAPT_STATUS_0_OVR_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADAPT_STATUS_0_OVR_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_STATUS_0_OVR_EN_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADAPT_STATUS_0_OVR_EN_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_STATUS_0_OVR_EN_set", A, value );

    /* (0x0000041c bits 0) field ADAPT_STATUS_0_OVR_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_field_set( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADAPT_STATUS_0_OVR_EN_MSK,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADAPT_STATUS_0_OVR_EN_OFF,
                                                                  value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_STATUS_0_OVR_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_STATUS_0_OVR_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_STATUS_0_OVR_EN_get", A, 15);
    /* (0x0000041c bits 0) field ADAPT_STATUS_0_OVR_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADAPT_STATUS_0_OVR_EN_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADAPT_STATUS_0_OVR_EN_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_STATUS_0_OVR_EN_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ALL_CALIB_REQUEST_FSM_OVR_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ALL_CALIB_REQUEST_FSM_OVR_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ALL_CALIB_REQUEST_FSM_OVR_EN_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ALL_CALIB_REQUEST_FSM_OVR_EN_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ALL_CALIB_REQUEST_FSM_OVR_EN_set", A, value );

    /* (0x00000420 bits 11) field ALL_CALIB_REQUEST_FSM_OVR_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_BIT_ALL_CALIB_REQUEST_FSM_OVR_EN_MSK,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_BIT_ALL_CALIB_REQUEST_FSM_OVR_EN_OFF,
                                                                    value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ALL_CALIB_REQUEST_FSM_OVR_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ALL_CALIB_REQUEST_FSM_OVR_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ALL_CALIB_REQUEST_FSM_OVR_EN_get", A, 15);
    /* (0x00000420 bits 11) field ALL_CALIB_REQUEST_FSM_OVR_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_BIT_ALL_CALIB_REQUEST_FSM_OVR_EN_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_BIT_ALL_CALIB_REQUEST_FSM_OVR_EN_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ALL_CALIB_REQUEST_FSM_OVR_EN_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_TX_EMI_ROP_RON_CAL_REQUEST_OVR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_TX_EMI_ROP_RON_CAL_REQUEST_OVR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_TX_EMI_ROP_RON_CAL_REQUEST_OVR_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_TX_EMI_ROP_RON_CAL_REQUEST_OVR_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_TX_EMI_ROP_RON_CAL_REQUEST_OVR_set", A, value );

    /* (0x00000420 bits 10) field TX_EMI_ROP_RON_CAL_REQUEST_OVR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_BIT_TX_EMI_ROP_RON_CAL_REQUEST_OVR_MSK,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_BIT_TX_EMI_ROP_RON_CAL_REQUEST_OVR_OFF,
                                                                    value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_TX_EMI_ROP_RON_CAL_REQUEST_OVR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                             s16_handle_t *h_ptr,
                                                                             UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_TX_EMI_ROP_RON_CAL_REQUEST_OVR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                             s16_handle_t *h_ptr,
                                                                             UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_TX_EMI_ROP_RON_CAL_REQUEST_OVR_get", A, 15);
    /* (0x00000420 bits 10) field TX_EMI_ROP_RON_CAL_REQUEST_OVR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_BIT_TX_EMI_ROP_RON_CAL_REQUEST_OVR_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_BIT_TX_EMI_ROP_RON_CAL_REQUEST_OVR_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_TX_EMI_ROP_RON_CAL_REQUEST_OVR_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_RTUNE_CAL_REQUEST_OVR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A,
                                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_RTUNE_CAL_REQUEST_OVR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A,
                                                                        UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_RTUNE_CAL_REQUEST_OVR_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_RTUNE_CAL_REQUEST_OVR_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_RTUNE_CAL_REQUEST_OVR_set", A, value );

    /* (0x00000420 bits 9) field PHGEN_RTUNE_CAL_REQUEST_OVR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_BIT_PHGEN_RTUNE_CAL_REQUEST_OVR_MSK,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_BIT_PHGEN_RTUNE_CAL_REQUEST_OVR_OFF,
                                                                    value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_RTUNE_CAL_REQUEST_OVR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_RTUNE_CAL_REQUEST_OVR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_RTUNE_CAL_REQUEST_OVR_get", A, 15);
    /* (0x00000420 bits 9) field PHGEN_RTUNE_CAL_REQUEST_OVR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_BIT_PHGEN_RTUNE_CAL_REQUEST_OVR_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_BIT_PHGEN_RTUNE_CAL_REQUEST_OVR_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_RTUNE_CAL_REQUEST_OVR_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADC_CALIB_REQUEST_OVR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADC_CALIB_REQUEST_OVR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADC_CALIB_REQUEST_OVR_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADC_CALIB_REQUEST_OVR_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADC_CALIB_REQUEST_OVR_set", A, value );

    /* (0x00000420 bits 6) field ADC_CALIB_REQUEST_OVR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_BIT_ADC_CALIB_REQUEST_OVR_MSK,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_BIT_ADC_CALIB_REQUEST_OVR_OFF,
                                                                    value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADC_CALIB_REQUEST_OVR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADC_CALIB_REQUEST_OVR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADC_CALIB_REQUEST_OVR_get", A, 15);
    /* (0x00000420 bits 6) field ADC_CALIB_REQUEST_OVR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_BIT_ADC_CALIB_REQUEST_OVR_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_BIT_ADC_CALIB_REQUEST_OVR_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADC_CALIB_REQUEST_OVR_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_CALIB_REQUEST_OVR_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_CALIB_REQUEST_OVR_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_CALIB_REQUEST_OVR_EN_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_CALIB_REQUEST_OVR_EN_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_CALIB_REQUEST_OVR_EN_set", A, value );

    /* (0x00000420 bits 4) field CALIB_REQUEST_OVR_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_BIT_CALIB_REQUEST_OVR_EN_MSK,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_BIT_CALIB_REQUEST_OVR_EN_OFF,
                                                                    value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_CALIB_REQUEST_OVR_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_CALIB_REQUEST_OVR_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_CALIB_REQUEST_OVR_EN_get", A, 15);
    /* (0x00000420 bits 4) field CALIB_REQUEST_OVR_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_BIT_CALIB_REQUEST_OVR_EN_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_1_REG_BIT_CALIB_REQUEST_OVR_EN_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_CALIB_REQUEST_OVR_EN_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_T_PISO_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                       s16_handle_t *h_ptr,
                                                       UINT32 A,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_T_PISO_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                       s16_handle_t *h_ptr,
                                                       UINT32 A,
                                                       UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_T_PISO_ENB_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_T_PISO_ENB_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_T_PISO_ENB_set", A, value );

    /* (0x00000440 bits 17) field T_PISO_ENB of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_field_set( b_ptr,
                                                                     h_ptr,
                                                                     A,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_BIT_T_PISO_ENB_MSK,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_BIT_T_PISO_ENB_OFF,
                                                                     value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_T_PISO_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_T_PISO_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_T_PISO_ENB_get", A, 15);
    /* (0x00000440 bits 17) field T_PISO_ENB of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_BIT_T_PISO_ENB_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_BIT_T_PISO_ENB_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_T_PISO_ENB_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_T_TX_OENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                      s16_handle_t *h_ptr,
                                                      UINT32 A,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_T_TX_OENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                      s16_handle_t *h_ptr,
                                                      UINT32 A,
                                                      UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_T_TX_OENB_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_T_TX_OENB_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_T_TX_OENB_set", A, value );

    /* (0x00000440 bits 14) field T_TX_OENB of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_field_set( b_ptr,
                                                                     h_ptr,
                                                                     A,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_BIT_T_TX_OENB_MSK,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_BIT_T_TX_OENB_OFF,
                                                                     value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_T_TX_OENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_T_TX_OENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_T_TX_OENB_get", A, 15);
    /* (0x00000440 bits 14) field T_TX_OENB of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_BIT_T_TX_OENB_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_BIT_T_TX_OENB_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_T_TX_OENB_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_T_PISO_CTRL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_T_PISO_CTRL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A,
                                                        UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_T_PISO_CTRL_set", A, 15);
    if (value > 31)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_T_PISO_CTRL_set", value, 31);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_T_PISO_CTRL_set", A, value );

    /* (0x00000440 bits 12:8) field T_PISO_CTRL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_field_set( b_ptr,
                                                                     h_ptr,
                                                                     A,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_BIT_T_PISO_CTRL_MSK,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_BIT_T_PISO_CTRL_OFF,
                                                                     value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_T_PISO_CTRL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_T_PISO_CTRL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_T_PISO_CTRL_get", A, 15);
    /* (0x00000440 bits 12:8) field T_PISO_CTRL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_BIT_T_PISO_CTRL_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_BIT_T_PISO_CTRL_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_T_PISO_CTRL_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_T_PISO_CTRL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_T_PISO_CTRL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit,
                                                              UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_T_PISO_CTRL_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_T_PISO_CTRL_set", stop_bit, start_bit );
    if (stop_bit > 4) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_T_PISO_CTRL_set", stop_bit, 4 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_T_PISO_CTRL_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000440 bits 12:8) field T_PISO_CTRL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 4) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 4;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000440 bits 12:8) field T_PISO_CTRL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_field_set( b_ptr,
                                                                         h_ptr,
                                                                         A,
                                                                         subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_BIT_T_PISO_CTRL_OFF + subfield_offset),
                                                                         PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_BIT_T_PISO_CTRL_OFF + subfield_offset,
                                                                         value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_T_PISO_CTRL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_T_PISO_CTRL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_T_PISO_CTRL_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_T_PISO_CTRL_get", stop_bit, start_bit );
    if (stop_bit > 4) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_T_PISO_CTRL_get", stop_bit, 4 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 4) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 4;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000440 bits 12:8) field T_PISO_CTRL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_BIT_T_PISO_CTRL_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_BIT_T_PISO_CTRL_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_BIT_T_PISO_CTRL_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PISO_CFG_1_BIT_T_PISO_CTRL_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_T_PISO_CTRL_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADC_CAL_DAC_OVR_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADC_CAL_DAC_OVR_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADC_CAL_DAC_OVR_EN_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADC_CAL_DAC_OVR_EN_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADC_CAL_DAC_OVR_EN_set", A, value );

    /* (0x00000444 bits 20) field ADC_CAL_DAC_OVR_EN of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
    s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_field_set( b_ptr,
                                                            h_ptr,
                                                            A,
                                                            PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_CAL_DAC_OVR_EN_MSK,
                                                            PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_CAL_DAC_OVR_EN_OFF,
                                                            value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADC_CAL_DAC_OVR_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADC_CAL_DAC_OVR_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADC_CAL_DAC_OVR_EN_get", A, 15);
    /* (0x00000444 bits 20) field ADC_CAL_DAC_OVR_EN of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_read( b_ptr,
                                                                   h_ptr,
                                                                   A);
    value = (reg_value & PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_CAL_DAC_OVR_EN_MSK) >> PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_CAL_DAC_OVR_EN_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADC_CAL_DAC_OVR_EN_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADC_CAL_DAC_ENB_DEFAULT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADC_CAL_DAC_ENB_DEFAULT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADC_CAL_DAC_ENB_DEFAULT_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADC_CAL_DAC_ENB_DEFAULT_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADC_CAL_DAC_ENB_DEFAULT_set", A, value );

    /* (0x00000444 bits 19) field ADC_CAL_DAC_ENB_DEFAULT of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
    s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_field_set( b_ptr,
                                                            h_ptr,
                                                            A,
                                                            PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_CAL_DAC_ENB_DEFAULT_MSK,
                                                            PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_CAL_DAC_ENB_DEFAULT_OFF,
                                                            value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADC_CAL_DAC_ENB_DEFAULT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADC_CAL_DAC_ENB_DEFAULT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADC_CAL_DAC_ENB_DEFAULT_get", A, 15);
    /* (0x00000444 bits 19) field ADC_CAL_DAC_ENB_DEFAULT of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_read( b_ptr,
                                                                   h_ptr,
                                                                   A);
    value = (reg_value & PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_CAL_DAC_ENB_DEFAULT_MSK) >> PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_CAL_DAC_ENB_DEFAULT_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADC_CAL_DAC_ENB_DEFAULT_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADC_CAL_DAC_ENB_CALIB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADC_CAL_DAC_ENB_CALIB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADC_CAL_DAC_ENB_CALIB_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADC_CAL_DAC_ENB_CALIB_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADC_CAL_DAC_ENB_CALIB_set", A, value );

    /* (0x00000444 bits 18) field ADC_CAL_DAC_ENB_CALIB of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
    s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_field_set( b_ptr,
                                                            h_ptr,
                                                            A,
                                                            PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_CAL_DAC_ENB_CALIB_MSK,
                                                            PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_CAL_DAC_ENB_CALIB_OFF,
                                                            value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADC_CAL_DAC_ENB_CALIB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADC_CAL_DAC_ENB_CALIB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADC_CAL_DAC_ENB_CALIB_get", A, 15);
    /* (0x00000444 bits 18) field ADC_CAL_DAC_ENB_CALIB of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_read( b_ptr,
                                                                   h_ptr,
                                                                   A);
    value = (reg_value & PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_CAL_DAC_ENB_CALIB_MSK) >> PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_CAL_DAC_ENB_CALIB_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADC_CAL_DAC_ENB_CALIB_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADC_CAL_DAC_ENB_OVR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A,
                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADC_CAL_DAC_ENB_OVR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A,
                                                                UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADC_CAL_DAC_ENB_OVR_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADC_CAL_DAC_ENB_OVR_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADC_CAL_DAC_ENB_OVR_set", A, value );

    /* (0x00000444 bits 17) field ADC_CAL_DAC_ENB_OVR of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
    s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_field_set( b_ptr,
                                                            h_ptr,
                                                            A,
                                                            PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_CAL_DAC_ENB_OVR_MSK,
                                                            PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_CAL_DAC_ENB_OVR_OFF,
                                                            value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADC_CAL_DAC_ENB_OVR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADC_CAL_DAC_ENB_OVR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADC_CAL_DAC_ENB_OVR_get", A, 15);
    /* (0x00000444 bits 17) field ADC_CAL_DAC_ENB_OVR of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_read( b_ptr,
                                                                   h_ptr,
                                                                   A);
    value = (reg_value & PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_CAL_DAC_ENB_OVR_MSK) >> PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_CAL_DAC_ENB_OVR_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADC_CAL_DAC_ENB_OVR_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_OC_OFFSET_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_OC_OFFSET_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A,
                                                          UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_OC_OFFSET_ENB_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_OC_OFFSET_ENB_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_OC_OFFSET_ENB_set", A, value );

    /* (0x00000444 bits 16) field OC_OFFSET_ENB of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
    s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_field_set( b_ptr,
                                                            h_ptr,
                                                            A,
                                                            PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_OC_OFFSET_ENB_MSK,
                                                            PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_OC_OFFSET_ENB_OFF,
                                                            value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_OC_OFFSET_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_OC_OFFSET_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_OC_OFFSET_ENB_get", A, 15);
    /* (0x00000444 bits 16) field OC_OFFSET_ENB of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_read( b_ptr,
                                                                   h_ptr,
                                                                   A);
    value = (reg_value & PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_OC_OFFSET_ENB_MSK) >> PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_OC_OFFSET_ENB_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_OC_OFFSET_ENB_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_OC_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                   s16_handle_t *h_ptr,
                                                   UINT32 A,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_OC_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                   s16_handle_t *h_ptr,
                                                   UINT32 A,
                                                   UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_OC_ENB_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_OC_ENB_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_OC_ENB_set", A, value );

    /* (0x00000444 bits 15) field OC_ENB of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
    s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_field_set( b_ptr,
                                                            h_ptr,
                                                            A,
                                                            PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_OC_ENB_MSK,
                                                            PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_OC_ENB_OFF,
                                                            value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_OC_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                     s16_handle_t *h_ptr,
                                                     UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_OC_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                     s16_handle_t *h_ptr,
                                                     UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_OC_ENB_get", A, 15);
    /* (0x00000444 bits 15) field OC_ENB of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_read( b_ptr,
                                                                   h_ptr,
                                                                   A);
    value = (reg_value & PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_OC_ENB_MSK) >> PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_OC_ENB_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_OC_ENB_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                      s16_handle_t *h_ptr,
                                                      UINT32 A,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                      s16_handle_t *h_ptr,
                                                      UINT32 A,
                                                      UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_ENB_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_ENB_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_ENB_set", A, value );

    /* (0x00000444 bits 14) field PHGEN_ENB of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
    s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_field_set( b_ptr,
                                                            h_ptr,
                                                            A,
                                                            PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_PHGEN_ENB_MSK,
                                                            PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_PHGEN_ENB_OFF,
                                                            value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_ENB_get", A, 15);
    /* (0x00000444 bits 14) field PHGEN_ENB of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_read( b_ptr,
                                                                   h_ptr,
                                                                   A);
    value = (reg_value & PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_PHGEN_ENB_MSK) >> PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_PHGEN_ENB_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_ENB_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_DLYCOR_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_DLYCOR_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_DLYCOR_ENB_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_DLYCOR_ENB_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_DLYCOR_ENB_set", A, value );

    /* (0x00000444 bits 13) field PHGEN_DLYCOR_ENB of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
    s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_field_set( b_ptr,
                                                            h_ptr,
                                                            A,
                                                            PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_PHGEN_DLYCOR_ENB_MSK,
                                                            PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_PHGEN_DLYCOR_ENB_OFF,
                                                            value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_DLYCOR_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_DLYCOR_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_DLYCOR_ENB_get", A, 15);
    /* (0x00000444 bits 13) field PHGEN_DLYCOR_ENB of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_read( b_ptr,
                                                                   h_ptr,
                                                                   A);
    value = (reg_value & PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_PHGEN_DLYCOR_ENB_MSK) >> PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_PHGEN_DLYCOR_ENB_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_DLYCOR_ENB_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADC_DAC_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADC_DAC_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A,
                                                        UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADC_DAC_ENB_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADC_DAC_ENB_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADC_DAC_ENB_set", A, value );

    /* (0x00000444 bits 12) field ADC_DAC_ENB of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
    s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_field_set( b_ptr,
                                                            h_ptr,
                                                            A,
                                                            PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_DAC_ENB_MSK,
                                                            PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_DAC_ENB_OFF,
                                                            value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADC_DAC_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADC_DAC_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADC_DAC_ENB_get", A, 15);
    /* (0x00000444 bits 12) field ADC_DAC_ENB of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_read( b_ptr,
                                                                   h_ptr,
                                                                   A);
    value = (reg_value & PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_DAC_ENB_MSK) >> PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_DAC_ENB_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADC_DAC_ENB_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADC_RATE_SEL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADC_RATE_SEL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A,
                                                         UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADC_RATE_SEL_set", A, 15);
    if (value > 3)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADC_RATE_SEL_set", value, 3);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADC_RATE_SEL_set", A, value );

    /* (0x00000444 bits 11:10) field ADC_RATE_SEL of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
    s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_field_set( b_ptr,
                                                            h_ptr,
                                                            A,
                                                            PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_RATE_SEL_MSK,
                                                            PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_RATE_SEL_OFF,
                                                            value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADC_RATE_SEL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADC_RATE_SEL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADC_RATE_SEL_get", A, 15);
    /* (0x00000444 bits 11:10) field ADC_RATE_SEL of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_read( b_ptr,
                                                                   h_ptr,
                                                                   A);
    value = (reg_value & PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_RATE_SEL_MSK) >> PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_RATE_SEL_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADC_RATE_SEL_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_ADC_RATE_SEL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_ADC_RATE_SEL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_ADC_RATE_SEL_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_ADC_RATE_SEL_set", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_ADC_RATE_SEL_set", stop_bit, 1 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_ADC_RATE_SEL_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000444 bits 11:10) field ADC_RATE_SEL of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 1) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 1;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000444 bits 11:10) field ADC_RATE_SEL of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
        s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                subfield_mask << (PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_RATE_SEL_OFF + subfield_offset),
                                                                PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_RATE_SEL_OFF + subfield_offset,
                                                                value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_ADC_RATE_SEL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_ADC_RATE_SEL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_ADC_RATE_SEL_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_ADC_RATE_SEL_get", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_ADC_RATE_SEL_get", stop_bit, 1 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 1) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 1;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000444 bits 11:10) field ADC_RATE_SEL of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_read( b_ptr,
                                                                   h_ptr,
                                                                   A);
    field_value = (reg_value & PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_RATE_SEL_MSK)
                  >> PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_RATE_SEL_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_RATE_SEL_MSK, PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_RATE_SEL_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_ADC_RATE_SEL_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADC_CLK_1200M_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADC_CLK_1200M_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADC_CLK_1200M_ENB_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADC_CLK_1200M_ENB_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADC_CLK_1200M_ENB_set", A, value );

    /* (0x00000444 bits 9) field ADC_CLK_1200M_ENB of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
    s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_field_set( b_ptr,
                                                            h_ptr,
                                                            A,
                                                            PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_CLK_1200M_ENB_MSK,
                                                            PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_CLK_1200M_ENB_OFF,
                                                            value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADC_CLK_1200M_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADC_CLK_1200M_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADC_CLK_1200M_ENB_get", A, 15);
    /* (0x00000444 bits 9) field ADC_CLK_1200M_ENB of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_read( b_ptr,
                                                                   h_ptr,
                                                                   A);
    value = (reg_value & PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_CLK_1200M_ENB_MSK) >> PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_CLK_1200M_ENB_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADC_CLK_1200M_ENB_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADC_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                    s16_handle_t *h_ptr,
                                                    UINT32 A,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADC_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                    s16_handle_t *h_ptr,
                                                    UINT32 A,
                                                    UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADC_ENB_set", A, 15);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADC_ENB_set", value, 15);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADC_ENB_set", A, value );

    /* (0x00000444 bits 7:4) field ADC_ENB of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
    s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_field_set( b_ptr,
                                                            h_ptr,
                                                            A,
                                                            PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_ENB_MSK,
                                                            PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_ENB_OFF,
                                                            value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADC_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                      s16_handle_t *h_ptr,
                                                      UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADC_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                      s16_handle_t *h_ptr,
                                                      UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADC_ENB_get", A, 15);
    /* (0x00000444 bits 7:4) field ADC_ENB of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_read( b_ptr,
                                                                   h_ptr,
                                                                   A);
    value = (reg_value & PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_ENB_MSK) >> PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_ENB_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADC_ENB_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_ADC_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_ADC_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A,
                                                          UINT32 start_bit,
                                                          UINT32 stop_bit,
                                                          UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_ADC_ENB_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_ADC_ENB_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_ADC_ENB_set", stop_bit, 3 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_ADC_ENB_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000444 bits 7:4) field ADC_ENB of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000444 bits 7:4) field ADC_ENB of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
        s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                subfield_mask << (PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_ENB_OFF + subfield_offset),
                                                                PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_ENB_OFF + subfield_offset,
                                                                value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_ADC_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_ADC_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_ADC_ENB_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_ADC_ENB_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_ADC_ENB_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000444 bits 7:4) field ADC_ENB of register PMC_PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_MTSB_CTRL_GLOBAL_ADC_CFG_1_read( b_ptr,
                                                                   h_ptr,
                                                                   A);
    field_value = (reg_value & PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_ENB_MSK)
                  >> PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_ENB_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_ENB_MSK, PCBI_REG_MTSB_CTRL_GLOBAL_ADC_CFG_1_BIT_ADC_ENB_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_ADC_ENB_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_TCB_RESET_DURATION_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_TCB_RESET_DURATION_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_TCB_RESET_DURATION_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_TCB_RESET_DURATION_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_TCB_RESET_DURATION_set", A, value );

    /* (0x00000448 bits 9:7) field TCB_RESET_DURATION of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_field_set( b_ptr,
                                                                     h_ptr,
                                                                     A,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_TCB_RESET_DURATION_MSK,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_TCB_RESET_DURATION_OFF,
                                                                     value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_TCB_RESET_DURATION_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_TCB_RESET_DURATION_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_TCB_RESET_DURATION_get", A, 15);
    /* (0x00000448 bits 9:7) field TCB_RESET_DURATION of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_TCB_RESET_DURATION_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_TCB_RESET_DURATION_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_TCB_RESET_DURATION_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_TCB_RESET_DURATION_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_TCB_RESET_DURATION_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_TCB_RESET_DURATION_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_TCB_RESET_DURATION_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_TCB_RESET_DURATION_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_TCB_RESET_DURATION_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000448 bits 9:7) field TCB_RESET_DURATION of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000448 bits 9:7) field TCB_RESET_DURATION of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_field_set( b_ptr,
                                                                         h_ptr,
                                                                         A,
                                                                         subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_TCB_RESET_DURATION_OFF + subfield_offset),
                                                                         PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_TCB_RESET_DURATION_OFF + subfield_offset,
                                                                         value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_TCB_RESET_DURATION_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_TCB_RESET_DURATION_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_TCB_RESET_DURATION_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_TCB_RESET_DURATION_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_TCB_RESET_DURATION_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000448 bits 9:7) field TCB_RESET_DURATION of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_TCB_RESET_DURATION_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_TCB_RESET_DURATION_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_TCB_RESET_DURATION_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_TCB_RESET_DURATION_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_TCB_RESET_DURATION_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_RX_CM_TERM_SEL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_RX_CM_TERM_SEL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A,
                                                           UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RX_CM_TERM_SEL_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_RX_CM_TERM_SEL_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_RX_CM_TERM_SEL_set", A, value );

    /* (0x00000448 bits 6) field RX_CM_TERM_SEL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_field_set( b_ptr,
                                                                     h_ptr,
                                                                     A,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_RX_CM_TERM_SEL_MSK,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_RX_CM_TERM_SEL_OFF,
                                                                     value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_RX_CM_TERM_SEL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_RX_CM_TERM_SEL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RX_CM_TERM_SEL_get", A, 15);
    /* (0x00000448 bits 6) field RX_CM_TERM_SEL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_RX_CM_TERM_SEL_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_RX_CM_TERM_SEL_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_RX_CM_TERM_SEL_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_RX_CMCOR_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_RX_CMCOR_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A,
                                                         UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RX_CMCOR_ENB_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_RX_CMCOR_ENB_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_RX_CMCOR_ENB_set", A, value );

    /* (0x00000448 bits 5) field RX_CMCOR_ENB of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_field_set( b_ptr,
                                                                     h_ptr,
                                                                     A,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_RX_CMCOR_ENB_MSK,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_RX_CMCOR_ENB_OFF,
                                                                     value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_RX_CMCOR_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_RX_CMCOR_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RX_CMCOR_ENB_get", A, 15);
    /* (0x00000448 bits 5) field RX_CMCOR_ENB of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_RX_CMCOR_ENB_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_RX_CMCOR_ENB_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_RX_CMCOR_ENB_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_T_EMI_DAC_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_T_EMI_DAC_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A,
                                                          UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_T_EMI_DAC_ENB_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_T_EMI_DAC_ENB_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_T_EMI_DAC_ENB_set", A, value );

    /* (0x00000448 bits 4) field T_EMI_DAC_ENB of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_field_set( b_ptr,
                                                                     h_ptr,
                                                                     A,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_T_EMI_DAC_ENB_MSK,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_T_EMI_DAC_ENB_OFF,
                                                                     value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_T_EMI_DAC_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_T_EMI_DAC_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_T_EMI_DAC_ENB_get", A, 15);
    /* (0x00000448 bits 4) field T_EMI_DAC_ENB of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_T_EMI_DAC_ENB_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_T_EMI_DAC_ENB_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_T_EMI_DAC_ENB_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_T_OC_SENSE_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_T_OC_SENSE_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A,
                                                           UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_T_OC_SENSE_ENB_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_T_OC_SENSE_ENB_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_T_OC_SENSE_ENB_set", A, value );

    /* (0x00000448 bits 3) field T_OC_SENSE_ENB of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_field_set( b_ptr,
                                                                     h_ptr,
                                                                     A,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_T_OC_SENSE_ENB_MSK,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_T_OC_SENSE_ENB_OFF,
                                                                     value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_T_OC_SENSE_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_T_OC_SENSE_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_T_OC_SENSE_ENB_get", A, 15);
    /* (0x00000448 bits 3) field T_OC_SENSE_ENB of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_T_OC_SENSE_ENB_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_T_OC_SENSE_ENB_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_T_OC_SENSE_ENB_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_T_OFFSET_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_T_OFFSET_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A,
                                                         UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_T_OFFSET_ENB_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_T_OFFSET_ENB_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_T_OFFSET_ENB_set", A, value );

    /* (0x00000448 bits 2) field T_OFFSET_ENB of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_field_set( b_ptr,
                                                                     h_ptr,
                                                                     A,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_T_OFFSET_ENB_MSK,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_T_OFFSET_ENB_OFF,
                                                                     value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_T_OFFSET_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_T_OFFSET_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_T_OFFSET_ENB_get", A, 15);
    /* (0x00000448 bits 2) field T_OFFSET_ENB of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_T_OFFSET_ENB_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_MTSB_CFG_1_BIT_T_OFFSET_ENB_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_T_OFFSET_ENB_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_LF_INTEG_OUT_MODE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_LF_INTEG_OUT_MODE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_LF_INTEG_OUT_MODE_set", A, 15);
    if (value > 3)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_LF_INTEG_OUT_MODE_set", value, 3);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_LF_INTEG_OUT_MODE_set", A, value );

    /* (0x0000044c bits 30:29) field LF_INTEG_OUT_MODE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_OUT_MODE_MSK,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_OUT_MODE_OFF,
                                                                    value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_LF_INTEG_OUT_MODE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_LF_INTEG_OUT_MODE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_LF_INTEG_OUT_MODE_get", A, 15);
    /* (0x0000044c bits 30:29) field LF_INTEG_OUT_MODE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_OUT_MODE_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_OUT_MODE_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_LF_INTEG_OUT_MODE_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_LF_INTEG_OUT_MODE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_LF_INTEG_OUT_MODE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_LF_INTEG_OUT_MODE_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_LF_INTEG_OUT_MODE_set", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_LF_INTEG_OUT_MODE_set", stop_bit, 1 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_LF_INTEG_OUT_MODE_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000044c bits 30:29) field LF_INTEG_OUT_MODE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 1) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 1;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000044c bits 30:29) field LF_INTEG_OUT_MODE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_field_set( b_ptr,
                                                                        h_ptr,
                                                                        A,
                                                                        subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_OUT_MODE_OFF + subfield_offset),
                                                                        PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_OUT_MODE_OFF + subfield_offset,
                                                                        value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_LF_INTEG_OUT_MODE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_LF_INTEG_OUT_MODE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_LF_INTEG_OUT_MODE_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_LF_INTEG_OUT_MODE_get", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_LF_INTEG_OUT_MODE_get", stop_bit, 1 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 1) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 1;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000044c bits 30:29) field LF_INTEG_OUT_MODE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_OUT_MODE_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_OUT_MODE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_OUT_MODE_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_OUT_MODE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_LF_INTEG_OUT_MODE_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_BLOCK_SIZE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                       s16_handle_t *h_ptr,
                                                       UINT32 A,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_BLOCK_SIZE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                       s16_handle_t *h_ptr,
                                                       UINT32 A,
                                                       UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_BLOCK_SIZE_set", A, 15);
    if (value > 3)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_BLOCK_SIZE_set", value, 3);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_BLOCK_SIZE_set", A, value );

    /* (0x0000044c bits 28:27) field BLOCK_SIZE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_BLOCK_SIZE_MSK,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_BLOCK_SIZE_OFF,
                                                                    value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_BLOCK_SIZE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_BLOCK_SIZE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_BLOCK_SIZE_get", A, 15);
    /* (0x0000044c bits 28:27) field BLOCK_SIZE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_BLOCK_SIZE_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_BLOCK_SIZE_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_BLOCK_SIZE_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_BLOCK_SIZE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_BLOCK_SIZE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 start_bit,
                                                             UINT32 stop_bit,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_BLOCK_SIZE_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_BLOCK_SIZE_set", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_BLOCK_SIZE_set", stop_bit, 1 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_BLOCK_SIZE_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000044c bits 28:27) field BLOCK_SIZE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 1) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 1;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000044c bits 28:27) field BLOCK_SIZE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_field_set( b_ptr,
                                                                        h_ptr,
                                                                        A,
                                                                        subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_BLOCK_SIZE_OFF + subfield_offset),
                                                                        PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_BLOCK_SIZE_OFF + subfield_offset,
                                                                        value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_BLOCK_SIZE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_BLOCK_SIZE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_BLOCK_SIZE_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_BLOCK_SIZE_get", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_BLOCK_SIZE_get", stop_bit, 1 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 1) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 1;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000044c bits 28:27) field BLOCK_SIZE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_BLOCK_SIZE_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_BLOCK_SIZE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_BLOCK_SIZE_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_BLOCK_SIZE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_BLOCK_SIZE_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_LF_INTEG_OUT_OVR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_LF_INTEG_OUT_OVR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_LF_INTEG_OUT_OVR_set", A, 15);
    if (value > 4095)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_LF_INTEG_OUT_OVR_set", value, 4095);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_LF_INTEG_OUT_OVR_set", A, value );

    /* (0x0000044c bits 26:15) field LF_INTEG_OUT_OVR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_OUT_OVR_MSK,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_OUT_OVR_OFF,
                                                                    value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_LF_INTEG_OUT_OVR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_LF_INTEG_OUT_OVR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_LF_INTEG_OUT_OVR_get", A, 15);
    /* (0x0000044c bits 26:15) field LF_INTEG_OUT_OVR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_OUT_OVR_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_OUT_OVR_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_LF_INTEG_OUT_OVR_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_LF_INTEG_OUT_OVR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_LF_INTEG_OUT_OVR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_LF_INTEG_OUT_OVR_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_LF_INTEG_OUT_OVR_set", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_LF_INTEG_OUT_OVR_set", stop_bit, 11 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_LF_INTEG_OUT_OVR_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000044c bits 26:15) field LF_INTEG_OUT_OVR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000044c bits 26:15) field LF_INTEG_OUT_OVR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_field_set( b_ptr,
                                                                        h_ptr,
                                                                        A,
                                                                        subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_OUT_OVR_OFF + subfield_offset),
                                                                        PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_OUT_OVR_OFF + subfield_offset,
                                                                        value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_LF_INTEG_OUT_OVR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_LF_INTEG_OUT_OVR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_LF_INTEG_OUT_OVR_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_LF_INTEG_OUT_OVR_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_LF_INTEG_OUT_OVR_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000044c bits 26:15) field LF_INTEG_OUT_OVR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_OUT_OVR_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_OUT_OVR_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_OUT_OVR_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_OUT_OVR_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_LF_INTEG_OUT_OVR_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_LF_INTEG_LEFT_SHIFT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A,
                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_LF_INTEG_LEFT_SHIFT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A,
                                                                UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_LF_INTEG_LEFT_SHIFT_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_LF_INTEG_LEFT_SHIFT_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_LF_INTEG_LEFT_SHIFT_set", A, value );

    /* (0x0000044c bits 14:12) field LF_INTEG_LEFT_SHIFT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_LEFT_SHIFT_MSK,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_LEFT_SHIFT_OFF,
                                                                    value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_LF_INTEG_LEFT_SHIFT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_LF_INTEG_LEFT_SHIFT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_LF_INTEG_LEFT_SHIFT_get", A, 15);
    /* (0x0000044c bits 14:12) field LF_INTEG_LEFT_SHIFT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_LEFT_SHIFT_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_LEFT_SHIFT_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_LF_INTEG_LEFT_SHIFT_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_LF_INTEG_LEFT_SHIFT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit,
                                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_LF_INTEG_LEFT_SHIFT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit,
                                                                      UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_LF_INTEG_LEFT_SHIFT_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_LF_INTEG_LEFT_SHIFT_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_LF_INTEG_LEFT_SHIFT_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_LF_INTEG_LEFT_SHIFT_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000044c bits 14:12) field LF_INTEG_LEFT_SHIFT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000044c bits 14:12) field LF_INTEG_LEFT_SHIFT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_field_set( b_ptr,
                                                                        h_ptr,
                                                                        A,
                                                                        subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_LEFT_SHIFT_OFF + subfield_offset),
                                                                        PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_LEFT_SHIFT_OFF + subfield_offset,
                                                                        value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_LF_INTEG_LEFT_SHIFT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_LF_INTEG_LEFT_SHIFT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_LF_INTEG_LEFT_SHIFT_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_LF_INTEG_LEFT_SHIFT_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_LF_INTEG_LEFT_SHIFT_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000044c bits 14:12) field LF_INTEG_LEFT_SHIFT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_LEFT_SHIFT_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_LEFT_SHIFT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_LEFT_SHIFT_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_LEFT_SHIFT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_LF_INTEG_LEFT_SHIFT_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_LF_INTEG_CTRL_GAIN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_LF_INTEG_CTRL_GAIN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_LF_INTEG_CTRL_GAIN_set", A, 15);
    if (value > 31)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_LF_INTEG_CTRL_GAIN_set", value, 31);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_LF_INTEG_CTRL_GAIN_set", A, value );

    /* (0x0000044c bits 11:7) field LF_INTEG_CTRL_GAIN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_CTRL_GAIN_MSK,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_CTRL_GAIN_OFF,
                                                                    value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_LF_INTEG_CTRL_GAIN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_LF_INTEG_CTRL_GAIN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_LF_INTEG_CTRL_GAIN_get", A, 15);
    /* (0x0000044c bits 11:7) field LF_INTEG_CTRL_GAIN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_CTRL_GAIN_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_CTRL_GAIN_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_LF_INTEG_CTRL_GAIN_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_LF_INTEG_CTRL_GAIN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_LF_INTEG_CTRL_GAIN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_LF_INTEG_CTRL_GAIN_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_LF_INTEG_CTRL_GAIN_set", stop_bit, start_bit );
    if (stop_bit > 4) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_LF_INTEG_CTRL_GAIN_set", stop_bit, 4 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_LF_INTEG_CTRL_GAIN_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000044c bits 11:7) field LF_INTEG_CTRL_GAIN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 4) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 4;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000044c bits 11:7) field LF_INTEG_CTRL_GAIN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_field_set( b_ptr,
                                                                        h_ptr,
                                                                        A,
                                                                        subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_CTRL_GAIN_OFF + subfield_offset),
                                                                        PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_CTRL_GAIN_OFF + subfield_offset,
                                                                        value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_LF_INTEG_CTRL_GAIN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_LF_INTEG_CTRL_GAIN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_LF_INTEG_CTRL_GAIN_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_LF_INTEG_CTRL_GAIN_get", stop_bit, start_bit );
    if (stop_bit > 4) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_LF_INTEG_CTRL_GAIN_get", stop_bit, 4 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 4) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 4;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000044c bits 11:7) field LF_INTEG_CTRL_GAIN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_CTRL_GAIN_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_CTRL_GAIN_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_CTRL_GAIN_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_INTEG_CTRL_GAIN_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_LF_INTEG_CTRL_GAIN_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_LF_PROP_LEFT_SHIFT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_LF_PROP_LEFT_SHIFT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_LF_PROP_LEFT_SHIFT_set", A, 15);
    if (value > 3)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_LF_PROP_LEFT_SHIFT_set", value, 3);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_LF_PROP_LEFT_SHIFT_set", A, value );

    /* (0x0000044c bits 6:5) field LF_PROP_LEFT_SHIFT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_PROP_LEFT_SHIFT_MSK,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_PROP_LEFT_SHIFT_OFF,
                                                                    value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_LF_PROP_LEFT_SHIFT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_LF_PROP_LEFT_SHIFT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_LF_PROP_LEFT_SHIFT_get", A, 15);
    /* (0x0000044c bits 6:5) field LF_PROP_LEFT_SHIFT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_PROP_LEFT_SHIFT_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_PROP_LEFT_SHIFT_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_LF_PROP_LEFT_SHIFT_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_LF_PROP_LEFT_SHIFT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_LF_PROP_LEFT_SHIFT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_LF_PROP_LEFT_SHIFT_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_LF_PROP_LEFT_SHIFT_set", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_LF_PROP_LEFT_SHIFT_set", stop_bit, 1 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_LF_PROP_LEFT_SHIFT_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000044c bits 6:5) field LF_PROP_LEFT_SHIFT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 1) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 1;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000044c bits 6:5) field LF_PROP_LEFT_SHIFT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_field_set( b_ptr,
                                                                        h_ptr,
                                                                        A,
                                                                        subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_PROP_LEFT_SHIFT_OFF + subfield_offset),
                                                                        PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_PROP_LEFT_SHIFT_OFF + subfield_offset,
                                                                        value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_LF_PROP_LEFT_SHIFT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_LF_PROP_LEFT_SHIFT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_LF_PROP_LEFT_SHIFT_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_LF_PROP_LEFT_SHIFT_get", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_LF_PROP_LEFT_SHIFT_get", stop_bit, 1 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 1) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 1;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000044c bits 6:5) field LF_PROP_LEFT_SHIFT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_PROP_LEFT_SHIFT_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_PROP_LEFT_SHIFT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_PROP_LEFT_SHIFT_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_PROP_LEFT_SHIFT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_LF_PROP_LEFT_SHIFT_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_LF_PROP_CTRL_GAIN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_LF_PROP_CTRL_GAIN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_LF_PROP_CTRL_GAIN_set", A, 15);
    if (value > 31)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_LF_PROP_CTRL_GAIN_set", value, 31);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_LF_PROP_CTRL_GAIN_set", A, value );

    /* (0x0000044c bits 4:0) field LF_PROP_CTRL_GAIN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_PROP_CTRL_GAIN_MSK,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_PROP_CTRL_GAIN_OFF,
                                                                    value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_LF_PROP_CTRL_GAIN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_LF_PROP_CTRL_GAIN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_LF_PROP_CTRL_GAIN_get", A, 15);
    /* (0x0000044c bits 4:0) field LF_PROP_CTRL_GAIN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_PROP_CTRL_GAIN_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_PROP_CTRL_GAIN_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_LF_PROP_CTRL_GAIN_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_LF_PROP_CTRL_GAIN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_LF_PROP_CTRL_GAIN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_LF_PROP_CTRL_GAIN_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_LF_PROP_CTRL_GAIN_set", stop_bit, start_bit );
    if (stop_bit > 4) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_LF_PROP_CTRL_GAIN_set", stop_bit, 4 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_LF_PROP_CTRL_GAIN_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000044c bits 4:0) field LF_PROP_CTRL_GAIN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 4) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 4;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000044c bits 4:0) field LF_PROP_CTRL_GAIN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_field_set( b_ptr,
                                                                        h_ptr,
                                                                        A,
                                                                        subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_PROP_CTRL_GAIN_OFF + subfield_offset),
                                                                        PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_PROP_CTRL_GAIN_OFF + subfield_offset,
                                                                        value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_LF_PROP_CTRL_GAIN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_LF_PROP_CTRL_GAIN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_LF_PROP_CTRL_GAIN_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_LF_PROP_CTRL_GAIN_get", stop_bit, start_bit );
    if (stop_bit > 4) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_LF_PROP_CTRL_GAIN_get", stop_bit, 4 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 4) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 4;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000044c bits 4:0) field LF_PROP_CTRL_GAIN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_PROP_CTRL_GAIN_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_PROP_CTRL_GAIN_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_PROP_CTRL_GAIN_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_1_BIT_LF_PROP_CTRL_GAIN_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_LF_PROP_CTRL_GAIN_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_LF_CLAMP_MIN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_LF_CLAMP_MIN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A,
                                                         UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_LF_CLAMP_MIN_set", A, 15);
    if (value > 4095)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_LF_CLAMP_MIN_set", value, 4095);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_LF_CLAMP_MIN_set", A, value );

    /* (0x00000450 bits 23:12) field LF_CLAMP_MIN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_BIT_LF_CLAMP_MIN_MSK,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_BIT_LF_CLAMP_MIN_OFF,
                                                                    value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_LF_CLAMP_MIN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_LF_CLAMP_MIN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_LF_CLAMP_MIN_get", A, 15);
    /* (0x00000450 bits 23:12) field LF_CLAMP_MIN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_BIT_LF_CLAMP_MIN_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_BIT_LF_CLAMP_MIN_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_LF_CLAMP_MIN_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_LF_CLAMP_MIN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_LF_CLAMP_MIN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_LF_CLAMP_MIN_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_LF_CLAMP_MIN_set", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_LF_CLAMP_MIN_set", stop_bit, 11 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_LF_CLAMP_MIN_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000450 bits 23:12) field LF_CLAMP_MIN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000450 bits 23:12) field LF_CLAMP_MIN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_field_set( b_ptr,
                                                                        h_ptr,
                                                                        A,
                                                                        subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_BIT_LF_CLAMP_MIN_OFF + subfield_offset),
                                                                        PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_BIT_LF_CLAMP_MIN_OFF + subfield_offset,
                                                                        value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_LF_CLAMP_MIN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_LF_CLAMP_MIN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_LF_CLAMP_MIN_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_LF_CLAMP_MIN_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_LF_CLAMP_MIN_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000450 bits 23:12) field LF_CLAMP_MIN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_BIT_LF_CLAMP_MIN_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_BIT_LF_CLAMP_MIN_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_BIT_LF_CLAMP_MIN_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_BIT_LF_CLAMP_MIN_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_LF_CLAMP_MIN_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_LF_CLAMP_MAX_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_LF_CLAMP_MAX_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A,
                                                         UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_LF_CLAMP_MAX_set", A, 15);
    if (value > 4095)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_LF_CLAMP_MAX_set", value, 4095);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_LF_CLAMP_MAX_set", A, value );

    /* (0x00000450 bits 11:0) field LF_CLAMP_MAX of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_BIT_LF_CLAMP_MAX_MSK,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_BIT_LF_CLAMP_MAX_OFF,
                                                                    value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_LF_CLAMP_MAX_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_LF_CLAMP_MAX_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_LF_CLAMP_MAX_get", A, 15);
    /* (0x00000450 bits 11:0) field LF_CLAMP_MAX of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_BIT_LF_CLAMP_MAX_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_BIT_LF_CLAMP_MAX_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_LF_CLAMP_MAX_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_LF_CLAMP_MAX_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_LF_CLAMP_MAX_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_LF_CLAMP_MAX_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_LF_CLAMP_MAX_set", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_LF_CLAMP_MAX_set", stop_bit, 11 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_LF_CLAMP_MAX_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000450 bits 11:0) field LF_CLAMP_MAX of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 11) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 11;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000450 bits 11:0) field LF_CLAMP_MAX of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_field_set( b_ptr,
                                                                        h_ptr,
                                                                        A,
                                                                        subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_BIT_LF_CLAMP_MAX_OFF + subfield_offset),
                                                                        PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_BIT_LF_CLAMP_MAX_OFF + subfield_offset,
                                                                        value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_LF_CLAMP_MAX_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_LF_CLAMP_MAX_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_LF_CLAMP_MAX_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_LF_CLAMP_MAX_get", stop_bit, start_bit );
    if (stop_bit > 11) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_LF_CLAMP_MAX_get", stop_bit, 11 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 11) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 11;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000450 bits 11:0) field LF_CLAMP_MAX of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_BIT_LF_CLAMP_MAX_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_BIT_LF_CLAMP_MAX_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_BIT_LF_CLAMP_MAX_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_CFG_2_BIT_LF_CLAMP_MAX_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_LF_CLAMP_MAX_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PGA_ENB_CALIB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PGA_ENB_CALIB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A,
                                                          UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PGA_ENB_CALIB_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PGA_ENB_CALIB_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PGA_ENB_CALIB_set", A, value );

    /* (0x00000458 bits 31) field PGA_ENB_CALIB of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_PGA_ENB_CALIB_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_PGA_ENB_CALIB_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PGA_ENB_CALIB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PGA_ENB_CALIB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PGA_ENB_CALIB_get", A, 15);
    /* (0x00000458 bits 31) field PGA_ENB_CALIB of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_PGA_ENB_CALIB_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_PGA_ENB_CALIB_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PGA_ENB_CALIB_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PGA_ENB_DEFAULT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PGA_ENB_DEFAULT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PGA_ENB_DEFAULT_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PGA_ENB_DEFAULT_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PGA_ENB_DEFAULT_set", A, value );

    /* (0x00000458 bits 30) field PGA_ENB_DEFAULT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_PGA_ENB_DEFAULT_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_PGA_ENB_DEFAULT_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PGA_ENB_DEFAULT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PGA_ENB_DEFAULT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PGA_ENB_DEFAULT_get", A, 15);
    /* (0x00000458 bits 30) field PGA_ENB_DEFAULT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_PGA_ENB_DEFAULT_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_PGA_ENB_DEFAULT_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PGA_ENB_DEFAULT_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PGA_ENB_OVR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PGA_ENB_OVR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A,
                                                        UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PGA_ENB_OVR_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PGA_ENB_OVR_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PGA_ENB_OVR_set", A, value );

    /* (0x00000458 bits 29) field PGA_ENB_OVR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_PGA_ENB_OVR_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_PGA_ENB_OVR_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PGA_ENB_OVR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PGA_ENB_OVR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PGA_ENB_OVR_get", A, 15);
    /* (0x00000458 bits 29) field PGA_ENB_OVR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_PGA_ENB_OVR_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_PGA_ENB_OVR_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PGA_ENB_OVR_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PGA_ENB_OVR_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PGA_ENB_OVR_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A,
                                                           UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PGA_ENB_OVR_EN_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PGA_ENB_OVR_EN_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PGA_ENB_OVR_EN_set", A, value );

    /* (0x00000458 bits 28) field PGA_ENB_OVR_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_PGA_ENB_OVR_EN_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_PGA_ENB_OVR_EN_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PGA_ENB_OVR_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PGA_ENB_OVR_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PGA_ENB_OVR_EN_get", A, 15);
    /* (0x00000458 bits 28) field PGA_ENB_OVR_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_PGA_ENB_OVR_EN_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_PGA_ENB_OVR_EN_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PGA_ENB_OVR_EN_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_CAL_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_CAL_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_CAL_EN_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_CAL_EN_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_CAL_EN_set", A, value );

    /* (0x00000458 bits 27) field PHGEN_REGV_CAL_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_PHGEN_REGV_CAL_EN_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_PHGEN_REGV_CAL_EN_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_CAL_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_CAL_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_CAL_EN_get", A, 15);
    /* (0x00000458 bits 27) field PHGEN_REGV_CAL_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_PHGEN_REGV_CAL_EN_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_PHGEN_REGV_CAL_EN_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_CAL_EN_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_CT_CAL_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_CT_CAL_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_CT_CAL_EN_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_CAL_EN_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_CAL_EN_set", A, value );

    /* (0x00000458 bits 26) field PHGEN_CT_CAL_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_PHGEN_CT_CAL_EN_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_PHGEN_CT_CAL_EN_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CT_CAL_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CT_CAL_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_CT_CAL_EN_get", A, 15);
    /* (0x00000458 bits 26) field PHGEN_CT_CAL_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_PHGEN_CT_CAL_EN_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_PHGEN_CT_CAL_EN_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_CAL_EN_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_CAL_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_CAL_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_CAL_EN_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_CAL_EN_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_CAL_EN_set", A, value );

    /* (0x00000458 bits 25) field PHGEN_FT_CAL_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_PHGEN_FT_CAL_EN_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_PHGEN_FT_CAL_EN_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_CAL_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_CAL_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_CAL_EN_get", A, 15);
    /* (0x00000458 bits 25) field PHGEN_FT_CAL_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_PHGEN_FT_CAL_EN_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_PHGEN_FT_CAL_EN_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_CAL_EN_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_TX_EMI_ROP_RON_CAL_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_TX_EMI_ROP_RON_CAL_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_TX_EMI_ROP_RON_CAL_EN_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_TX_EMI_ROP_RON_CAL_EN_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_TX_EMI_ROP_RON_CAL_EN_set", A, value );

    /* (0x00000458 bits 24) field TX_EMI_ROP_RON_CAL_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_TX_EMI_ROP_RON_CAL_EN_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_TX_EMI_ROP_RON_CAL_EN_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_TX_EMI_ROP_RON_CAL_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_TX_EMI_ROP_RON_CAL_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_TX_EMI_ROP_RON_CAL_EN_get", A, 15);
    /* (0x00000458 bits 24) field TX_EMI_ROP_RON_CAL_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_TX_EMI_ROP_RON_CAL_EN_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_TX_EMI_ROP_RON_CAL_EN_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_TX_EMI_ROP_RON_CAL_EN_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_TX_DCD_CALIB_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_TX_DCD_CALIB_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_TX_DCD_CALIB_EN_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_TX_DCD_CALIB_EN_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_TX_DCD_CALIB_EN_set", A, value );

    /* (0x00000458 bits 22) field TX_DCD_CALIB_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_TX_DCD_CALIB_EN_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_TX_DCD_CALIB_EN_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_TX_DCD_CALIB_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_TX_DCD_CALIB_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_TX_DCD_CALIB_EN_get", A, 15);
    /* (0x00000458 bits 22) field TX_DCD_CALIB_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_TX_DCD_CALIB_EN_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_TX_DCD_CALIB_EN_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_TX_DCD_CALIB_EN_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_TX_DCD_CALIB_DIV3_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_TX_DCD_CALIB_DIV3_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_TX_DCD_CALIB_DIV3_EN_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_TX_DCD_CALIB_DIV3_EN_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_TX_DCD_CALIB_DIV3_EN_set", A, value );

    /* (0x00000458 bits 21) field TX_DCD_CALIB_DIV3_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_TX_DCD_CALIB_DIV3_EN_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_TX_DCD_CALIB_DIV3_EN_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_TX_DCD_CALIB_DIV3_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_TX_DCD_CALIB_DIV3_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_TX_DCD_CALIB_DIV3_EN_get", A, 15);
    /* (0x00000458 bits 21) field TX_DCD_CALIB_DIV3_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_TX_DCD_CALIB_DIV3_EN_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_TX_DCD_CALIB_DIV3_EN_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_TX_DCD_CALIB_DIV3_EN_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADC_CALIB_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADC_CALIB_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A,
                                                         UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADC_CALIB_EN_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADC_CALIB_EN_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADC_CALIB_EN_set", A, value );

    /* (0x00000458 bits 20) field ADC_CALIB_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_ADC_CALIB_EN_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_ADC_CALIB_EN_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADC_CALIB_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADC_CALIB_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADC_CALIB_EN_get", A, 15);
    /* (0x00000458 bits 20) field ADC_CALIB_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_ADC_CALIB_EN_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_ADC_CALIB_EN_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADC_CALIB_EN_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADAPT_MISSION_CNTR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADAPT_MISSION_CNTR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_MISSION_CNTR_set", A, 15);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADAPT_MISSION_CNTR_set", value, 15);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_MISSION_CNTR_set", A, value );

    /* (0x00000458 bits 19:16) field ADAPT_MISSION_CNTR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_ADAPT_MISSION_CNTR_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_ADAPT_MISSION_CNTR_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_MISSION_CNTR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_MISSION_CNTR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_MISSION_CNTR_get", A, 15);
    /* (0x00000458 bits 19:16) field ADAPT_MISSION_CNTR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_ADAPT_MISSION_CNTR_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_ADAPT_MISSION_CNTR_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_MISSION_CNTR_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_ADAPT_MISSION_CNTR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_ADAPT_MISSION_CNTR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_ADAPT_MISSION_CNTR_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_ADAPT_MISSION_CNTR_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_ADAPT_MISSION_CNTR_set", stop_bit, 3 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_ADAPT_MISSION_CNTR_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000458 bits 19:16) field ADAPT_MISSION_CNTR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000458 bits 19:16) field ADAPT_MISSION_CNTR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_ADAPT_MISSION_CNTR_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_ADAPT_MISSION_CNTR_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_ADAPT_MISSION_CNTR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_ADAPT_MISSION_CNTR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_ADAPT_MISSION_CNTR_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_ADAPT_MISSION_CNTR_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_ADAPT_MISSION_CNTR_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000458 bits 19:16) field ADAPT_MISSION_CNTR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_ADAPT_MISSION_CNTR_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_ADAPT_MISSION_CNTR_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_ADAPT_MISSION_CNTR_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_1_BIT_ADAPT_MISSION_CNTR_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_ADAPT_MISSION_CNTR_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS7_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS7_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS7_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS7_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS7_set", A, value );

    /* (0x0000045c bits 23:21) field MU_STEP_GAIN_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS7_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS7_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS7_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS7_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS7_get", A, 15);
    /* (0x0000045c bits 23:21) field MU_STEP_GAIN_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS7_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS7_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS7_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS7_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS7_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS7_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS7_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS7_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS7_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000045c bits 23:21) field MU_STEP_GAIN_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000045c bits 23:21) field MU_STEP_GAIN_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS7_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS7_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS7_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS7_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS7_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS7_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS7_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000045c bits 23:21) field MU_STEP_GAIN_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS7_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS7_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS7_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS7_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS7_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS6_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS6_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS6_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS6_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS6_set", A, value );

    /* (0x0000045c bits 20:18) field MU_STEP_GAIN_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS6_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS6_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS6_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS6_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS6_get", A, 15);
    /* (0x0000045c bits 20:18) field MU_STEP_GAIN_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS6_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS6_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS6_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS6_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS6_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS6_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS6_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS6_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS6_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000045c bits 20:18) field MU_STEP_GAIN_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000045c bits 20:18) field MU_STEP_GAIN_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS6_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS6_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS6_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS6_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS6_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS6_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS6_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000045c bits 20:18) field MU_STEP_GAIN_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS6_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS6_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS6_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS6_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS6_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS5_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS5_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS5_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS5_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS5_set", A, value );

    /* (0x0000045c bits 17:15) field MU_STEP_GAIN_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS5_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS5_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS5_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS5_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS5_get", A, 15);
    /* (0x0000045c bits 17:15) field MU_STEP_GAIN_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS5_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS5_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS5_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS5_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS5_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS5_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS5_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS5_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS5_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000045c bits 17:15) field MU_STEP_GAIN_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000045c bits 17:15) field MU_STEP_GAIN_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS5_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS5_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS5_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS5_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS5_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS5_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS5_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000045c bits 17:15) field MU_STEP_GAIN_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS5_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS5_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS5_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS5_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS5_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS4_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS4_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS4_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS4_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS4_set", A, value );

    /* (0x0000045c bits 14:12) field MU_STEP_GAIN_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS4_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS4_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS4_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS4_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS4_get", A, 15);
    /* (0x0000045c bits 14:12) field MU_STEP_GAIN_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS4_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS4_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS4_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS4_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS4_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS4_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS4_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS4_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS4_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000045c bits 14:12) field MU_STEP_GAIN_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000045c bits 14:12) field MU_STEP_GAIN_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS4_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS4_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS4_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS4_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS4_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS4_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS4_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000045c bits 14:12) field MU_STEP_GAIN_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS4_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS4_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS4_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS4_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS4_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS3_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS3_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS3_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS3_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS3_set", A, value );

    /* (0x0000045c bits 11:9) field MU_STEP_GAIN_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS3_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS3_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS3_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS3_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS3_get", A, 15);
    /* (0x0000045c bits 11:9) field MU_STEP_GAIN_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS3_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS3_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS3_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS3_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS3_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS3_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS3_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS3_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS3_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000045c bits 11:9) field MU_STEP_GAIN_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000045c bits 11:9) field MU_STEP_GAIN_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS3_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS3_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS3_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS3_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS3_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS3_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS3_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000045c bits 11:9) field MU_STEP_GAIN_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS3_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS3_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS3_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS3_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS3_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS2_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS2_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS2_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS2_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS2_set", A, value );

    /* (0x0000045c bits 8:6) field MU_STEP_GAIN_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS2_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS2_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS2_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS2_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS2_get", A, 15);
    /* (0x0000045c bits 8:6) field MU_STEP_GAIN_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS2_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS2_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS2_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS2_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS2_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS2_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS2_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS2_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS2_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000045c bits 8:6) field MU_STEP_GAIN_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000045c bits 8:6) field MU_STEP_GAIN_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS2_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS2_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS2_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS2_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS2_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS2_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS2_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000045c bits 8:6) field MU_STEP_GAIN_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS2_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS2_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS2_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS2_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS2_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS1_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS1_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS1_set", A, value );

    /* (0x0000045c bits 5:3) field MU_STEP_GAIN_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS1_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS1_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS1_get", A, 15);
    /* (0x0000045c bits 5:3) field MU_STEP_GAIN_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS1_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS1_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS1_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS1_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS1_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS1_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS1_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000045c bits 5:3) field MU_STEP_GAIN_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000045c bits 5:3) field MU_STEP_GAIN_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS1_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS1_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS1_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS1_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS1_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000045c bits 5:3) field MU_STEP_GAIN_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS1_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS1_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS1_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS1_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS1_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS0_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS0_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS0_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS0_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS0_set", A, value );

    /* (0x0000045c bits 2:0) field MU_STEP_GAIN_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS0_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS0_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS0_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS0_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS0_get", A, 15);
    /* (0x0000045c bits 2:0) field MU_STEP_GAIN_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS0_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS0_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_GAIN_PASS0_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS0_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS0_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS0_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS0_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS0_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS0_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000045c bits 2:0) field MU_STEP_GAIN_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000045c bits 2:0) field MU_STEP_GAIN_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS0_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS0_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS0_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS0_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS0_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS0_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS0_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000045c bits 2:0) field MU_STEP_GAIN_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS0_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS0_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS0_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_2_BIT_MU_STEP_GAIN_PASS0_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_GAIN_PASS0_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS7_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS7_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS7_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS7_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS7_set", A, value );

    /* (0x00000460 bits 23:21) field MU_STEP_OFFSET_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS7_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS7_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS7_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS7_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS7_get", A, 15);
    /* (0x00000460 bits 23:21) field MU_STEP_OFFSET_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS7_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS7_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS7_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS7_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit,
                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS7_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit,
                                                                       UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS7_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS7_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS7_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS7_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000460 bits 23:21) field MU_STEP_OFFSET_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000460 bits 23:21) field MU_STEP_OFFSET_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS7_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS7_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS7_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS7_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS7_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS7_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS7_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000460 bits 23:21) field MU_STEP_OFFSET_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS7_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS7_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS7_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS7_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS7_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS6_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS6_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS6_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS6_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS6_set", A, value );

    /* (0x00000460 bits 20:18) field MU_STEP_OFFSET_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS6_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS6_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS6_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS6_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS6_get", A, 15);
    /* (0x00000460 bits 20:18) field MU_STEP_OFFSET_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS6_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS6_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS6_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS6_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit,
                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS6_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit,
                                                                       UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS6_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS6_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS6_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS6_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000460 bits 20:18) field MU_STEP_OFFSET_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000460 bits 20:18) field MU_STEP_OFFSET_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS6_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS6_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS6_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS6_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS6_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS6_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS6_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000460 bits 20:18) field MU_STEP_OFFSET_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS6_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS6_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS6_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS6_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS6_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS5_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS5_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS5_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS5_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS5_set", A, value );

    /* (0x00000460 bits 17:15) field MU_STEP_OFFSET_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS5_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS5_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS5_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS5_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS5_get", A, 15);
    /* (0x00000460 bits 17:15) field MU_STEP_OFFSET_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS5_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS5_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS5_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS5_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit,
                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS5_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit,
                                                                       UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS5_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS5_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS5_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS5_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000460 bits 17:15) field MU_STEP_OFFSET_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000460 bits 17:15) field MU_STEP_OFFSET_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS5_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS5_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS5_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS5_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS5_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS5_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS5_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000460 bits 17:15) field MU_STEP_OFFSET_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS5_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS5_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS5_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS5_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS5_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS4_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS4_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS4_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS4_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS4_set", A, value );

    /* (0x00000460 bits 14:12) field MU_STEP_OFFSET_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS4_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS4_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS4_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS4_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS4_get", A, 15);
    /* (0x00000460 bits 14:12) field MU_STEP_OFFSET_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS4_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS4_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS4_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS4_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit,
                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS4_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit,
                                                                       UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS4_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS4_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS4_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS4_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000460 bits 14:12) field MU_STEP_OFFSET_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000460 bits 14:12) field MU_STEP_OFFSET_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS4_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS4_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS4_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS4_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS4_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS4_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS4_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000460 bits 14:12) field MU_STEP_OFFSET_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS4_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS4_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS4_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS4_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS4_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS3_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS3_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS3_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS3_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS3_set", A, value );

    /* (0x00000460 bits 11:9) field MU_STEP_OFFSET_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS3_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS3_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS3_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS3_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS3_get", A, 15);
    /* (0x00000460 bits 11:9) field MU_STEP_OFFSET_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS3_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS3_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS3_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS3_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit,
                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS3_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit,
                                                                       UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS3_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS3_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS3_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS3_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000460 bits 11:9) field MU_STEP_OFFSET_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000460 bits 11:9) field MU_STEP_OFFSET_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS3_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS3_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS3_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS3_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS3_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS3_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS3_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000460 bits 11:9) field MU_STEP_OFFSET_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS3_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS3_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS3_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS3_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS3_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS2_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS2_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS2_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS2_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS2_set", A, value );

    /* (0x00000460 bits 8:6) field MU_STEP_OFFSET_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS2_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS2_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS2_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS2_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS2_get", A, 15);
    /* (0x00000460 bits 8:6) field MU_STEP_OFFSET_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS2_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS2_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS2_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS2_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit,
                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS2_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit,
                                                                       UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS2_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS2_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS2_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS2_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000460 bits 8:6) field MU_STEP_OFFSET_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000460 bits 8:6) field MU_STEP_OFFSET_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS2_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS2_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS2_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS2_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS2_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS2_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS2_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000460 bits 8:6) field MU_STEP_OFFSET_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS2_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS2_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS2_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS2_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS2_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS1_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS1_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS1_set", A, value );

    /* (0x00000460 bits 5:3) field MU_STEP_OFFSET_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS1_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS1_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS1_get", A, 15);
    /* (0x00000460 bits 5:3) field MU_STEP_OFFSET_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS1_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS1_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS1_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit,
                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit,
                                                                       UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS1_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS1_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS1_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS1_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000460 bits 5:3) field MU_STEP_OFFSET_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000460 bits 5:3) field MU_STEP_OFFSET_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS1_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS1_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS1_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS1_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS1_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000460 bits 5:3) field MU_STEP_OFFSET_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS1_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS1_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS1_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS1_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS1_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS0_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS0_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS0_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS0_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS0_set", A, value );

    /* (0x00000460 bits 2:0) field MU_STEP_OFFSET_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS0_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS0_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS0_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS0_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS0_get", A, 15);
    /* (0x00000460 bits 2:0) field MU_STEP_OFFSET_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS0_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS0_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_OFFSET_PASS0_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS0_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit,
                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS0_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit,
                                                                       UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS0_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS0_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS0_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS0_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000460 bits 2:0) field MU_STEP_OFFSET_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000460 bits 2:0) field MU_STEP_OFFSET_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS0_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS0_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS0_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS0_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS0_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS0_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS0_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000460 bits 2:0) field MU_STEP_OFFSET_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS0_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS0_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS0_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_3_BIT_MU_STEP_OFFSET_PASS0_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_OFFSET_PASS0_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_COEF_PASS7_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_COEF_PASS7_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS7_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS7_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS7_set", A, value );

    /* (0x00000464 bits 23:21) field MU_STEP_COEF_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS7_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS7_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_COEF_PASS7_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_COEF_PASS7_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS7_get", A, 15);
    /* (0x00000464 bits 23:21) field MU_STEP_COEF_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS7_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS7_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS7_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS7_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS7_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS7_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS7_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS7_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS7_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000464 bits 23:21) field MU_STEP_COEF_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000464 bits 23:21) field MU_STEP_COEF_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS7_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS7_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS7_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS7_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS7_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS7_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS7_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000464 bits 23:21) field MU_STEP_COEF_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS7_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS7_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS7_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS7_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS7_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_COEF_PASS6_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_COEF_PASS6_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS6_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS6_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS6_set", A, value );

    /* (0x00000464 bits 20:18) field MU_STEP_COEF_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS6_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS6_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_COEF_PASS6_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_COEF_PASS6_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS6_get", A, 15);
    /* (0x00000464 bits 20:18) field MU_STEP_COEF_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS6_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS6_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS6_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS6_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS6_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS6_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS6_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS6_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS6_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000464 bits 20:18) field MU_STEP_COEF_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000464 bits 20:18) field MU_STEP_COEF_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS6_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS6_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS6_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS6_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS6_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS6_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS6_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000464 bits 20:18) field MU_STEP_COEF_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS6_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS6_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS6_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS6_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS6_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_COEF_PASS5_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_COEF_PASS5_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS5_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS5_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS5_set", A, value );

    /* (0x00000464 bits 17:15) field MU_STEP_COEF_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS5_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS5_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_COEF_PASS5_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_COEF_PASS5_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS5_get", A, 15);
    /* (0x00000464 bits 17:15) field MU_STEP_COEF_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS5_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS5_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS5_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS5_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS5_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS5_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS5_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS5_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS5_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000464 bits 17:15) field MU_STEP_COEF_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000464 bits 17:15) field MU_STEP_COEF_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS5_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS5_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS5_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS5_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS5_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS5_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS5_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000464 bits 17:15) field MU_STEP_COEF_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS5_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS5_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS5_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS5_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS5_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_COEF_PASS4_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_COEF_PASS4_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS4_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS4_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS4_set", A, value );

    /* (0x00000464 bits 14:12) field MU_STEP_COEF_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS4_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS4_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_COEF_PASS4_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_COEF_PASS4_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS4_get", A, 15);
    /* (0x00000464 bits 14:12) field MU_STEP_COEF_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS4_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS4_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS4_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS4_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS4_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS4_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS4_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS4_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS4_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000464 bits 14:12) field MU_STEP_COEF_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000464 bits 14:12) field MU_STEP_COEF_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS4_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS4_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS4_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS4_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS4_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS4_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS4_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000464 bits 14:12) field MU_STEP_COEF_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS4_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS4_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS4_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS4_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS4_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_COEF_PASS3_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_COEF_PASS3_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS3_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS3_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS3_set", A, value );

    /* (0x00000464 bits 11:9) field MU_STEP_COEF_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS3_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS3_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_COEF_PASS3_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_COEF_PASS3_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS3_get", A, 15);
    /* (0x00000464 bits 11:9) field MU_STEP_COEF_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS3_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS3_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS3_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS3_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS3_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS3_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS3_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS3_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS3_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000464 bits 11:9) field MU_STEP_COEF_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000464 bits 11:9) field MU_STEP_COEF_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS3_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS3_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS3_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS3_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS3_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS3_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS3_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000464 bits 11:9) field MU_STEP_COEF_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS3_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS3_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS3_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS3_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS3_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_COEF_PASS2_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_COEF_PASS2_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS2_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS2_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS2_set", A, value );

    /* (0x00000464 bits 8:6) field MU_STEP_COEF_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS2_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS2_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_COEF_PASS2_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_COEF_PASS2_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS2_get", A, 15);
    /* (0x00000464 bits 8:6) field MU_STEP_COEF_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS2_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS2_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS2_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS2_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS2_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS2_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS2_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS2_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS2_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000464 bits 8:6) field MU_STEP_COEF_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000464 bits 8:6) field MU_STEP_COEF_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS2_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS2_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS2_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS2_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS2_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS2_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS2_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000464 bits 8:6) field MU_STEP_COEF_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS2_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS2_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS2_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS2_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS2_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_COEF_PASS1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_COEF_PASS1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS1_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS1_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS1_set", A, value );

    /* (0x00000464 bits 5:3) field MU_STEP_COEF_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS1_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS1_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_COEF_PASS1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_COEF_PASS1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS1_get", A, 15);
    /* (0x00000464 bits 5:3) field MU_STEP_COEF_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS1_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS1_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS1_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS1_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS1_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS1_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS1_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000464 bits 5:3) field MU_STEP_COEF_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000464 bits 5:3) field MU_STEP_COEF_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS1_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS1_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS1_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS1_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS1_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000464 bits 5:3) field MU_STEP_COEF_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS1_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS1_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS1_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS1_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS1_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_COEF_PASS0_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_COEF_PASS0_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS0_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS0_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS0_set", A, value );

    /* (0x00000464 bits 2:0) field MU_STEP_COEF_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS0_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS0_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_COEF_PASS0_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_COEF_PASS0_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS0_get", A, 15);
    /* (0x00000464 bits 2:0) field MU_STEP_COEF_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS0_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS0_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_COEF_PASS0_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS0_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS0_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS0_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS0_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS0_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS0_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000464 bits 2:0) field MU_STEP_COEF_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000464 bits 2:0) field MU_STEP_COEF_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS0_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS0_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS0_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS0_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS0_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS0_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS0_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000464 bits 2:0) field MU_STEP_COEF_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS0_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS0_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS0_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_4_BIT_MU_STEP_COEF_PASS0_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_COEF_PASS0_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS7_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS7_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS7_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS7_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS7_set", A, value );

    /* (0x00000468 bits 23:21) field MU_STEP_ADC_MAP_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS7_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS7_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS7_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS7_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS7_get", A, 15);
    /* (0x00000468 bits 23:21) field MU_STEP_ADC_MAP_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS7_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS7_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS7_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS7_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit,
                                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS7_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit,
                                                                        UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS7_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS7_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS7_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS7_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000468 bits 23:21) field MU_STEP_ADC_MAP_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000468 bits 23:21) field MU_STEP_ADC_MAP_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS7_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS7_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS7_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS7_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS7_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS7_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS7_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000468 bits 23:21) field MU_STEP_ADC_MAP_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS7_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS7_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS7_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS7_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS7_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS6_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS6_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS6_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS6_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS6_set", A, value );

    /* (0x00000468 bits 20:18) field MU_STEP_ADC_MAP_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS6_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS6_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS6_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS6_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS6_get", A, 15);
    /* (0x00000468 bits 20:18) field MU_STEP_ADC_MAP_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS6_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS6_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS6_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS6_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit,
                                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS6_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit,
                                                                        UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS6_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS6_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS6_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS6_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000468 bits 20:18) field MU_STEP_ADC_MAP_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000468 bits 20:18) field MU_STEP_ADC_MAP_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS6_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS6_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS6_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS6_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS6_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS6_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS6_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000468 bits 20:18) field MU_STEP_ADC_MAP_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS6_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS6_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS6_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS6_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS6_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS5_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS5_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS5_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS5_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS5_set", A, value );

    /* (0x00000468 bits 17:15) field MU_STEP_ADC_MAP_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS5_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS5_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS5_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS5_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS5_get", A, 15);
    /* (0x00000468 bits 17:15) field MU_STEP_ADC_MAP_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS5_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS5_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS5_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS5_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit,
                                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS5_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit,
                                                                        UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS5_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS5_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS5_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS5_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000468 bits 17:15) field MU_STEP_ADC_MAP_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000468 bits 17:15) field MU_STEP_ADC_MAP_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS5_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS5_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS5_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS5_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS5_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS5_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS5_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000468 bits 17:15) field MU_STEP_ADC_MAP_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS5_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS5_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS5_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS5_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS5_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS4_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS4_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS4_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS4_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS4_set", A, value );

    /* (0x00000468 bits 14:12) field MU_STEP_ADC_MAP_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS4_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS4_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS4_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS4_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS4_get", A, 15);
    /* (0x00000468 bits 14:12) field MU_STEP_ADC_MAP_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS4_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS4_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS4_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS4_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit,
                                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS4_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit,
                                                                        UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS4_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS4_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS4_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS4_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000468 bits 14:12) field MU_STEP_ADC_MAP_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000468 bits 14:12) field MU_STEP_ADC_MAP_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS4_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS4_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS4_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS4_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS4_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS4_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS4_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000468 bits 14:12) field MU_STEP_ADC_MAP_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS4_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS4_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS4_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS4_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS4_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS3_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS3_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS3_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS3_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS3_set", A, value );

    /* (0x00000468 bits 11:9) field MU_STEP_ADC_MAP_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS3_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS3_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS3_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS3_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS3_get", A, 15);
    /* (0x00000468 bits 11:9) field MU_STEP_ADC_MAP_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS3_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS3_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS3_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS3_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit,
                                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS3_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit,
                                                                        UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS3_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS3_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS3_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS3_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000468 bits 11:9) field MU_STEP_ADC_MAP_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000468 bits 11:9) field MU_STEP_ADC_MAP_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS3_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS3_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS3_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS3_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS3_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS3_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS3_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000468 bits 11:9) field MU_STEP_ADC_MAP_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS3_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS3_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS3_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS3_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS3_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS2_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS2_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS2_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS2_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS2_set", A, value );

    /* (0x00000468 bits 8:6) field MU_STEP_ADC_MAP_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS2_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS2_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS2_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS2_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS2_get", A, 15);
    /* (0x00000468 bits 8:6) field MU_STEP_ADC_MAP_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS2_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS2_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS2_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS2_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit,
                                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS2_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit,
                                                                        UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS2_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS2_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS2_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS2_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000468 bits 8:6) field MU_STEP_ADC_MAP_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000468 bits 8:6) field MU_STEP_ADC_MAP_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS2_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS2_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS2_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS2_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS2_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS2_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS2_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000468 bits 8:6) field MU_STEP_ADC_MAP_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS2_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS2_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS2_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS2_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS2_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS1_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS1_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS1_set", A, value );

    /* (0x00000468 bits 5:3) field MU_STEP_ADC_MAP_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS1_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS1_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS1_get", A, 15);
    /* (0x00000468 bits 5:3) field MU_STEP_ADC_MAP_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS1_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS1_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS1_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit,
                                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit,
                                                                        UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS1_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS1_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS1_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS1_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000468 bits 5:3) field MU_STEP_ADC_MAP_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000468 bits 5:3) field MU_STEP_ADC_MAP_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS1_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS1_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS1_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS1_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS1_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000468 bits 5:3) field MU_STEP_ADC_MAP_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS1_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS1_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS1_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS1_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS1_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS0_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS0_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS0_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS0_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS0_set", A, value );

    /* (0x00000468 bits 2:0) field MU_STEP_ADC_MAP_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS0_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS0_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS0_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS0_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS0_get", A, 15);
    /* (0x00000468 bits 2:0) field MU_STEP_ADC_MAP_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS0_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS0_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_MU_STEP_ADC_MAP_PASS0_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS0_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit,
                                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS0_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit,
                                                                        UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS0_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS0_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS0_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS0_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000468 bits 2:0) field MU_STEP_ADC_MAP_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000468 bits 2:0) field MU_STEP_ADC_MAP_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS0_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS0_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS0_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS0_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS0_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS0_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS0_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000468 bits 2:0) field MU_STEP_ADC_MAP_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS0_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS0_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS0_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_5_BIT_MU_STEP_ADC_MAP_PASS0_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_MU_STEP_ADC_MAP_PASS0_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS7_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS7_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS7_set", A, 15);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS7_set", value, 15);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS7_set", A, value );

    /* (0x0000046c bits 31:28) field ADAPT_LOOPS_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS7_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS7_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS7_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS7_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS7_get", A, 15);
    /* (0x0000046c bits 31:28) field ADAPT_LOOPS_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS7_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS7_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS7_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS7_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS7_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS7_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS7_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS7_set", stop_bit, 3 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS7_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000046c bits 31:28) field ADAPT_LOOPS_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000046c bits 31:28) field ADAPT_LOOPS_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS7_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS7_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS7_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS7_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS7_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS7_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS7_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000046c bits 31:28) field ADAPT_LOOPS_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS7_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS7_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS7_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS7_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS7_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS6_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS6_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS6_set", A, 15);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS6_set", value, 15);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS6_set", A, value );

    /* (0x0000046c bits 27:24) field ADAPT_LOOPS_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS6_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS6_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS6_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS6_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS6_get", A, 15);
    /* (0x0000046c bits 27:24) field ADAPT_LOOPS_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS6_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS6_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS6_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS6_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS6_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS6_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS6_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS6_set", stop_bit, 3 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS6_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000046c bits 27:24) field ADAPT_LOOPS_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000046c bits 27:24) field ADAPT_LOOPS_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS6_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS6_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS6_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS6_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS6_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS6_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS6_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000046c bits 27:24) field ADAPT_LOOPS_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS6_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS6_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS6_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS6_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS6_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS5_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS5_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS5_set", A, 15);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS5_set", value, 15);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS5_set", A, value );

    /* (0x0000046c bits 23:20) field ADAPT_LOOPS_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS5_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS5_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS5_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS5_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS5_get", A, 15);
    /* (0x0000046c bits 23:20) field ADAPT_LOOPS_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS5_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS5_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS5_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS5_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS5_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS5_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS5_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS5_set", stop_bit, 3 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS5_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000046c bits 23:20) field ADAPT_LOOPS_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000046c bits 23:20) field ADAPT_LOOPS_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS5_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS5_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS5_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS5_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS5_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS5_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS5_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000046c bits 23:20) field ADAPT_LOOPS_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS5_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS5_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS5_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS5_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS5_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS4_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS4_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS4_set", A, 15);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS4_set", value, 15);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS4_set", A, value );

    /* (0x0000046c bits 19:16) field ADAPT_LOOPS_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS4_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS4_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS4_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS4_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS4_get", A, 15);
    /* (0x0000046c bits 19:16) field ADAPT_LOOPS_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS4_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS4_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS4_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS4_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS4_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS4_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS4_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS4_set", stop_bit, 3 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS4_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000046c bits 19:16) field ADAPT_LOOPS_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000046c bits 19:16) field ADAPT_LOOPS_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS4_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS4_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS4_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS4_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS4_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS4_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS4_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000046c bits 19:16) field ADAPT_LOOPS_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS4_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS4_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS4_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS4_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS4_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS3_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS3_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS3_set", A, 15);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS3_set", value, 15);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS3_set", A, value );

    /* (0x0000046c bits 15:12) field ADAPT_LOOPS_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS3_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS3_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS3_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS3_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS3_get", A, 15);
    /* (0x0000046c bits 15:12) field ADAPT_LOOPS_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS3_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS3_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS3_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS3_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS3_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS3_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS3_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS3_set", stop_bit, 3 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS3_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000046c bits 15:12) field ADAPT_LOOPS_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000046c bits 15:12) field ADAPT_LOOPS_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS3_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS3_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS3_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS3_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS3_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS3_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS3_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000046c bits 15:12) field ADAPT_LOOPS_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS3_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS3_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS3_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS3_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS3_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS2_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS2_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS2_set", A, 15);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS2_set", value, 15);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS2_set", A, value );

    /* (0x0000046c bits 11:8) field ADAPT_LOOPS_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS2_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS2_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS2_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS2_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS2_get", A, 15);
    /* (0x0000046c bits 11:8) field ADAPT_LOOPS_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS2_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS2_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS2_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS2_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS2_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS2_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS2_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS2_set", stop_bit, 3 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS2_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000046c bits 11:8) field ADAPT_LOOPS_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000046c bits 11:8) field ADAPT_LOOPS_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS2_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS2_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS2_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS2_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS2_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS2_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS2_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000046c bits 11:8) field ADAPT_LOOPS_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS2_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS2_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS2_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS2_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS2_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS1_set", A, 15);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS1_set", value, 15);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS1_set", A, value );

    /* (0x0000046c bits 7:4) field ADAPT_LOOPS_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS1_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS1_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS1_get", A, 15);
    /* (0x0000046c bits 7:4) field ADAPT_LOOPS_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS1_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS1_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS1_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS1_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS1_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS1_set", stop_bit, 3 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS1_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000046c bits 7:4) field ADAPT_LOOPS_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000046c bits 7:4) field ADAPT_LOOPS_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS1_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS1_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS1_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS1_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS1_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000046c bits 7:4) field ADAPT_LOOPS_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS1_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS1_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS1_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS1_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS1_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS0_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS0_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS0_set", A, 15);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS0_set", value, 15);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS0_set", A, value );

    /* (0x0000046c bits 3:0) field ADAPT_LOOPS_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS0_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS0_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS0_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS0_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS0_get", A, 15);
    /* (0x0000046c bits 3:0) field ADAPT_LOOPS_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS0_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS0_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_LOOPS_PASS0_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS0_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS0_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS0_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS0_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS0_set", stop_bit, 3 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS0_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000046c bits 3:0) field ADAPT_LOOPS_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000046c bits 3:0) field ADAPT_LOOPS_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS0_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS0_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS0_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS0_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS0_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS0_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS0_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000046c bits 3:0) field ADAPT_LOOPS_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS0_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS0_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS0_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_6_BIT_ADAPT_LOOPS_PASS0_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_ADAPT_LOOPS_PASS0_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_SSI_OVR_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                       s16_handle_t *h_ptr,
                                                       UINT32 A,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_SSI_OVR_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                       s16_handle_t *h_ptr,
                                                       UINT32 A,
                                                       UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_SSI_OVR_EN_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_SSI_OVR_EN_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_SSI_OVR_EN_set", A, value );

    /* (0x00000470 bits 25) field SSI_OVR_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_BIT_SSI_OVR_EN_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_BIT_SSI_OVR_EN_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_SSI_OVR_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_SSI_OVR_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_SSI_OVR_EN_get", A, 15);
    /* (0x00000470 bits 25) field SSI_OVR_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_BIT_SSI_OVR_EN_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_BIT_SSI_OVR_EN_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_SSI_OVR_EN_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_SSI_MIN_THRESHOLD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_SSI_MIN_THRESHOLD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_SSI_MIN_THRESHOLD_set", A, 15);
    if (value > 31)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_SSI_MIN_THRESHOLD_set", value, 31);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_SSI_MIN_THRESHOLD_set", A, value );

    /* (0x00000470 bits 23:19) field SSI_MIN_THRESHOLD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_BIT_SSI_MIN_THRESHOLD_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_BIT_SSI_MIN_THRESHOLD_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_SSI_MIN_THRESHOLD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_SSI_MIN_THRESHOLD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_SSI_MIN_THRESHOLD_get", A, 15);
    /* (0x00000470 bits 23:19) field SSI_MIN_THRESHOLD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_BIT_SSI_MIN_THRESHOLD_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_BIT_SSI_MIN_THRESHOLD_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_SSI_MIN_THRESHOLD_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_SSI_MIN_THRESHOLD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_SSI_MIN_THRESHOLD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_SSI_MIN_THRESHOLD_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_SSI_MIN_THRESHOLD_set", stop_bit, start_bit );
    if (stop_bit > 4) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_SSI_MIN_THRESHOLD_set", stop_bit, 4 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_SSI_MIN_THRESHOLD_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000470 bits 23:19) field SSI_MIN_THRESHOLD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 4) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 4;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000470 bits 23:19) field SSI_MIN_THRESHOLD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_BIT_SSI_MIN_THRESHOLD_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_BIT_SSI_MIN_THRESHOLD_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_SSI_MIN_THRESHOLD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_SSI_MIN_THRESHOLD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_SSI_MIN_THRESHOLD_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_SSI_MIN_THRESHOLD_get", stop_bit, start_bit );
    if (stop_bit > 4) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_SSI_MIN_THRESHOLD_get", stop_bit, 4 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 4) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 4;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000470 bits 23:19) field SSI_MIN_THRESHOLD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_BIT_SSI_MIN_THRESHOLD_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_BIT_SSI_MIN_THRESHOLD_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_BIT_SSI_MIN_THRESHOLD_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_BIT_SSI_MIN_THRESHOLD_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_SSI_MIN_THRESHOLD_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_SSI_ADJUST_THRESHOLD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_SSI_ADJUST_THRESHOLD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_SSI_ADJUST_THRESHOLD_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_SSI_ADJUST_THRESHOLD_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_SSI_ADJUST_THRESHOLD_set", A, value );

    /* (0x00000470 bits 2) field SSI_ADJUST_THRESHOLD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_BIT_SSI_ADJUST_THRESHOLD_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_BIT_SSI_ADJUST_THRESHOLD_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_SSI_ADJUST_THRESHOLD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_SSI_ADJUST_THRESHOLD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_SSI_ADJUST_THRESHOLD_get", A, 15);
    /* (0x00000470 bits 2) field SSI_ADJUST_THRESHOLD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_BIT_SSI_ADJUST_THRESHOLD_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_BIT_SSI_ADJUST_THRESHOLD_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_SSI_ADJUST_THRESHOLD_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_SSI_REL_AMP_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_SSI_REL_AMP_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A,
                                                        UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_SSI_REL_AMP_set", A, 15);
    if (value > 3)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_SSI_REL_AMP_set", value, 3);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_SSI_REL_AMP_set", A, value );

    /* (0x00000470 bits 1:0) field SSI_REL_AMP of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_BIT_SSI_REL_AMP_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_BIT_SSI_REL_AMP_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_SSI_REL_AMP_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_SSI_REL_AMP_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_SSI_REL_AMP_get", A, 15);
    /* (0x00000470 bits 1:0) field SSI_REL_AMP of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_BIT_SSI_REL_AMP_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_BIT_SSI_REL_AMP_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_SSI_REL_AMP_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_SSI_REL_AMP_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_SSI_REL_AMP_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit,
                                                              UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_SSI_REL_AMP_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_SSI_REL_AMP_set", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_SSI_REL_AMP_set", stop_bit, 1 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_SSI_REL_AMP_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000470 bits 1:0) field SSI_REL_AMP of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 1) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 1;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000470 bits 1:0) field SSI_REL_AMP of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_BIT_SSI_REL_AMP_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_BIT_SSI_REL_AMP_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_SSI_REL_AMP_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_SSI_REL_AMP_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_SSI_REL_AMP_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_SSI_REL_AMP_get", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_SSI_REL_AMP_get", stop_bit, 1 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 1) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 1;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000470 bits 1:0) field SSI_REL_AMP of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_BIT_SSI_REL_AMP_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_BIT_SSI_REL_AMP_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_BIT_SSI_REL_AMP_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_CFG_7_BIT_SSI_REL_AMP_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_SSI_REL_AMP_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_RR_PERIOD_GAIN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_RR_PERIOD_GAIN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A,
                                                           UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RR_PERIOD_GAIN_set", A, 15);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_RR_PERIOD_GAIN_set", value, 15);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_RR_PERIOD_GAIN_set", A, value );

    /* (0x00000474 bits 28:25) field RR_PERIOD_GAIN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_field_set( b_ptr,
                                                               h_ptr,
                                                               A,
                                                               PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_GAIN_MSK,
                                                               PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_GAIN_OFF,
                                                               value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_RR_PERIOD_GAIN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_RR_PERIOD_GAIN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RR_PERIOD_GAIN_get", A, 15);
    /* (0x00000474 bits 28:25) field RR_PERIOD_GAIN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_read( b_ptr,
                                                                      h_ptr,
                                                                      A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_GAIN_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_GAIN_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_RR_PERIOD_GAIN_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_RR_PERIOD_GAIN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_RR_PERIOD_GAIN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_RR_PERIOD_GAIN_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_RR_PERIOD_GAIN_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_RR_PERIOD_GAIN_set", stop_bit, 3 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_RR_PERIOD_GAIN_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000474 bits 28:25) field RR_PERIOD_GAIN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000474 bits 28:25) field RR_PERIOD_GAIN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_field_set( b_ptr,
                                                                   h_ptr,
                                                                   A,
                                                                   subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_GAIN_OFF + subfield_offset),
                                                                   PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_GAIN_OFF + subfield_offset,
                                                                   value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_RR_PERIOD_GAIN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_RR_PERIOD_GAIN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_RR_PERIOD_GAIN_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_RR_PERIOD_GAIN_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_RR_PERIOD_GAIN_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000474 bits 28:25) field RR_PERIOD_GAIN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_read( b_ptr,
                                                                      h_ptr,
                                                                      A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_GAIN_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_GAIN_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_GAIN_MSK, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_GAIN_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_RR_PERIOD_GAIN_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_RR_PERIOD_ADC_MAP_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_RR_PERIOD_ADC_MAP_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RR_PERIOD_ADC_MAP_set", A, 15);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_RR_PERIOD_ADC_MAP_set", value, 15);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_RR_PERIOD_ADC_MAP_set", A, value );

    /* (0x00000474 bits 24:21) field RR_PERIOD_ADC_MAP of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_field_set( b_ptr,
                                                               h_ptr,
                                                               A,
                                                               PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_ADC_MAP_MSK,
                                                               PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_ADC_MAP_OFF,
                                                               value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_RR_PERIOD_ADC_MAP_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_RR_PERIOD_ADC_MAP_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RR_PERIOD_ADC_MAP_get", A, 15);
    /* (0x00000474 bits 24:21) field RR_PERIOD_ADC_MAP of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_read( b_ptr,
                                                                      h_ptr,
                                                                      A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_ADC_MAP_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_ADC_MAP_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_RR_PERIOD_ADC_MAP_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_RR_PERIOD_ADC_MAP_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_RR_PERIOD_ADC_MAP_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_RR_PERIOD_ADC_MAP_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_RR_PERIOD_ADC_MAP_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_RR_PERIOD_ADC_MAP_set", stop_bit, 3 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_RR_PERIOD_ADC_MAP_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000474 bits 24:21) field RR_PERIOD_ADC_MAP of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000474 bits 24:21) field RR_PERIOD_ADC_MAP of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_field_set( b_ptr,
                                                                   h_ptr,
                                                                   A,
                                                                   subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_ADC_MAP_OFF + subfield_offset),
                                                                   PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_ADC_MAP_OFF + subfield_offset,
                                                                   value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_RR_PERIOD_ADC_MAP_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_RR_PERIOD_ADC_MAP_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_RR_PERIOD_ADC_MAP_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_RR_PERIOD_ADC_MAP_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_RR_PERIOD_ADC_MAP_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000474 bits 24:21) field RR_PERIOD_ADC_MAP of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_read( b_ptr,
                                                                      h_ptr,
                                                                      A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_ADC_MAP_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_ADC_MAP_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_ADC_MAP_MSK, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_ADC_MAP_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_RR_PERIOD_ADC_MAP_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_RR_PERIOD_OFFSET_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_RR_PERIOD_OFFSET_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RR_PERIOD_OFFSET_set", A, 15);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_RR_PERIOD_OFFSET_set", value, 15);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_RR_PERIOD_OFFSET_set", A, value );

    /* (0x00000474 bits 20:17) field RR_PERIOD_OFFSET of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_field_set( b_ptr,
                                                               h_ptr,
                                                               A,
                                                               PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_OFFSET_MSK,
                                                               PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_OFFSET_OFF,
                                                               value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_RR_PERIOD_OFFSET_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_RR_PERIOD_OFFSET_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RR_PERIOD_OFFSET_get", A, 15);
    /* (0x00000474 bits 20:17) field RR_PERIOD_OFFSET of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_read( b_ptr,
                                                                      h_ptr,
                                                                      A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_OFFSET_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_OFFSET_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_RR_PERIOD_OFFSET_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_RR_PERIOD_OFFSET_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_RR_PERIOD_OFFSET_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_RR_PERIOD_OFFSET_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_RR_PERIOD_OFFSET_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_RR_PERIOD_OFFSET_set", stop_bit, 3 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_RR_PERIOD_OFFSET_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000474 bits 20:17) field RR_PERIOD_OFFSET of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000474 bits 20:17) field RR_PERIOD_OFFSET of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_field_set( b_ptr,
                                                                   h_ptr,
                                                                   A,
                                                                   subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_OFFSET_OFF + subfield_offset),
                                                                   PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_OFFSET_OFF + subfield_offset,
                                                                   value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_RR_PERIOD_OFFSET_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_RR_PERIOD_OFFSET_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_RR_PERIOD_OFFSET_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_RR_PERIOD_OFFSET_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_RR_PERIOD_OFFSET_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000474 bits 20:17) field RR_PERIOD_OFFSET of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_read( b_ptr,
                                                                      h_ptr,
                                                                      A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_OFFSET_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_OFFSET_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_OFFSET_MSK, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_OFFSET_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_RR_PERIOD_OFFSET_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_RR_PERIOD_COEF_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_RR_PERIOD_COEF_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A,
                                                           UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RR_PERIOD_COEF_set", A, 15);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_RR_PERIOD_COEF_set", value, 15);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_RR_PERIOD_COEF_set", A, value );

    /* (0x00000474 bits 16:13) field RR_PERIOD_COEF of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_field_set( b_ptr,
                                                               h_ptr,
                                                               A,
                                                               PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_COEF_MSK,
                                                               PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_COEF_OFF,
                                                               value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_RR_PERIOD_COEF_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_RR_PERIOD_COEF_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RR_PERIOD_COEF_get", A, 15);
    /* (0x00000474 bits 16:13) field RR_PERIOD_COEF of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_read( b_ptr,
                                                                      h_ptr,
                                                                      A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_COEF_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_COEF_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_RR_PERIOD_COEF_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_RR_PERIOD_COEF_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_RR_PERIOD_COEF_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_RR_PERIOD_COEF_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_RR_PERIOD_COEF_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_RR_PERIOD_COEF_set", stop_bit, 3 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_RR_PERIOD_COEF_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000474 bits 16:13) field RR_PERIOD_COEF of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000474 bits 16:13) field RR_PERIOD_COEF of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_field_set( b_ptr,
                                                                   h_ptr,
                                                                   A,
                                                                   subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_COEF_OFF + subfield_offset),
                                                                   PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_COEF_OFF + subfield_offset,
                                                                   value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_RR_PERIOD_COEF_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_RR_PERIOD_COEF_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_RR_PERIOD_COEF_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_RR_PERIOD_COEF_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_RR_PERIOD_COEF_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000474 bits 16:13) field RR_PERIOD_COEF of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_read( b_ptr,
                                                                      h_ptr,
                                                                      A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_COEF_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_COEF_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_COEF_MSK, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_COEF_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_RR_PERIOD_COEF_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_RR_PERIOD_DSS_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_RR_PERIOD_DSS_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A,
                                                          UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RR_PERIOD_DSS_set", A, 15);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_RR_PERIOD_DSS_set", value, 15);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_RR_PERIOD_DSS_set", A, value );

    /* (0x00000474 bits 8:5) field RR_PERIOD_DSS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_field_set( b_ptr,
                                                               h_ptr,
                                                               A,
                                                               PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_DSS_MSK,
                                                               PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_DSS_OFF,
                                                               value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_RR_PERIOD_DSS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_RR_PERIOD_DSS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_RR_PERIOD_DSS_get", A, 15);
    /* (0x00000474 bits 8:5) field RR_PERIOD_DSS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_read( b_ptr,
                                                                      h_ptr,
                                                                      A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_DSS_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_DSS_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_RR_PERIOD_DSS_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_RR_PERIOD_DSS_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit,
                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_RR_PERIOD_DSS_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit,
                                                                UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_RR_PERIOD_DSS_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_RR_PERIOD_DSS_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_RR_PERIOD_DSS_set", stop_bit, 3 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_RR_PERIOD_DSS_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000474 bits 8:5) field RR_PERIOD_DSS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000474 bits 8:5) field RR_PERIOD_DSS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_field_set( b_ptr,
                                                                   h_ptr,
                                                                   A,
                                                                   subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_DSS_OFF + subfield_offset),
                                                                   PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_DSS_OFF + subfield_offset,
                                                                   value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_RR_PERIOD_DSS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_RR_PERIOD_DSS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_RR_PERIOD_DSS_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_RR_PERIOD_DSS_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_RR_PERIOD_DSS_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000474 bits 8:5) field RR_PERIOD_DSS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_read( b_ptr,
                                                                      h_ptr,
                                                                      A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_DSS_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_DSS_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_DSS_MSK, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_RR_PERIOD_DSS_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_RR_PERIOD_DSS_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADAPT_MISSION_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADAPT_MISSION_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_MISSION_ENB_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADAPT_MISSION_ENB_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_MISSION_ENB_set", A, value );

    /* (0x00000474 bits 4) field ADAPT_MISSION_ENB of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_field_set( b_ptr,
                                                               h_ptr,
                                                               A,
                                                               PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_ADAPT_MISSION_ENB_MSK,
                                                               PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_ADAPT_MISSION_ENB_OFF,
                                                               value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_MISSION_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_MISSION_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_MISSION_ENB_get", A, 15);
    /* (0x00000474 bits 4) field ADAPT_MISSION_ENB of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_read( b_ptr,
                                                                      h_ptr,
                                                                      A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_ADAPT_MISSION_ENB_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_ADAPT_MISSION_ENB_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_MISSION_ENB_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADAPT_DELAY_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADAPT_DELAY_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A,
                                                        UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_DELAY_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADAPT_DELAY_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_DELAY_set", A, value );

    /* (0x00000474 bits 3:1) field ADAPT_DELAY of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_field_set( b_ptr,
                                                               h_ptr,
                                                               A,
                                                               PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_ADAPT_DELAY_MSK,
                                                               PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_ADAPT_DELAY_OFF,
                                                               value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_DELAY_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_DELAY_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_DELAY_get", A, 15);
    /* (0x00000474 bits 3:1) field ADAPT_DELAY of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_read( b_ptr,
                                                                      h_ptr,
                                                                      A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_ADAPT_DELAY_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_ADAPT_DELAY_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_DELAY_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_ADAPT_DELAY_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_ADAPT_DELAY_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit,
                                                              UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_ADAPT_DELAY_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_ADAPT_DELAY_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_ADAPT_DELAY_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_ADAPT_DELAY_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000474 bits 3:1) field ADAPT_DELAY of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000474 bits 3:1) field ADAPT_DELAY of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_field_set( b_ptr,
                                                                   h_ptr,
                                                                   A,
                                                                   subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_ADAPT_DELAY_OFF + subfield_offset),
                                                                   PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_ADAPT_DELAY_OFF + subfield_offset,
                                                                   value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_ADAPT_DELAY_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_ADAPT_DELAY_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_ADAPT_DELAY_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_ADAPT_DELAY_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_ADAPT_DELAY_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000474 bits 3:1) field ADAPT_DELAY of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_read( b_ptr,
                                                                      h_ptr,
                                                                      A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_ADAPT_DELAY_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_ADAPT_DELAY_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_ADAPT_DELAY_MSK, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_ADAPT_DELAY_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_ADAPT_DELAY_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_DSS_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                    s16_handle_t *h_ptr,
                                                    UINT32 A,
                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_DSS_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                    s16_handle_t *h_ptr,
                                                    UINT32 A,
                                                    UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_DSS_ENB_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_DSS_ENB_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_DSS_ENB_set", A, value );

    /* (0x00000474 bits 0) field DSS_ENB of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_field_set( b_ptr,
                                                               h_ptr,
                                                               A,
                                                               PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_DSS_ENB_MSK,
                                                               PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_DSS_ENB_OFF,
                                                               value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_DSS_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                      s16_handle_t *h_ptr,
                                                      UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_DSS_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                      s16_handle_t *h_ptr,
                                                      UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_DSS_ENB_get", A, 15);
    /* (0x00000474 bits 0) field DSS_ENB of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_1_read( b_ptr,
                                                                      h_ptr,
                                                                      A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_DSS_ENB_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_1_BIT_DSS_ENB_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_DSS_ENB_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PATH_PATTERN_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PATH_PATTERN_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PATH_PATTERN_ENB_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PATH_PATTERN_ENB_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PATH_PATTERN_ENB_set", A, value );

    /* (0x00000478 bits 29) field PATH_PATTERN_ENB of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_2_field_set( b_ptr,
                                                               h_ptr,
                                                               A,
                                                               PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_PATH_PATTERN_ENB_MSK,
                                                               PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_PATH_PATTERN_ENB_OFF,
                                                               value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PATH_PATTERN_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PATH_PATTERN_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PATH_PATTERN_ENB_get", A, 15);
    /* (0x00000478 bits 29) field PATH_PATTERN_ENB of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_2_read( b_ptr,
                                                                      h_ptr,
                                                                      A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_PATH_PATTERN_ENB_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_PATH_PATTERN_ENB_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PATH_PATTERN_ENB_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PRELOAD_ENB_P1_7_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PRELOAD_ENB_P1_7_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PRELOAD_ENB_P1_7_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PRELOAD_ENB_P1_7_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PRELOAD_ENB_P1_7_set", A, value );

    /* (0x00000478 bits 28) field PRELOAD_ENB_P1_7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_2_field_set( b_ptr,
                                                               h_ptr,
                                                               A,
                                                               PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_PRELOAD_ENB_P1_7_MSK,
                                                               PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_PRELOAD_ENB_P1_7_OFF,
                                                               value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PRELOAD_ENB_P1_7_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PRELOAD_ENB_P1_7_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PRELOAD_ENB_P1_7_get", A, 15);
    /* (0x00000478 bits 28) field PRELOAD_ENB_P1_7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_2_read( b_ptr,
                                                                      h_ptr,
                                                                      A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_PRELOAD_ENB_P1_7_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_PRELOAD_ENB_P1_7_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PRELOAD_ENB_P1_7_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PRELOAD_ENB_P0_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PRELOAD_ENB_P0_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A,
                                                           UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PRELOAD_ENB_P0_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PRELOAD_ENB_P0_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PRELOAD_ENB_P0_set", A, value );

    /* (0x00000478 bits 27) field PRELOAD_ENB_P0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_2_field_set( b_ptr,
                                                               h_ptr,
                                                               A,
                                                               PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_PRELOAD_ENB_P0_MSK,
                                                               PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_PRELOAD_ENB_P0_OFF,
                                                               value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PRELOAD_ENB_P0_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PRELOAD_ENB_P0_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PRELOAD_ENB_P0_get", A, 15);
    /* (0x00000478 bits 27) field PRELOAD_ENB_P0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_2_read( b_ptr,
                                                                      h_ptr,
                                                                      A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_PRELOAD_ENB_P0_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_PRELOAD_ENB_P0_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PRELOAD_ENB_P0_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_CLIP_RATE_THRESH_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_CLIP_RATE_THRESH_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_CLIP_RATE_THRESH_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_CLIP_RATE_THRESH_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_CLIP_RATE_THRESH_set", A, value );

    /* (0x00000478 bits 8:6) field CLIP_RATE_THRESH of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_2_field_set( b_ptr,
                                                               h_ptr,
                                                               A,
                                                               PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_CLIP_RATE_THRESH_MSK,
                                                               PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_CLIP_RATE_THRESH_OFF,
                                                               value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_CLIP_RATE_THRESH_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_CLIP_RATE_THRESH_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_CLIP_RATE_THRESH_get", A, 15);
    /* (0x00000478 bits 8:6) field CLIP_RATE_THRESH of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_2_read( b_ptr,
                                                                      h_ptr,
                                                                      A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_CLIP_RATE_THRESH_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_CLIP_RATE_THRESH_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_CLIP_RATE_THRESH_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_CLIP_RATE_THRESH_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_CLIP_RATE_THRESH_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_CLIP_RATE_THRESH_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_CLIP_RATE_THRESH_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_CLIP_RATE_THRESH_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_CLIP_RATE_THRESH_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000478 bits 8:6) field CLIP_RATE_THRESH of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000478 bits 8:6) field CLIP_RATE_THRESH of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_2_field_set( b_ptr,
                                                                   h_ptr,
                                                                   A,
                                                                   subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_CLIP_RATE_THRESH_OFF + subfield_offset),
                                                                   PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_CLIP_RATE_THRESH_OFF + subfield_offset,
                                                                   value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_CLIP_RATE_THRESH_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_CLIP_RATE_THRESH_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_CLIP_RATE_THRESH_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_CLIP_RATE_THRESH_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_CLIP_RATE_THRESH_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000478 bits 8:6) field CLIP_RATE_THRESH of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_2_read( b_ptr,
                                                                      h_ptr,
                                                                      A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_CLIP_RATE_THRESH_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_CLIP_RATE_THRESH_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_CLIP_RATE_THRESH_MSK, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_CLIP_RATE_THRESH_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_CLIP_RATE_THRESH_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_CLIP_RATE_AMP_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_CLIP_RATE_AMP_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A,
                                                          UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_CLIP_RATE_AMP_set", A, 15);
    if (value > 63)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_CLIP_RATE_AMP_set", value, 63);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_CLIP_RATE_AMP_set", A, value );

    /* (0x00000478 bits 5:0) field CLIP_RATE_AMP of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_2_field_set( b_ptr,
                                                               h_ptr,
                                                               A,
                                                               PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_CLIP_RATE_AMP_MSK,
                                                               PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_CLIP_RATE_AMP_OFF,
                                                               value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_CLIP_RATE_AMP_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_CLIP_RATE_AMP_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_CLIP_RATE_AMP_get", A, 15);
    /* (0x00000478 bits 5:0) field CLIP_RATE_AMP of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_2_read( b_ptr,
                                                                      h_ptr,
                                                                      A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_CLIP_RATE_AMP_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_CLIP_RATE_AMP_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_CLIP_RATE_AMP_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_CLIP_RATE_AMP_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit,
                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_CLIP_RATE_AMP_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A,
                                                                UINT32 start_bit,
                                                                UINT32 stop_bit,
                                                                UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_CLIP_RATE_AMP_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_CLIP_RATE_AMP_set", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_CLIP_RATE_AMP_set", stop_bit, 5 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_CLIP_RATE_AMP_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000478 bits 5:0) field CLIP_RATE_AMP of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 5) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 5;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000478 bits 5:0) field CLIP_RATE_AMP of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_2_field_set( b_ptr,
                                                                   h_ptr,
                                                                   A,
                                                                   subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_CLIP_RATE_AMP_OFF + subfield_offset),
                                                                   PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_CLIP_RATE_AMP_OFF + subfield_offset,
                                                                   value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_CLIP_RATE_AMP_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_CLIP_RATE_AMP_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_CLIP_RATE_AMP_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_CLIP_RATE_AMP_get", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_CLIP_RATE_AMP_get", stop_bit, 5 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 5) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 5;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000478 bits 5:0) field CLIP_RATE_AMP of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_2_read( b_ptr,
                                                                      h_ptr,
                                                                      A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_CLIP_RATE_AMP_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_CLIP_RATE_AMP_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_CLIP_RATE_AMP_MSK, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_2_BIT_CLIP_RATE_AMP_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_CLIP_RATE_AMP_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_TR_FFE_B_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_TR_FFE_B_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_TR_FFE_B_PRELOAD_set", A, 15);
    if (value > 31)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_TR_FFE_B_PRELOAD_set", value, 31);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_TR_FFE_B_PRELOAD_set", A, value );

    /* (0x0000047c bits 30:26) field TR_FFE_B_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_field_set( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_TR_FFE_B_PRELOAD_MSK,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_TR_FFE_B_PRELOAD_OFF,
                                                                  value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_TR_FFE_B_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_TR_FFE_B_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_TR_FFE_B_PRELOAD_get", A, 15);
    /* (0x0000047c bits 30:26) field TR_FFE_B_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_TR_FFE_B_PRELOAD_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_TR_FFE_B_PRELOAD_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_TR_FFE_B_PRELOAD_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_TR_FFE_B_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_TR_FFE_B_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_TR_FFE_B_PRELOAD_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_TR_FFE_B_PRELOAD_set", stop_bit, start_bit );
    if (stop_bit > 4) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_TR_FFE_B_PRELOAD_set", stop_bit, 4 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_TR_FFE_B_PRELOAD_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000047c bits 30:26) field TR_FFE_B_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 4) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 4;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000047c bits 30:26) field TR_FFE_B_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_TR_FFE_B_PRELOAD_OFF + subfield_offset),
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_TR_FFE_B_PRELOAD_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_TR_FFE_B_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_TR_FFE_B_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_TR_FFE_B_PRELOAD_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_TR_FFE_B_PRELOAD_get", stop_bit, start_bit );
    if (stop_bit > 4) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_TR_FFE_B_PRELOAD_get", stop_bit, 4 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 4) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 4;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000047c bits 30:26) field TR_FFE_B_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_TR_FFE_B_PRELOAD_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_TR_FFE_B_PRELOAD_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_TR_FFE_B_PRELOAD_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_TR_FFE_B_PRELOAD_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_TR_FFE_B_PRELOAD_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_TR_FFE_A_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_TR_FFE_A_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_TR_FFE_A_PRELOAD_set", A, 15);
    if (value > 31)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_TR_FFE_A_PRELOAD_set", value, 31);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_TR_FFE_A_PRELOAD_set", A, value );

    /* (0x0000047c bits 25:21) field TR_FFE_A_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_field_set( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_TR_FFE_A_PRELOAD_MSK,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_TR_FFE_A_PRELOAD_OFF,
                                                                  value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_TR_FFE_A_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_TR_FFE_A_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_TR_FFE_A_PRELOAD_get", A, 15);
    /* (0x0000047c bits 25:21) field TR_FFE_A_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_TR_FFE_A_PRELOAD_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_TR_FFE_A_PRELOAD_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_TR_FFE_A_PRELOAD_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_TR_FFE_A_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_TR_FFE_A_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_TR_FFE_A_PRELOAD_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_TR_FFE_A_PRELOAD_set", stop_bit, start_bit );
    if (stop_bit > 4) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_TR_FFE_A_PRELOAD_set", stop_bit, 4 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_TR_FFE_A_PRELOAD_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000047c bits 25:21) field TR_FFE_A_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 4) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 4;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000047c bits 25:21) field TR_FFE_A_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_TR_FFE_A_PRELOAD_OFF + subfield_offset),
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_TR_FFE_A_PRELOAD_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_TR_FFE_A_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_TR_FFE_A_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_TR_FFE_A_PRELOAD_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_TR_FFE_A_PRELOAD_get", stop_bit, start_bit );
    if (stop_bit > 4) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_TR_FFE_A_PRELOAD_get", stop_bit, 4 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 4) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 4;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000047c bits 25:21) field TR_FFE_A_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_TR_FFE_A_PRELOAD_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_TR_FFE_A_PRELOAD_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_TR_FFE_A_PRELOAD_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_TR_FFE_A_PRELOAD_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_TR_FFE_A_PRELOAD_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_DP_FFE_C_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_DP_FFE_C_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_DP_FFE_C_PRELOAD_set", A, 15);
    if (value > 127)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_DP_FFE_C_PRELOAD_set", value, 127);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_DP_FFE_C_PRELOAD_set", A, value );

    /* (0x0000047c bits 20:14) field DP_FFE_C_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_field_set( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_C_PRELOAD_MSK,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_C_PRELOAD_OFF,
                                                                  value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_DP_FFE_C_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_DP_FFE_C_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_DP_FFE_C_PRELOAD_get", A, 15);
    /* (0x0000047c bits 20:14) field DP_FFE_C_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_C_PRELOAD_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_C_PRELOAD_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_DP_FFE_C_PRELOAD_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_DP_FFE_C_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_DP_FFE_C_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_DP_FFE_C_PRELOAD_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_DP_FFE_C_PRELOAD_set", stop_bit, start_bit );
    if (stop_bit > 6) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_DP_FFE_C_PRELOAD_set", stop_bit, 6 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_DP_FFE_C_PRELOAD_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000047c bits 20:14) field DP_FFE_C_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 6) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 6;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000047c bits 20:14) field DP_FFE_C_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_C_PRELOAD_OFF + subfield_offset),
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_C_PRELOAD_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_DP_FFE_C_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_DP_FFE_C_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_DP_FFE_C_PRELOAD_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_DP_FFE_C_PRELOAD_get", stop_bit, start_bit );
    if (stop_bit > 6) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_DP_FFE_C_PRELOAD_get", stop_bit, 6 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 6) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 6;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000047c bits 20:14) field DP_FFE_C_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_C_PRELOAD_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_C_PRELOAD_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_C_PRELOAD_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_C_PRELOAD_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_DP_FFE_C_PRELOAD_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_DP_FFE_B_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_DP_FFE_B_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_DP_FFE_B_PRELOAD_set", A, 15);
    if (value > 127)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_DP_FFE_B_PRELOAD_set", value, 127);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_DP_FFE_B_PRELOAD_set", A, value );

    /* (0x0000047c bits 13:7) field DP_FFE_B_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_field_set( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_B_PRELOAD_MSK,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_B_PRELOAD_OFF,
                                                                  value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_DP_FFE_B_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_DP_FFE_B_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_DP_FFE_B_PRELOAD_get", A, 15);
    /* (0x0000047c bits 13:7) field DP_FFE_B_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_B_PRELOAD_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_B_PRELOAD_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_DP_FFE_B_PRELOAD_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_DP_FFE_B_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_DP_FFE_B_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_DP_FFE_B_PRELOAD_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_DP_FFE_B_PRELOAD_set", stop_bit, start_bit );
    if (stop_bit > 6) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_DP_FFE_B_PRELOAD_set", stop_bit, 6 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_DP_FFE_B_PRELOAD_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000047c bits 13:7) field DP_FFE_B_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 6) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 6;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000047c bits 13:7) field DP_FFE_B_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_B_PRELOAD_OFF + subfield_offset),
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_B_PRELOAD_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_DP_FFE_B_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_DP_FFE_B_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_DP_FFE_B_PRELOAD_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_DP_FFE_B_PRELOAD_get", stop_bit, start_bit );
    if (stop_bit > 6) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_DP_FFE_B_PRELOAD_get", stop_bit, 6 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 6) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 6;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000047c bits 13:7) field DP_FFE_B_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_B_PRELOAD_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_B_PRELOAD_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_B_PRELOAD_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_B_PRELOAD_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_DP_FFE_B_PRELOAD_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_DP_FFE_A_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_DP_FFE_A_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_DP_FFE_A_PRELOAD_set", A, 15);
    if (value > 127)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_DP_FFE_A_PRELOAD_set", value, 127);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_DP_FFE_A_PRELOAD_set", A, value );

    /* (0x0000047c bits 6:0) field DP_FFE_A_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_field_set( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_A_PRELOAD_MSK,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_A_PRELOAD_OFF,
                                                                  value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_DP_FFE_A_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_DP_FFE_A_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_DP_FFE_A_PRELOAD_get", A, 15);
    /* (0x0000047c bits 6:0) field DP_FFE_A_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_A_PRELOAD_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_A_PRELOAD_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_DP_FFE_A_PRELOAD_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_DP_FFE_A_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_DP_FFE_A_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_DP_FFE_A_PRELOAD_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_DP_FFE_A_PRELOAD_set", stop_bit, start_bit );
    if (stop_bit > 6) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_DP_FFE_A_PRELOAD_set", stop_bit, 6 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_DP_FFE_A_PRELOAD_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000047c bits 6:0) field DP_FFE_A_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 6) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 6;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000047c bits 6:0) field DP_FFE_A_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_A_PRELOAD_OFF + subfield_offset),
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_A_PRELOAD_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_DP_FFE_A_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_DP_FFE_A_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_DP_FFE_A_PRELOAD_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_DP_FFE_A_PRELOAD_get", stop_bit, start_bit );
    if (stop_bit > 6) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_DP_FFE_A_PRELOAD_get", stop_bit, 6 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 6) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 6;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000047c bits 6:0) field DP_FFE_A_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_A_PRELOAD_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_A_PRELOAD_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_A_PRELOAD_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_3_BIT_DP_FFE_A_PRELOAD_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_DP_FFE_A_PRELOAD_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PGA_OFFSET_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PGA_OFFSET_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PGA_OFFSET_PRELOAD_set", A, 15);
    if (value > 255)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PGA_OFFSET_PRELOAD_set", value, 255);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PGA_OFFSET_PRELOAD_set", A, value );

    /* (0x00000480 bits 25:18) field PGA_OFFSET_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_field_set( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_BIT_PGA_OFFSET_PRELOAD_MSK,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_BIT_PGA_OFFSET_PRELOAD_OFF,
                                                                  value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PGA_OFFSET_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PGA_OFFSET_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PGA_OFFSET_PRELOAD_get", A, 15);
    /* (0x00000480 bits 25:18) field PGA_OFFSET_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_BIT_PGA_OFFSET_PRELOAD_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_BIT_PGA_OFFSET_PRELOAD_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PGA_OFFSET_PRELOAD_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PGA_OFFSET_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PGA_OFFSET_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PGA_OFFSET_PRELOAD_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PGA_OFFSET_PRELOAD_set", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PGA_OFFSET_PRELOAD_set", stop_bit, 7 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PGA_OFFSET_PRELOAD_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000480 bits 25:18) field PGA_OFFSET_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 7) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 7;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000480 bits 25:18) field PGA_OFFSET_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_BIT_PGA_OFFSET_PRELOAD_OFF + subfield_offset),
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_BIT_PGA_OFFSET_PRELOAD_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PGA_OFFSET_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PGA_OFFSET_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PGA_OFFSET_PRELOAD_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PGA_OFFSET_PRELOAD_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PGA_OFFSET_PRELOAD_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000480 bits 25:18) field PGA_OFFSET_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_BIT_PGA_OFFSET_PRELOAD_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_BIT_PGA_OFFSET_PRELOAD_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_BIT_PGA_OFFSET_PRELOAD_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_BIT_PGA_OFFSET_PRELOAD_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PGA_OFFSET_PRELOAD_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_LMS_DATA_SEL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_LMS_DATA_SEL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A,
                                                         UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_LMS_DATA_SEL_set", A, 15);
    if (value > 262143)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_LMS_DATA_SEL_set", value, 262143);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_LMS_DATA_SEL_set", A, value );

    /* (0x00000480 bits 17:0) field LMS_DATA_SEL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_field_set( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_BIT_LMS_DATA_SEL_MSK,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_BIT_LMS_DATA_SEL_OFF,
                                                                  value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_LMS_DATA_SEL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_LMS_DATA_SEL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_LMS_DATA_SEL_get", A, 15);
    /* (0x00000480 bits 17:0) field LMS_DATA_SEL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_BIT_LMS_DATA_SEL_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_BIT_LMS_DATA_SEL_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_LMS_DATA_SEL_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_LMS_DATA_SEL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_LMS_DATA_SEL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 start_bit,
                                                               UINT32 stop_bit,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_LMS_DATA_SEL_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_LMS_DATA_SEL_set", stop_bit, start_bit );
    if (stop_bit > 17) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_LMS_DATA_SEL_set", stop_bit, 17 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_LMS_DATA_SEL_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000480 bits 17:0) field LMS_DATA_SEL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 17) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 17;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000480 bits 17:0) field LMS_DATA_SEL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_BIT_LMS_DATA_SEL_OFF + subfield_offset),
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_BIT_LMS_DATA_SEL_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_LMS_DATA_SEL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_LMS_DATA_SEL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_LMS_DATA_SEL_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_LMS_DATA_SEL_get", stop_bit, start_bit );
    if (stop_bit > 17) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_LMS_DATA_SEL_get", stop_bit, 17 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 17) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 17;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000480 bits 17:0) field LMS_DATA_SEL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_BIT_LMS_DATA_SEL_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_BIT_LMS_DATA_SEL_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_BIT_LMS_DATA_SEL_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_4_BIT_LMS_DATA_SEL_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_LMS_DATA_SEL_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_DFE_COEF2_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_DFE_COEF2_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_DFE_COEF2_PRELOAD_set", A, 15);
    if (value > 511)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_DFE_COEF2_PRELOAD_set", value, 511);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_DFE_COEF2_PRELOAD_set", A, value );

    /* (0x00000484 bits 26:18) field DFE_COEF2_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_field_set( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF2_PRELOAD_MSK,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF2_PRELOAD_OFF,
                                                                  value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_DFE_COEF2_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_DFE_COEF2_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_DFE_COEF2_PRELOAD_get", A, 15);
    /* (0x00000484 bits 26:18) field DFE_COEF2_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF2_PRELOAD_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF2_PRELOAD_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_DFE_COEF2_PRELOAD_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_DFE_COEF2_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_DFE_COEF2_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_DFE_COEF2_PRELOAD_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_DFE_COEF2_PRELOAD_set", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_DFE_COEF2_PRELOAD_set", stop_bit, 8 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_DFE_COEF2_PRELOAD_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000484 bits 26:18) field DFE_COEF2_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 8) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 8;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000484 bits 26:18) field DFE_COEF2_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF2_PRELOAD_OFF + subfield_offset),
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF2_PRELOAD_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_DFE_COEF2_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_DFE_COEF2_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_DFE_COEF2_PRELOAD_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_DFE_COEF2_PRELOAD_get", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_DFE_COEF2_PRELOAD_get", stop_bit, 8 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 8) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 8;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000484 bits 26:18) field DFE_COEF2_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF2_PRELOAD_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF2_PRELOAD_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF2_PRELOAD_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF2_PRELOAD_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_DFE_COEF2_PRELOAD_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_DFE_COEF1_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_DFE_COEF1_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_DFE_COEF1_PRELOAD_set", A, 15);
    if (value > 511)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_DFE_COEF1_PRELOAD_set", value, 511);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_DFE_COEF1_PRELOAD_set", A, value );

    /* (0x00000484 bits 17:9) field DFE_COEF1_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_field_set( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF1_PRELOAD_MSK,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF1_PRELOAD_OFF,
                                                                  value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_DFE_COEF1_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_DFE_COEF1_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_DFE_COEF1_PRELOAD_get", A, 15);
    /* (0x00000484 bits 17:9) field DFE_COEF1_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF1_PRELOAD_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF1_PRELOAD_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_DFE_COEF1_PRELOAD_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_DFE_COEF1_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_DFE_COEF1_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_DFE_COEF1_PRELOAD_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_DFE_COEF1_PRELOAD_set", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_DFE_COEF1_PRELOAD_set", stop_bit, 8 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_DFE_COEF1_PRELOAD_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000484 bits 17:9) field DFE_COEF1_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 8) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 8;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000484 bits 17:9) field DFE_COEF1_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF1_PRELOAD_OFF + subfield_offset),
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF1_PRELOAD_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_DFE_COEF1_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_DFE_COEF1_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_DFE_COEF1_PRELOAD_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_DFE_COEF1_PRELOAD_get", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_DFE_COEF1_PRELOAD_get", stop_bit, 8 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 8) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 8;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000484 bits 17:9) field DFE_COEF1_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF1_PRELOAD_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF1_PRELOAD_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF1_PRELOAD_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF1_PRELOAD_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_DFE_COEF1_PRELOAD_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_DFE_COEF0_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_DFE_COEF0_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_DFE_COEF0_PRELOAD_set", A, 15);
    if (value > 511)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_DFE_COEF0_PRELOAD_set", value, 511);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_DFE_COEF0_PRELOAD_set", A, value );

    /* (0x00000484 bits 8:0) field DFE_COEF0_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_field_set( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF0_PRELOAD_MSK,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF0_PRELOAD_OFF,
                                                                  value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_DFE_COEF0_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_DFE_COEF0_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_DFE_COEF0_PRELOAD_get", A, 15);
    /* (0x00000484 bits 8:0) field DFE_COEF0_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF0_PRELOAD_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF0_PRELOAD_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_DFE_COEF0_PRELOAD_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_DFE_COEF0_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_DFE_COEF0_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit,
                                                                    UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_DFE_COEF0_PRELOAD_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_DFE_COEF0_PRELOAD_set", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_DFE_COEF0_PRELOAD_set", stop_bit, 8 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_DFE_COEF0_PRELOAD_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000484 bits 8:0) field DFE_COEF0_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 8) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 8;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000484 bits 8:0) field DFE_COEF0_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF0_PRELOAD_OFF + subfield_offset),
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF0_PRELOAD_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_DFE_COEF0_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_DFE_COEF0_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_DFE_COEF0_PRELOAD_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_DFE_COEF0_PRELOAD_get", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_DFE_COEF0_PRELOAD_get", stop_bit, 8 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 8) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 8;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000484 bits 8:0) field DFE_COEF0_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF0_PRELOAD_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF0_PRELOAD_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF0_PRELOAD_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_5_BIT_DFE_COEF0_PRELOAD_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_DFE_COEF0_PRELOAD_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_OFL_DECAY_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                      s16_handle_t *h_ptr,
                                                      UINT32 A,
                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_OFL_DECAY_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                      s16_handle_t *h_ptr,
                                                      UINT32 A,
                                                      UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_OFL_DECAY_set", A, 15);
    if (value > 63)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_OFL_DECAY_set", value, 63);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_OFL_DECAY_set", A, value );

    /* (0x00000490 bits 9:4) field OFL_DECAY of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_field_set( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_BIT_OFL_DECAY_MSK,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_BIT_OFL_DECAY_OFF,
                                                                  value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_OFL_DECAY_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_OFL_DECAY_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_OFL_DECAY_get", A, 15);
    /* (0x00000490 bits 9:4) field OFL_DECAY of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_BIT_OFL_DECAY_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_BIT_OFL_DECAY_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_OFL_DECAY_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_OFL_DECAY_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_OFL_DECAY_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 start_bit,
                                                            UINT32 stop_bit,
                                                            UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_OFL_DECAY_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_OFL_DECAY_set", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_OFL_DECAY_set", stop_bit, 5 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_OFL_DECAY_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000490 bits 9:4) field OFL_DECAY of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 5) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 5;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000490 bits 9:4) field OFL_DECAY of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_BIT_OFL_DECAY_OFF + subfield_offset),
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_BIT_OFL_DECAY_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_OFL_DECAY_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_OFL_DECAY_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 start_bit,
                                                              UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_OFL_DECAY_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_OFL_DECAY_get", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_OFL_DECAY_get", stop_bit, 5 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 5) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 5;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000490 bits 9:4) field OFL_DECAY of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_BIT_OFL_DECAY_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_BIT_OFL_DECAY_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_BIT_OFL_DECAY_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_BIT_OFL_DECAY_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_OFL_DECAY_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADC_MAP_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADC_MAP_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADC_MAP_PRELOAD_set", A, 15);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADC_MAP_PRELOAD_set", value, 15);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADC_MAP_PRELOAD_set", A, value );

    /* (0x00000490 bits 3:0) field ADC_MAP_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_field_set( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_BIT_ADC_MAP_PRELOAD_MSK,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_BIT_ADC_MAP_PRELOAD_OFF,
                                                                  value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADC_MAP_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADC_MAP_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADC_MAP_PRELOAD_get", A, 15);
    /* (0x00000490 bits 3:0) field ADC_MAP_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_BIT_ADC_MAP_PRELOAD_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_BIT_ADC_MAP_PRELOAD_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADC_MAP_PRELOAD_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_ADC_MAP_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_ADC_MAP_PRELOAD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_ADC_MAP_PRELOAD_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_ADC_MAP_PRELOAD_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_ADC_MAP_PRELOAD_set", stop_bit, 3 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_ADC_MAP_PRELOAD_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000490 bits 3:0) field ADC_MAP_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000490 bits 3:0) field ADC_MAP_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_BIT_ADC_MAP_PRELOAD_OFF + subfield_offset),
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_BIT_ADC_MAP_PRELOAD_OFF + subfield_offset,
                                                                      value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_ADC_MAP_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_ADC_MAP_PRELOAD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_ADC_MAP_PRELOAD_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_ADC_MAP_PRELOAD_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_ADC_MAP_PRELOAD_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000490 bits 3:0) field ADC_MAP_PRELOAD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_BIT_ADC_MAP_PRELOAD_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_BIT_ADC_MAP_PRELOAD_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_BIT_ADC_MAP_PRELOAD_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADAPT_8_BIT_ADC_MAP_PRELOAD_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_ADC_MAP_PRELOAD_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_OBJECTS_EN_PASS0_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_OBJECTS_EN_PASS0_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS0_set", A, 15);
    if (value > 262143)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS0_set", value, 262143);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS0_set", A, value );

    /* (0x00000494 bits 17:0) field OBJECTS_EN_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_9 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_9_field_set( b_ptr,
                                                               h_ptr,
                                                               A,
                                                               PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_9_BIT_OBJECTS_EN_PASS0_MSK,
                                                               PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_9_BIT_OBJECTS_EN_PASS0_OFF,
                                                               value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_OBJECTS_EN_PASS0_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_OBJECTS_EN_PASS0_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS0_get", A, 15);
    /* (0x00000494 bits 17:0) field OBJECTS_EN_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_9 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_9_read( b_ptr,
                                                                      h_ptr,
                                                                      A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_9_BIT_OBJECTS_EN_PASS0_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_9_BIT_OBJECTS_EN_PASS0_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS0_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS0_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS0_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS0_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS0_set", stop_bit, start_bit );
    if (stop_bit > 17) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS0_set", stop_bit, 17 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS0_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000494 bits 17:0) field OBJECTS_EN_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_9 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 17) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 17;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000494 bits 17:0) field OBJECTS_EN_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_9 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_9_field_set( b_ptr,
                                                                   h_ptr,
                                                                   A,
                                                                   subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_9_BIT_OBJECTS_EN_PASS0_OFF + subfield_offset),
                                                                   PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_9_BIT_OBJECTS_EN_PASS0_OFF + subfield_offset,
                                                                   value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS0_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS0_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS0_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS0_get", stop_bit, start_bit );
    if (stop_bit > 17) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS0_get", stop_bit, 17 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 17) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 17;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000494 bits 17:0) field OBJECTS_EN_PASS0 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_9 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_9_read( b_ptr,
                                                                      h_ptr,
                                                                      A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_9_BIT_OBJECTS_EN_PASS0_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_9_BIT_OBJECTS_EN_PASS0_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_9_BIT_OBJECTS_EN_PASS0_MSK, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_9_BIT_OBJECTS_EN_PASS0_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS0_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_OBJECTS_EN_PASS1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_OBJECTS_EN_PASS1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS1_set", A, 15);
    if (value > 262143)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS1_set", value, 262143);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS1_set", A, value );

    /* (0x00000498 bits 17:0) field OBJECTS_EN_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_10 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_10_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_10_BIT_OBJECTS_EN_PASS1_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_10_BIT_OBJECTS_EN_PASS1_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_OBJECTS_EN_PASS1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_OBJECTS_EN_PASS1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS1_get", A, 15);
    /* (0x00000498 bits 17:0) field OBJECTS_EN_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_10 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_10_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_10_BIT_OBJECTS_EN_PASS1_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_10_BIT_OBJECTS_EN_PASS1_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS1_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS1_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS1_set", stop_bit, start_bit );
    if (stop_bit > 17) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS1_set", stop_bit, 17 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS1_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x00000498 bits 17:0) field OBJECTS_EN_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_10 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 17) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 17;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x00000498 bits 17:0) field OBJECTS_EN_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_10 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_10_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_10_BIT_OBJECTS_EN_PASS1_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_10_BIT_OBJECTS_EN_PASS1_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS1_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS1_get", stop_bit, start_bit );
    if (stop_bit > 17) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS1_get", stop_bit, 17 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 17) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 17;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000498 bits 17:0) field OBJECTS_EN_PASS1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_10 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_10_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_10_BIT_OBJECTS_EN_PASS1_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_10_BIT_OBJECTS_EN_PASS1_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_10_BIT_OBJECTS_EN_PASS1_MSK, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_10_BIT_OBJECTS_EN_PASS1_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS1_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_OBJECTS_EN_PASS2_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_OBJECTS_EN_PASS2_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS2_set", A, 15);
    if (value > 262143)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS2_set", value, 262143);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS2_set", A, value );

    /* (0x0000049c bits 17:0) field OBJECTS_EN_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_11 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_11_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_11_BIT_OBJECTS_EN_PASS2_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_11_BIT_OBJECTS_EN_PASS2_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_OBJECTS_EN_PASS2_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_OBJECTS_EN_PASS2_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS2_get", A, 15);
    /* (0x0000049c bits 17:0) field OBJECTS_EN_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_11 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_11_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_11_BIT_OBJECTS_EN_PASS2_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_11_BIT_OBJECTS_EN_PASS2_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS2_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS2_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS2_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS2_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS2_set", stop_bit, start_bit );
    if (stop_bit > 17) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS2_set", stop_bit, 17 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS2_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x0000049c bits 17:0) field OBJECTS_EN_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_11 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 17) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 17;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x0000049c bits 17:0) field OBJECTS_EN_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_11 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_11_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_11_BIT_OBJECTS_EN_PASS2_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_11_BIT_OBJECTS_EN_PASS2_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS2_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS2_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS2_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS2_get", stop_bit, start_bit );
    if (stop_bit > 17) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS2_get", stop_bit, 17 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 17) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 17;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000049c bits 17:0) field OBJECTS_EN_PASS2 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_11 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_11_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_11_BIT_OBJECTS_EN_PASS2_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_11_BIT_OBJECTS_EN_PASS2_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_11_BIT_OBJECTS_EN_PASS2_MSK, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_11_BIT_OBJECTS_EN_PASS2_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS2_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_OBJECTS_EN_PASS3_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_OBJECTS_EN_PASS3_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS3_set", A, 15);
    if (value > 262143)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS3_set", value, 262143);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS3_set", A, value );

    /* (0x000004a0 bits 17:0) field OBJECTS_EN_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_12 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_12_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_12_BIT_OBJECTS_EN_PASS3_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_12_BIT_OBJECTS_EN_PASS3_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_OBJECTS_EN_PASS3_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_OBJECTS_EN_PASS3_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS3_get", A, 15);
    /* (0x000004a0 bits 17:0) field OBJECTS_EN_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_12 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_12_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_12_BIT_OBJECTS_EN_PASS3_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_12_BIT_OBJECTS_EN_PASS3_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS3_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS3_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS3_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS3_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS3_set", stop_bit, start_bit );
    if (stop_bit > 17) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS3_set", stop_bit, 17 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS3_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004a0 bits 17:0) field OBJECTS_EN_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_12 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 17) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 17;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004a0 bits 17:0) field OBJECTS_EN_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_12 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_12_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_12_BIT_OBJECTS_EN_PASS3_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_12_BIT_OBJECTS_EN_PASS3_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS3_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS3_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS3_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS3_get", stop_bit, start_bit );
    if (stop_bit > 17) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS3_get", stop_bit, 17 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 17) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 17;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004a0 bits 17:0) field OBJECTS_EN_PASS3 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_12 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_12_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_12_BIT_OBJECTS_EN_PASS3_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_12_BIT_OBJECTS_EN_PASS3_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_12_BIT_OBJECTS_EN_PASS3_MSK, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_12_BIT_OBJECTS_EN_PASS3_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS3_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_OBJECTS_EN_PASS4_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_OBJECTS_EN_PASS4_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS4_set", A, 15);
    if (value > 262143)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS4_set", value, 262143);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS4_set", A, value );

    /* (0x000004a4 bits 17:0) field OBJECTS_EN_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_13 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_13_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_13_BIT_OBJECTS_EN_PASS4_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_13_BIT_OBJECTS_EN_PASS4_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_OBJECTS_EN_PASS4_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_OBJECTS_EN_PASS4_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS4_get", A, 15);
    /* (0x000004a4 bits 17:0) field OBJECTS_EN_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_13 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_13_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_13_BIT_OBJECTS_EN_PASS4_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_13_BIT_OBJECTS_EN_PASS4_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS4_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS4_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS4_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS4_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS4_set", stop_bit, start_bit );
    if (stop_bit > 17) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS4_set", stop_bit, 17 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS4_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004a4 bits 17:0) field OBJECTS_EN_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_13 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 17) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 17;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004a4 bits 17:0) field OBJECTS_EN_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_13 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_13_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_13_BIT_OBJECTS_EN_PASS4_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_13_BIT_OBJECTS_EN_PASS4_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS4_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS4_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS4_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS4_get", stop_bit, start_bit );
    if (stop_bit > 17) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS4_get", stop_bit, 17 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 17) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 17;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004a4 bits 17:0) field OBJECTS_EN_PASS4 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_13 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_13_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_13_BIT_OBJECTS_EN_PASS4_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_13_BIT_OBJECTS_EN_PASS4_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_13_BIT_OBJECTS_EN_PASS4_MSK, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_13_BIT_OBJECTS_EN_PASS4_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS4_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_OBJECTS_EN_PASS5_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_OBJECTS_EN_PASS5_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS5_set", A, 15);
    if (value > 262143)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS5_set", value, 262143);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS5_set", A, value );

    /* (0x000004a8 bits 17:0) field OBJECTS_EN_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_14 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_14_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_14_BIT_OBJECTS_EN_PASS5_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_14_BIT_OBJECTS_EN_PASS5_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_OBJECTS_EN_PASS5_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_OBJECTS_EN_PASS5_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS5_get", A, 15);
    /* (0x000004a8 bits 17:0) field OBJECTS_EN_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_14 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_14_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_14_BIT_OBJECTS_EN_PASS5_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_14_BIT_OBJECTS_EN_PASS5_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS5_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS5_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS5_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS5_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS5_set", stop_bit, start_bit );
    if (stop_bit > 17) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS5_set", stop_bit, 17 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS5_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004a8 bits 17:0) field OBJECTS_EN_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_14 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 17) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 17;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004a8 bits 17:0) field OBJECTS_EN_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_14 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_14_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_14_BIT_OBJECTS_EN_PASS5_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_14_BIT_OBJECTS_EN_PASS5_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS5_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS5_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS5_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS5_get", stop_bit, start_bit );
    if (stop_bit > 17) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS5_get", stop_bit, 17 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 17) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 17;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004a8 bits 17:0) field OBJECTS_EN_PASS5 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_14 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_14_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_14_BIT_OBJECTS_EN_PASS5_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_14_BIT_OBJECTS_EN_PASS5_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_14_BIT_OBJECTS_EN_PASS5_MSK, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_14_BIT_OBJECTS_EN_PASS5_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS5_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_OBJECTS_EN_PASS6_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_OBJECTS_EN_PASS6_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS6_set", A, 15);
    if (value > 262143)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS6_set", value, 262143);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS6_set", A, value );

    /* (0x000004ac bits 17:0) field OBJECTS_EN_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_15 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_15_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_15_BIT_OBJECTS_EN_PASS6_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_15_BIT_OBJECTS_EN_PASS6_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_OBJECTS_EN_PASS6_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_OBJECTS_EN_PASS6_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS6_get", A, 15);
    /* (0x000004ac bits 17:0) field OBJECTS_EN_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_15 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_15_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_15_BIT_OBJECTS_EN_PASS6_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_15_BIT_OBJECTS_EN_PASS6_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS6_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS6_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS6_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS6_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS6_set", stop_bit, start_bit );
    if (stop_bit > 17) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS6_set", stop_bit, 17 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS6_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004ac bits 17:0) field OBJECTS_EN_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_15 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 17) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 17;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004ac bits 17:0) field OBJECTS_EN_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_15 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_15_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_15_BIT_OBJECTS_EN_PASS6_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_15_BIT_OBJECTS_EN_PASS6_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS6_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS6_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS6_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS6_get", stop_bit, start_bit );
    if (stop_bit > 17) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS6_get", stop_bit, 17 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 17) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 17;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004ac bits 17:0) field OBJECTS_EN_PASS6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_15 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_15_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_15_BIT_OBJECTS_EN_PASS6_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_15_BIT_OBJECTS_EN_PASS6_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_15_BIT_OBJECTS_EN_PASS6_MSK, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_15_BIT_OBJECTS_EN_PASS6_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS6_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_OBJECTS_EN_PASS7_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_OBJECTS_EN_PASS7_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS7_set", A, 15);
    if (value > 262143)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS7_set", value, 262143);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS7_set", A, value );

    /* (0x000004b0 bits 17:0) field OBJECTS_EN_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_16 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_16_field_set( b_ptr,
                                                                h_ptr,
                                                                A,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_16_BIT_OBJECTS_EN_PASS7_MSK,
                                                                PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_16_BIT_OBJECTS_EN_PASS7_OFF,
                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_OBJECTS_EN_PASS7_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_OBJECTS_EN_PASS7_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS7_get", A, 15);
    /* (0x000004b0 bits 17:0) field OBJECTS_EN_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_16 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_16_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_16_BIT_OBJECTS_EN_PASS7_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_16_BIT_OBJECTS_EN_PASS7_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_OBJECTS_EN_PASS7_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS7_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS7_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit,
                                                                   UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS7_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS7_set", stop_bit, start_bit );
    if (stop_bit > 17) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS7_set", stop_bit, 17 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS7_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004b0 bits 17:0) field OBJECTS_EN_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_16 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 17) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 17;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004b0 bits 17:0) field OBJECTS_EN_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_16 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_16_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_16_BIT_OBJECTS_EN_PASS7_OFF + subfield_offset),
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_16_BIT_OBJECTS_EN_PASS7_OFF + subfield_offset,
                                                                    value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS7_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS7_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS7_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS7_get", stop_bit, start_bit );
    if (stop_bit > 17) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS7_get", stop_bit, 17 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 17) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 17;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004b0 bits 17:0) field OBJECTS_EN_PASS7 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_16 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_ADAPT_CFG_16_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_16_BIT_OBJECTS_EN_PASS7_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_16_BIT_OBJECTS_EN_PASS7_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_16_BIT_OBJECTS_EN_PASS7_MSK, PCBI_REG_DIGI120_MTSB_CTRL_ADAPT_CFG_16_BIT_OBJECTS_EN_PASS7_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_OBJECTS_EN_PASS7_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PGA_LUT_PEAK_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PGA_LUT_PEAK_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PGA_LUT_PEAK_EN_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PGA_LUT_PEAK_EN_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PGA_LUT_PEAK_EN_set", A, value );

    /* (0x000004b8 bits 29) field PGA_LUT_PEAK_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_field_set( b_ptr,
                                                                     h_ptr,
                                                                     A,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_PEAK_EN_MSK,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_PEAK_EN_OFF,
                                                                     value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PGA_LUT_PEAK_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PGA_LUT_PEAK_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PGA_LUT_PEAK_EN_get", A, 15);
    /* (0x000004b8 bits 29) field PGA_LUT_PEAK_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_PEAK_EN_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_PEAK_EN_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PGA_LUT_PEAK_EN_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PGA_LUT_ADDRESS_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PGA_LUT_ADDRESS_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PGA_LUT_ADDRESS_set", A, 15);
    if (value > 31)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PGA_LUT_ADDRESS_set", value, 31);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PGA_LUT_ADDRESS_set", A, value );

    /* (0x000004b8 bits 28:24) field PGA_LUT_ADDRESS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_field_set( b_ptr,
                                                                     h_ptr,
                                                                     A,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_ADDRESS_MSK,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_ADDRESS_OFF,
                                                                     value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PGA_LUT_ADDRESS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PGA_LUT_ADDRESS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PGA_LUT_ADDRESS_get", A, 15);
    /* (0x000004b8 bits 28:24) field PGA_LUT_ADDRESS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_ADDRESS_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_ADDRESS_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PGA_LUT_ADDRESS_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PGA_LUT_ADDRESS_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PGA_LUT_ADDRESS_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PGA_LUT_ADDRESS_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PGA_LUT_ADDRESS_set", stop_bit, start_bit );
    if (stop_bit > 4) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PGA_LUT_ADDRESS_set", stop_bit, 4 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PGA_LUT_ADDRESS_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004b8 bits 28:24) field PGA_LUT_ADDRESS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 4) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 4;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004b8 bits 28:24) field PGA_LUT_ADDRESS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_field_set( b_ptr,
                                                                         h_ptr,
                                                                         A,
                                                                         subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_ADDRESS_OFF + subfield_offset),
                                                                         PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_ADDRESS_OFF + subfield_offset,
                                                                         value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PGA_LUT_ADDRESS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PGA_LUT_ADDRESS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PGA_LUT_ADDRESS_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PGA_LUT_ADDRESS_get", stop_bit, start_bit );
    if (stop_bit > 4) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PGA_LUT_ADDRESS_get", stop_bit, 4 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 4) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 4;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004b8 bits 28:24) field PGA_LUT_ADDRESS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_ADDRESS_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_ADDRESS_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_ADDRESS_MSK, PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_ADDRESS_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PGA_LUT_ADDRESS_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PGA_LUT_WR_DATA_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PGA_LUT_WR_DATA_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PGA_LUT_WR_DATA_set", A, 15);
    if (value > 2097151)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PGA_LUT_WR_DATA_set", value, 2097151);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PGA_LUT_WR_DATA_set", A, value );

    /* (0x000004b8 bits 20:0) field PGA_LUT_WR_DATA of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_field_set( b_ptr,
                                                                     h_ptr,
                                                                     A,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_WR_DATA_MSK,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_WR_DATA_OFF,
                                                                     value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PGA_LUT_WR_DATA_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PGA_LUT_WR_DATA_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PGA_LUT_WR_DATA_get", A, 15);
    /* (0x000004b8 bits 20:0) field PGA_LUT_WR_DATA of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_WR_DATA_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_WR_DATA_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PGA_LUT_WR_DATA_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PGA_LUT_WR_DATA_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PGA_LUT_WR_DATA_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PGA_LUT_WR_DATA_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PGA_LUT_WR_DATA_set", stop_bit, start_bit );
    if (stop_bit > 20) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PGA_LUT_WR_DATA_set", stop_bit, 20 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PGA_LUT_WR_DATA_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004b8 bits 20:0) field PGA_LUT_WR_DATA of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 20) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 20;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004b8 bits 20:0) field PGA_LUT_WR_DATA of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_field_set( b_ptr,
                                                                         h_ptr,
                                                                         A,
                                                                         subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_WR_DATA_OFF + subfield_offset),
                                                                         PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_WR_DATA_OFF + subfield_offset,
                                                                         value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PGA_LUT_WR_DATA_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PGA_LUT_WR_DATA_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PGA_LUT_WR_DATA_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PGA_LUT_WR_DATA_get", stop_bit, start_bit );
    if (stop_bit > 20) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PGA_LUT_WR_DATA_get", stop_bit, 20 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 20) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 20;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004b8 bits 20:0) field PGA_LUT_WR_DATA of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_WR_DATA_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_WR_DATA_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_WR_DATA_MSK, PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_WR_DATA_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PGA_LUT_WR_DATA_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PI_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                   s16_handle_t *h_ptr,
                                                   UINT32 A,
                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PI_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                   s16_handle_t *h_ptr,
                                                   UINT32 A,
                                                   UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PI_ENB_set", A, 15);
    if (value > 15)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PI_ENB_set", value, 15);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PI_ENB_set", A, value );

    /* (0x000004c0 bits 3:0) field PI_ENB of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2_field_set( b_ptr,
                                                                    h_ptr,
                                                                    A,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2_BIT_PI_ENB_MSK,
                                                                    PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2_BIT_PI_ENB_OFF,
                                                                    value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PI_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                     s16_handle_t *h_ptr,
                                                     UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PI_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                     s16_handle_t *h_ptr,
                                                     UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PI_ENB_get", A, 15);
    /* (0x000004c0 bits 3:0) field PI_ENB of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2_BIT_PI_ENB_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2_BIT_PI_ENB_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PI_ENB_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PI_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PI_ENB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A,
                                                         UINT32 start_bit,
                                                         UINT32 stop_bit,
                                                         UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PI_ENB_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PI_ENB_set", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PI_ENB_set", stop_bit, 3 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PI_ENB_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004c0 bits 3:0) field PI_ENB of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 3) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 3;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004c0 bits 3:0) field PI_ENB of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2_field_set( b_ptr,
                                                                        h_ptr,
                                                                        A,
                                                                        subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2_BIT_PI_ENB_OFF + subfield_offset),
                                                                        PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2_BIT_PI_ENB_OFF + subfield_offset,
                                                                        value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PI_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PI_ENB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A,
                                                           UINT32 start_bit,
                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PI_ENB_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PI_ENB_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PI_ENB_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004c0 bits 3:0) field PI_ENB of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2_BIT_PI_ENB_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2_BIT_PI_ENB_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2_BIT_PI_ENB_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_ADC_CFG_2_BIT_PI_ENB_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PI_ENB_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_TIMER_VALUE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_TIMER_VALUE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_TIMER_VALUE_set", A, 15);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_TIMER_VALUE_set", A, value );

    /* (0x000004c4 bits 31:0) field PHGEN_REGV_TIMER_VALUE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1_BIT_PHGEN_REGV_TIMER_VALUE_MSK,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1_BIT_PHGEN_REGV_TIMER_VALUE_OFF,
                                                                      value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_TIMER_VALUE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_TIMER_VALUE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_TIMER_VALUE_get", A, 15);
    /* (0x000004c4 bits 31:0) field PHGEN_REGV_TIMER_VALUE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1_BIT_PHGEN_REGV_TIMER_VALUE_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1_BIT_PHGEN_REGV_TIMER_VALUE_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_TIMER_VALUE_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_REGV_TIMER_VALUE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit,
                                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_REGV_TIMER_VALUE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit,
                                                                         UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_TIMER_VALUE_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_TIMER_VALUE_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_TIMER_VALUE_set", stop_bit, 31 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_REGV_TIMER_VALUE_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004c4 bits 31:0) field PHGEN_REGV_TIMER_VALUE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004c4 bits 31:0) field PHGEN_REGV_TIMER_VALUE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1_field_set( b_ptr,
                                                                          h_ptr,
                                                                          A,
                                                                          subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1_BIT_PHGEN_REGV_TIMER_VALUE_OFF + subfield_offset),
                                                                          PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1_BIT_PHGEN_REGV_TIMER_VALUE_OFF + subfield_offset,
                                                                          value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_REGV_TIMER_VALUE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_REGV_TIMER_VALUE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_TIMER_VALUE_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_TIMER_VALUE_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_TIMER_VALUE_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004c4 bits 31:0) field PHGEN_REGV_TIMER_VALUE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1_BIT_PHGEN_REGV_TIMER_VALUE_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1_BIT_PHGEN_REGV_TIMER_VALUE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1_BIT_PHGEN_REGV_TIMER_VALUE_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_1_BIT_PHGEN_REGV_TIMER_VALUE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_REGV_TIMER_VALUE_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_INVERT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_INVERT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_INVERT_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_INVERT_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_INVERT_set", A, value );

    /* (0x000004c8 bits 24) field PHGEN_REGV_INVERT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_BIT_PHGEN_REGV_INVERT_MSK,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_BIT_PHGEN_REGV_INVERT_OFF,
                                                                      value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_INVERT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_INVERT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_INVERT_get", A, 15);
    /* (0x000004c8 bits 24) field PHGEN_REGV_INVERT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_BIT_PHGEN_REGV_INVERT_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_BIT_PHGEN_REGV_INVERT_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_INVERT_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_TOLERANCE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_TOLERANCE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_TOLERANCE_set", A, 15);
    if (value > 255)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_TOLERANCE_set", value, 255);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_TOLERANCE_set", A, value );

    /* (0x000004c8 bits 23:16) field PHGEN_REGV_TOLERANCE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_BIT_PHGEN_REGV_TOLERANCE_MSK,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_BIT_PHGEN_REGV_TOLERANCE_OFF,
                                                                      value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_TOLERANCE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_TOLERANCE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_TOLERANCE_get", A, 15);
    /* (0x000004c8 bits 23:16) field PHGEN_REGV_TOLERANCE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_BIT_PHGEN_REGV_TOLERANCE_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_BIT_PHGEN_REGV_TOLERANCE_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_TOLERANCE_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_REGV_TOLERANCE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit,
                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_REGV_TOLERANCE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit,
                                                                       UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_TOLERANCE_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_TOLERANCE_set", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_TOLERANCE_set", stop_bit, 7 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_REGV_TOLERANCE_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004c8 bits 23:16) field PHGEN_REGV_TOLERANCE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 7) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 7;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004c8 bits 23:16) field PHGEN_REGV_TOLERANCE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_field_set( b_ptr,
                                                                          h_ptr,
                                                                          A,
                                                                          subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_BIT_PHGEN_REGV_TOLERANCE_OFF + subfield_offset),
                                                                          PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_BIT_PHGEN_REGV_TOLERANCE_OFF + subfield_offset,
                                                                          value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_REGV_TOLERANCE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_REGV_TOLERANCE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_TOLERANCE_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_TOLERANCE_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_TOLERANCE_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004c8 bits 23:16) field PHGEN_REGV_TOLERANCE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_BIT_PHGEN_REGV_TOLERANCE_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_BIT_PHGEN_REGV_TOLERANCE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_BIT_PHGEN_REGV_TOLERANCE_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_BIT_PHGEN_REGV_TOLERANCE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_REGV_TOLERANCE_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_WINDOW_SIZE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_WINDOW_SIZE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_WINDOW_SIZE_set", A, 15);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_WINDOW_SIZE_set", value, 65535);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_WINDOW_SIZE_set", A, value );

    /* (0x000004c8 bits 15:0) field PHGEN_REGV_WINDOW_SIZE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_BIT_PHGEN_REGV_WINDOW_SIZE_MSK,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_BIT_PHGEN_REGV_WINDOW_SIZE_OFF,
                                                                      value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_WINDOW_SIZE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_WINDOW_SIZE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_WINDOW_SIZE_get", A, 15);
    /* (0x000004c8 bits 15:0) field PHGEN_REGV_WINDOW_SIZE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_BIT_PHGEN_REGV_WINDOW_SIZE_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_BIT_PHGEN_REGV_WINDOW_SIZE_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_WINDOW_SIZE_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_REGV_WINDOW_SIZE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit,
                                                                         UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_REGV_WINDOW_SIZE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit,
                                                                         UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_WINDOW_SIZE_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_WINDOW_SIZE_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_WINDOW_SIZE_set", stop_bit, 15 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_REGV_WINDOW_SIZE_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004c8 bits 15:0) field PHGEN_REGV_WINDOW_SIZE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004c8 bits 15:0) field PHGEN_REGV_WINDOW_SIZE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_field_set( b_ptr,
                                                                          h_ptr,
                                                                          A,
                                                                          subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_BIT_PHGEN_REGV_WINDOW_SIZE_OFF + subfield_offset),
                                                                          PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_BIT_PHGEN_REGV_WINDOW_SIZE_OFF + subfield_offset,
                                                                          value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_REGV_WINDOW_SIZE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_REGV_WINDOW_SIZE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A,
                                                                           UINT32 start_bit,
                                                                           UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_WINDOW_SIZE_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_WINDOW_SIZE_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_WINDOW_SIZE_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004c8 bits 15:0) field PHGEN_REGV_WINDOW_SIZE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_BIT_PHGEN_REGV_WINDOW_SIZE_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_BIT_PHGEN_REGV_WINDOW_SIZE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_BIT_PHGEN_REGV_WINDOW_SIZE_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_2_BIT_PHGEN_REGV_WINDOW_SIZE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_REGV_WINDOW_SIZE_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_FT_START_VAL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_FT_START_VAL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_FT_START_VAL_set", A, 15);
    if (value > 511)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_FT_START_VAL_set", value, 511);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_FT_START_VAL_set", A, value );

    /* (0x000004cc bits 26:18) field PHGEN_REGV_FT_START_VAL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_FT_START_VAL_MSK,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_FT_START_VAL_OFF,
                                                                      value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_FT_START_VAL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_FT_START_VAL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_FT_START_VAL_get", A, 15);
    /* (0x000004cc bits 26:18) field PHGEN_REGV_FT_START_VAL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_FT_START_VAL_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_FT_START_VAL_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_FT_START_VAL_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_REGV_FT_START_VAL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_REGV_FT_START_VAL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_FT_START_VAL_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_FT_START_VAL_set", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_FT_START_VAL_set", stop_bit, 8 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_REGV_FT_START_VAL_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004cc bits 26:18) field PHGEN_REGV_FT_START_VAL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 8) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 8;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004cc bits 26:18) field PHGEN_REGV_FT_START_VAL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_field_set( b_ptr,
                                                                          h_ptr,
                                                                          A,
                                                                          subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_FT_START_VAL_OFF + subfield_offset),
                                                                          PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_FT_START_VAL_OFF + subfield_offset,
                                                                          value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_REGV_FT_START_VAL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A,
                                                                            UINT32 start_bit,
                                                                            UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_REGV_FT_START_VAL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A,
                                                                            UINT32 start_bit,
                                                                            UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_FT_START_VAL_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_FT_START_VAL_get", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_FT_START_VAL_get", stop_bit, 8 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 8) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 8;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004cc bits 26:18) field PHGEN_REGV_FT_START_VAL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_FT_START_VAL_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_FT_START_VAL_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_FT_START_VAL_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_FT_START_VAL_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_REGV_FT_START_VAL_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_HARD_MAX_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_HARD_MAX_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_HARD_MAX_LIMIT_set", A, 15);
    if (value > 511)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_HARD_MAX_LIMIT_set", value, 511);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_HARD_MAX_LIMIT_set", A, value );

    /* (0x000004cc bits 17:9) field PHGEN_REGV_HARD_MAX_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_HARD_MAX_LIMIT_MSK,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_HARD_MAX_LIMIT_OFF,
                                                                      value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_HARD_MAX_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_HARD_MAX_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_HARD_MAX_LIMIT_get", A, 15);
    /* (0x000004cc bits 17:9) field PHGEN_REGV_HARD_MAX_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_HARD_MAX_LIMIT_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_HARD_MAX_LIMIT_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_HARD_MAX_LIMIT_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_REGV_HARD_MAX_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A,
                                                                            UINT32 start_bit,
                                                                            UINT32 stop_bit,
                                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_REGV_HARD_MAX_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A,
                                                                            UINT32 start_bit,
                                                                            UINT32 stop_bit,
                                                                            UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_HARD_MAX_LIMIT_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_HARD_MAX_LIMIT_set", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_HARD_MAX_LIMIT_set", stop_bit, 8 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_REGV_HARD_MAX_LIMIT_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004cc bits 17:9) field PHGEN_REGV_HARD_MAX_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 8) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 8;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004cc bits 17:9) field PHGEN_REGV_HARD_MAX_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_field_set( b_ptr,
                                                                          h_ptr,
                                                                          A,
                                                                          subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_HARD_MAX_LIMIT_OFF + subfield_offset),
                                                                          PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_HARD_MAX_LIMIT_OFF + subfield_offset,
                                                                          value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_REGV_HARD_MAX_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A,
                                                                              UINT32 start_bit,
                                                                              UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_REGV_HARD_MAX_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A,
                                                                              UINT32 start_bit,
                                                                              UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_HARD_MAX_LIMIT_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_HARD_MAX_LIMIT_get", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_HARD_MAX_LIMIT_get", stop_bit, 8 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 8) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 8;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004cc bits 17:9) field PHGEN_REGV_HARD_MAX_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_HARD_MAX_LIMIT_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_HARD_MAX_LIMIT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_HARD_MAX_LIMIT_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_HARD_MAX_LIMIT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_REGV_HARD_MAX_LIMIT_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_SOFT_MAX_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_SOFT_MAX_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_SOFT_MAX_LIMIT_set", A, 15);
    if (value > 511)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_SOFT_MAX_LIMIT_set", value, 511);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_SOFT_MAX_LIMIT_set", A, value );

    /* (0x000004cc bits 8:0) field PHGEN_REGV_SOFT_MAX_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_SOFT_MAX_LIMIT_MSK,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_SOFT_MAX_LIMIT_OFF,
                                                                      value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_SOFT_MAX_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_SOFT_MAX_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_SOFT_MAX_LIMIT_get", A, 15);
    /* (0x000004cc bits 8:0) field PHGEN_REGV_SOFT_MAX_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_SOFT_MAX_LIMIT_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_SOFT_MAX_LIMIT_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_SOFT_MAX_LIMIT_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_REGV_SOFT_MAX_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A,
                                                                            UINT32 start_bit,
                                                                            UINT32 stop_bit,
                                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_REGV_SOFT_MAX_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A,
                                                                            UINT32 start_bit,
                                                                            UINT32 stop_bit,
                                                                            UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_SOFT_MAX_LIMIT_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_SOFT_MAX_LIMIT_set", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_SOFT_MAX_LIMIT_set", stop_bit, 8 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_REGV_SOFT_MAX_LIMIT_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004cc bits 8:0) field PHGEN_REGV_SOFT_MAX_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 8) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 8;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004cc bits 8:0) field PHGEN_REGV_SOFT_MAX_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_field_set( b_ptr,
                                                                          h_ptr,
                                                                          A,
                                                                          subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_SOFT_MAX_LIMIT_OFF + subfield_offset),
                                                                          PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_SOFT_MAX_LIMIT_OFF + subfield_offset,
                                                                          value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_REGV_SOFT_MAX_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A,
                                                                              UINT32 start_bit,
                                                                              UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_REGV_SOFT_MAX_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A,
                                                                              UINT32 start_bit,
                                                                              UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_SOFT_MAX_LIMIT_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_SOFT_MAX_LIMIT_get", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_SOFT_MAX_LIMIT_get", stop_bit, 8 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 8) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 8;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004cc bits 8:0) field PHGEN_REGV_SOFT_MAX_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_SOFT_MAX_LIMIT_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_SOFT_MAX_LIMIT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_SOFT_MAX_LIMIT_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_3_BIT_PHGEN_REGV_SOFT_MAX_LIMIT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_REGV_SOFT_MAX_LIMIT_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_OFFSET_VAL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_OFFSET_VAL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_OFFSET_VAL_set", A, 15);
    if (value > 511)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_OFFSET_VAL_set", value, 511);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_OFFSET_VAL_set", A, value );

    /* (0x000004d0 bits 26:18) field PHGEN_REGV_OFFSET_VAL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_OFFSET_VAL_MSK,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_OFFSET_VAL_OFF,
                                                                      value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_OFFSET_VAL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_OFFSET_VAL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_OFFSET_VAL_get", A, 15);
    /* (0x000004d0 bits 26:18) field PHGEN_REGV_OFFSET_VAL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_OFFSET_VAL_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_OFFSET_VAL_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_OFFSET_VAL_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_REGV_OFFSET_VAL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit,
                                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_REGV_OFFSET_VAL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit,
                                                                        UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_OFFSET_VAL_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_OFFSET_VAL_set", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_OFFSET_VAL_set", stop_bit, 8 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_REGV_OFFSET_VAL_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004d0 bits 26:18) field PHGEN_REGV_OFFSET_VAL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 8) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 8;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004d0 bits 26:18) field PHGEN_REGV_OFFSET_VAL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_field_set( b_ptr,
                                                                          h_ptr,
                                                                          A,
                                                                          subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_OFFSET_VAL_OFF + subfield_offset),
                                                                          PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_OFFSET_VAL_OFF + subfield_offset,
                                                                          value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_REGV_OFFSET_VAL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_REGV_OFFSET_VAL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_OFFSET_VAL_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_OFFSET_VAL_get", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_OFFSET_VAL_get", stop_bit, 8 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 8) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 8;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004d0 bits 26:18) field PHGEN_REGV_OFFSET_VAL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_OFFSET_VAL_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_OFFSET_VAL_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_OFFSET_VAL_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_OFFSET_VAL_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_REGV_OFFSET_VAL_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_HARD_MIN_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_HARD_MIN_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_HARD_MIN_LIMIT_set", A, 15);
    if (value > 511)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_HARD_MIN_LIMIT_set", value, 511);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_HARD_MIN_LIMIT_set", A, value );

    /* (0x000004d0 bits 17:9) field PHGEN_REGV_HARD_MIN_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_HARD_MIN_LIMIT_MSK,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_HARD_MIN_LIMIT_OFF,
                                                                      value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_HARD_MIN_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_HARD_MIN_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_HARD_MIN_LIMIT_get", A, 15);
    /* (0x000004d0 bits 17:9) field PHGEN_REGV_HARD_MIN_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_HARD_MIN_LIMIT_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_HARD_MIN_LIMIT_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_HARD_MIN_LIMIT_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_REGV_HARD_MIN_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A,
                                                                            UINT32 start_bit,
                                                                            UINT32 stop_bit,
                                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_REGV_HARD_MIN_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A,
                                                                            UINT32 start_bit,
                                                                            UINT32 stop_bit,
                                                                            UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_HARD_MIN_LIMIT_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_HARD_MIN_LIMIT_set", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_HARD_MIN_LIMIT_set", stop_bit, 8 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_REGV_HARD_MIN_LIMIT_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004d0 bits 17:9) field PHGEN_REGV_HARD_MIN_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 8) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 8;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004d0 bits 17:9) field PHGEN_REGV_HARD_MIN_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_field_set( b_ptr,
                                                                          h_ptr,
                                                                          A,
                                                                          subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_HARD_MIN_LIMIT_OFF + subfield_offset),
                                                                          PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_HARD_MIN_LIMIT_OFF + subfield_offset,
                                                                          value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_REGV_HARD_MIN_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A,
                                                                              UINT32 start_bit,
                                                                              UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_REGV_HARD_MIN_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A,
                                                                              UINT32 start_bit,
                                                                              UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_HARD_MIN_LIMIT_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_HARD_MIN_LIMIT_get", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_HARD_MIN_LIMIT_get", stop_bit, 8 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 8) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 8;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004d0 bits 17:9) field PHGEN_REGV_HARD_MIN_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_HARD_MIN_LIMIT_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_HARD_MIN_LIMIT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_HARD_MIN_LIMIT_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_HARD_MIN_LIMIT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_REGV_HARD_MIN_LIMIT_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_SOFT_MIN_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_SOFT_MIN_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_SOFT_MIN_LIMIT_set", A, 15);
    if (value > 511)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_SOFT_MIN_LIMIT_set", value, 511);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_SOFT_MIN_LIMIT_set", A, value );

    /* (0x000004d0 bits 8:0) field PHGEN_REGV_SOFT_MIN_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_SOFT_MIN_LIMIT_MSK,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_SOFT_MIN_LIMIT_OFF,
                                                                      value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_SOFT_MIN_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_SOFT_MIN_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_SOFT_MIN_LIMIT_get", A, 15);
    /* (0x000004d0 bits 8:0) field PHGEN_REGV_SOFT_MIN_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_SOFT_MIN_LIMIT_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_SOFT_MIN_LIMIT_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_SOFT_MIN_LIMIT_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_REGV_SOFT_MIN_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A,
                                                                            UINT32 start_bit,
                                                                            UINT32 stop_bit,
                                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_REGV_SOFT_MIN_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A,
                                                                            UINT32 start_bit,
                                                                            UINT32 stop_bit,
                                                                            UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_SOFT_MIN_LIMIT_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_SOFT_MIN_LIMIT_set", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_SOFT_MIN_LIMIT_set", stop_bit, 8 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_REGV_SOFT_MIN_LIMIT_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004d0 bits 8:0) field PHGEN_REGV_SOFT_MIN_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 8) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 8;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004d0 bits 8:0) field PHGEN_REGV_SOFT_MIN_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_field_set( b_ptr,
                                                                          h_ptr,
                                                                          A,
                                                                          subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_SOFT_MIN_LIMIT_OFF + subfield_offset),
                                                                          PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_SOFT_MIN_LIMIT_OFF + subfield_offset,
                                                                          value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_REGV_SOFT_MIN_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A,
                                                                              UINT32 start_bit,
                                                                              UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_REGV_SOFT_MIN_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A,
                                                                              UINT32 start_bit,
                                                                              UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_SOFT_MIN_LIMIT_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_SOFT_MIN_LIMIT_get", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_REGV_SOFT_MIN_LIMIT_get", stop_bit, 8 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 8) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 8;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004d0 bits 8:0) field PHGEN_REGV_SOFT_MIN_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_SOFT_MIN_LIMIT_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_SOFT_MIN_LIMIT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_SOFT_MIN_LIMIT_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_CFG_4_BIT_PHGEN_REGV_SOFT_MIN_LIMIT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_REGV_SOFT_MIN_LIMIT_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_TIMER_VALUE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_TIMER_VALUE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_TIMER_VALUE_set", A, 15);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_TIMER_VALUE_set", A, value );

    /* (0x000004d4 bits 31:0) field PHGEN_FT_TIMER_VALUE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1_field_set( b_ptr,
                                                                         h_ptr,
                                                                         A,
                                                                         PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1_BIT_PHGEN_FT_TIMER_VALUE_MSK,
                                                                         PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1_BIT_PHGEN_FT_TIMER_VALUE_OFF,
                                                                         value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_TIMER_VALUE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_TIMER_VALUE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_TIMER_VALUE_get", A, 15);
    /* (0x000004d4 bits 31:0) field PHGEN_FT_TIMER_VALUE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1_read( b_ptr,
                                                                                h_ptr,
                                                                                A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1_BIT_PHGEN_FT_TIMER_VALUE_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1_BIT_PHGEN_FT_TIMER_VALUE_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_TIMER_VALUE_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_FT_TIMER_VALUE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit,
                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_FT_TIMER_VALUE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit,
                                                                       UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_TIMER_VALUE_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_FT_TIMER_VALUE_set", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_TIMER_VALUE_set", stop_bit, 31 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_FT_TIMER_VALUE_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004d4 bits 31:0) field PHGEN_FT_TIMER_VALUE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 31) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 31;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004d4 bits 31:0) field PHGEN_FT_TIMER_VALUE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1_field_set( b_ptr,
                                                                             h_ptr,
                                                                             A,
                                                                             subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1_BIT_PHGEN_FT_TIMER_VALUE_OFF + subfield_offset),
                                                                             PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1_BIT_PHGEN_FT_TIMER_VALUE_OFF + subfield_offset,
                                                                             value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_FT_TIMER_VALUE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_FT_TIMER_VALUE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_TIMER_VALUE_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_FT_TIMER_VALUE_get", stop_bit, start_bit );
    if (stop_bit > 31) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_TIMER_VALUE_get", stop_bit, 31 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 31) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 31;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004d4 bits 31:0) field PHGEN_FT_TIMER_VALUE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1_read( b_ptr,
                                                                                h_ptr,
                                                                                A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1_BIT_PHGEN_FT_TIMER_VALUE_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1_BIT_PHGEN_FT_TIMER_VALUE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1_BIT_PHGEN_FT_TIMER_VALUE_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_1_BIT_PHGEN_FT_TIMER_VALUE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_FT_TIMER_VALUE_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_INVERT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_INVERT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_INVERT_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_INVERT_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_INVERT_set", A, value );

    /* (0x000004d8 bits 24) field PHGEN_FT_INVERT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_field_set( b_ptr,
                                                                         h_ptr,
                                                                         A,
                                                                         PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_BIT_PHGEN_FT_INVERT_MSK,
                                                                         PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_BIT_PHGEN_FT_INVERT_OFF,
                                                                         value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_INVERT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_INVERT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_INVERT_get", A, 15);
    /* (0x000004d8 bits 24) field PHGEN_FT_INVERT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_read( b_ptr,
                                                                                h_ptr,
                                                                                A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_BIT_PHGEN_FT_INVERT_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_BIT_PHGEN_FT_INVERT_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_INVERT_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_TOLERANCE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_TOLERANCE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_TOLERANCE_set", A, 15);
    if (value > 255)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_TOLERANCE_set", value, 255);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_TOLERANCE_set", A, value );

    /* (0x000004d8 bits 23:16) field PHGEN_FT_TOLERANCE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_field_set( b_ptr,
                                                                         h_ptr,
                                                                         A,
                                                                         PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_BIT_PHGEN_FT_TOLERANCE_MSK,
                                                                         PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_BIT_PHGEN_FT_TOLERANCE_OFF,
                                                                         value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_TOLERANCE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_TOLERANCE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_TOLERANCE_get", A, 15);
    /* (0x000004d8 bits 23:16) field PHGEN_FT_TOLERANCE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_read( b_ptr,
                                                                                h_ptr,
                                                                                A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_BIT_PHGEN_FT_TOLERANCE_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_BIT_PHGEN_FT_TOLERANCE_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_TOLERANCE_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_FT_TOLERANCE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_FT_TOLERANCE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_TOLERANCE_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_FT_TOLERANCE_set", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_TOLERANCE_set", stop_bit, 7 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_FT_TOLERANCE_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004d8 bits 23:16) field PHGEN_FT_TOLERANCE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 7) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 7;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004d8 bits 23:16) field PHGEN_FT_TOLERANCE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_field_set( b_ptr,
                                                                             h_ptr,
                                                                             A,
                                                                             subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_BIT_PHGEN_FT_TOLERANCE_OFF + subfield_offset),
                                                                             PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_BIT_PHGEN_FT_TOLERANCE_OFF + subfield_offset,
                                                                             value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_FT_TOLERANCE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_FT_TOLERANCE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_TOLERANCE_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_FT_TOLERANCE_get", stop_bit, start_bit );
    if (stop_bit > 7) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_TOLERANCE_get", stop_bit, 7 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 7) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 7;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004d8 bits 23:16) field PHGEN_FT_TOLERANCE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_read( b_ptr,
                                                                                h_ptr,
                                                                                A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_BIT_PHGEN_FT_TOLERANCE_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_BIT_PHGEN_FT_TOLERANCE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_BIT_PHGEN_FT_TOLERANCE_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_BIT_PHGEN_FT_TOLERANCE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_FT_TOLERANCE_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_WINDOW_SIZE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_WINDOW_SIZE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_WINDOW_SIZE_set", A, 15);
    if (value > 65535)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_WINDOW_SIZE_set", value, 65535);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_WINDOW_SIZE_set", A, value );

    /* (0x000004d8 bits 15:0) field PHGEN_FT_WINDOW_SIZE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_field_set( b_ptr,
                                                                         h_ptr,
                                                                         A,
                                                                         PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_BIT_PHGEN_FT_WINDOW_SIZE_MSK,
                                                                         PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_BIT_PHGEN_FT_WINDOW_SIZE_OFF,
                                                                         value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_WINDOW_SIZE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_WINDOW_SIZE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_WINDOW_SIZE_get", A, 15);
    /* (0x000004d8 bits 15:0) field PHGEN_FT_WINDOW_SIZE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_read( b_ptr,
                                                                                h_ptr,
                                                                                A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_BIT_PHGEN_FT_WINDOW_SIZE_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_BIT_PHGEN_FT_WINDOW_SIZE_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_WINDOW_SIZE_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_FT_WINDOW_SIZE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit,
                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_FT_WINDOW_SIZE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit,
                                                                       UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_WINDOW_SIZE_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_FT_WINDOW_SIZE_set", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_WINDOW_SIZE_set", stop_bit, 15 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_FT_WINDOW_SIZE_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004d8 bits 15:0) field PHGEN_FT_WINDOW_SIZE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 15) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 15;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004d8 bits 15:0) field PHGEN_FT_WINDOW_SIZE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_field_set( b_ptr,
                                                                             h_ptr,
                                                                             A,
                                                                             subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_BIT_PHGEN_FT_WINDOW_SIZE_OFF + subfield_offset),
                                                                             PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_BIT_PHGEN_FT_WINDOW_SIZE_OFF + subfield_offset,
                                                                             value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_FT_WINDOW_SIZE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_FT_WINDOW_SIZE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 start_bit,
                                                                         UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_WINDOW_SIZE_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_FT_WINDOW_SIZE_get", stop_bit, start_bit );
    if (stop_bit > 15) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_WINDOW_SIZE_get", stop_bit, 15 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 15) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 15;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004d8 bits 15:0) field PHGEN_FT_WINDOW_SIZE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_read( b_ptr,
                                                                                h_ptr,
                                                                                A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_BIT_PHGEN_FT_WINDOW_SIZE_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_BIT_PHGEN_FT_WINDOW_SIZE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_BIT_PHGEN_FT_WINDOW_SIZE_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_2_BIT_PHGEN_FT_WINDOW_SIZE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_FT_WINDOW_SIZE_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_HARD_MAX_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_HARD_MAX_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_HARD_MAX_LIMIT_set", A, 15);
    if (value > 511)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_HARD_MAX_LIMIT_set", value, 511);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_HARD_MAX_LIMIT_set", A, value );

    /* (0x000004dc bits 17:9) field PHGEN_FT_HARD_MAX_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_field_set( b_ptr,
                                                                         h_ptr,
                                                                         A,
                                                                         PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_BIT_PHGEN_FT_HARD_MAX_LIMIT_MSK,
                                                                         PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_BIT_PHGEN_FT_HARD_MAX_LIMIT_OFF,
                                                                         value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_HARD_MAX_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_HARD_MAX_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_HARD_MAX_LIMIT_get", A, 15);
    /* (0x000004dc bits 17:9) field PHGEN_FT_HARD_MAX_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_read( b_ptr,
                                                                                h_ptr,
                                                                                A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_BIT_PHGEN_FT_HARD_MAX_LIMIT_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_BIT_PHGEN_FT_HARD_MAX_LIMIT_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_HARD_MAX_LIMIT_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_FT_HARD_MAX_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_FT_HARD_MAX_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_HARD_MAX_LIMIT_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_FT_HARD_MAX_LIMIT_set", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_HARD_MAX_LIMIT_set", stop_bit, 8 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_FT_HARD_MAX_LIMIT_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004dc bits 17:9) field PHGEN_FT_HARD_MAX_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 8) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 8;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004dc bits 17:9) field PHGEN_FT_HARD_MAX_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_field_set( b_ptr,
                                                                             h_ptr,
                                                                             A,
                                                                             subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_BIT_PHGEN_FT_HARD_MAX_LIMIT_OFF + subfield_offset),
                                                                             PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_BIT_PHGEN_FT_HARD_MAX_LIMIT_OFF + subfield_offset,
                                                                             value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_FT_HARD_MAX_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A,
                                                                            UINT32 start_bit,
                                                                            UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_FT_HARD_MAX_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A,
                                                                            UINT32 start_bit,
                                                                            UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_HARD_MAX_LIMIT_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_FT_HARD_MAX_LIMIT_get", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_HARD_MAX_LIMIT_get", stop_bit, 8 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 8) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 8;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004dc bits 17:9) field PHGEN_FT_HARD_MAX_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_read( b_ptr,
                                                                                h_ptr,
                                                                                A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_BIT_PHGEN_FT_HARD_MAX_LIMIT_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_BIT_PHGEN_FT_HARD_MAX_LIMIT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_BIT_PHGEN_FT_HARD_MAX_LIMIT_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_BIT_PHGEN_FT_HARD_MAX_LIMIT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_FT_HARD_MAX_LIMIT_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_SOFT_MAX_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_SOFT_MAX_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_SOFT_MAX_LIMIT_set", A, 15);
    if (value > 511)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_SOFT_MAX_LIMIT_set", value, 511);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_SOFT_MAX_LIMIT_set", A, value );

    /* (0x000004dc bits 8:0) field PHGEN_FT_SOFT_MAX_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_field_set( b_ptr,
                                                                         h_ptr,
                                                                         A,
                                                                         PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_BIT_PHGEN_FT_SOFT_MAX_LIMIT_MSK,
                                                                         PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_BIT_PHGEN_FT_SOFT_MAX_LIMIT_OFF,
                                                                         value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_SOFT_MAX_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_SOFT_MAX_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_SOFT_MAX_LIMIT_get", A, 15);
    /* (0x000004dc bits 8:0) field PHGEN_FT_SOFT_MAX_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_read( b_ptr,
                                                                                h_ptr,
                                                                                A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_BIT_PHGEN_FT_SOFT_MAX_LIMIT_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_BIT_PHGEN_FT_SOFT_MAX_LIMIT_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_SOFT_MAX_LIMIT_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_FT_SOFT_MAX_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_FT_SOFT_MAX_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_SOFT_MAX_LIMIT_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_FT_SOFT_MAX_LIMIT_set", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_SOFT_MAX_LIMIT_set", stop_bit, 8 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_FT_SOFT_MAX_LIMIT_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004dc bits 8:0) field PHGEN_FT_SOFT_MAX_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 8) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 8;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004dc bits 8:0) field PHGEN_FT_SOFT_MAX_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_field_set( b_ptr,
                                                                             h_ptr,
                                                                             A,
                                                                             subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_BIT_PHGEN_FT_SOFT_MAX_LIMIT_OFF + subfield_offset),
                                                                             PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_BIT_PHGEN_FT_SOFT_MAX_LIMIT_OFF + subfield_offset,
                                                                             value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_FT_SOFT_MAX_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A,
                                                                            UINT32 start_bit,
                                                                            UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_FT_SOFT_MAX_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A,
                                                                            UINT32 start_bit,
                                                                            UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_SOFT_MAX_LIMIT_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_FT_SOFT_MAX_LIMIT_get", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_SOFT_MAX_LIMIT_get", stop_bit, 8 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 8) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 8;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004dc bits 8:0) field PHGEN_FT_SOFT_MAX_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_read( b_ptr,
                                                                                h_ptr,
                                                                                A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_BIT_PHGEN_FT_SOFT_MAX_LIMIT_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_BIT_PHGEN_FT_SOFT_MAX_LIMIT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_BIT_PHGEN_FT_SOFT_MAX_LIMIT_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_3_BIT_PHGEN_FT_SOFT_MAX_LIMIT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_FT_SOFT_MAX_LIMIT_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_OFFSET_VAL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A,
                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_OFFSET_VAL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A,
                                                                UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_OFFSET_VAL_set", A, 15);
    if (value > 511)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_OFFSET_VAL_set", value, 511);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_OFFSET_VAL_set", A, value );

    /* (0x000004e0 bits 26:18) field PHGEN_FT_OFFSET_VAL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_field_set( b_ptr,
                                                                         h_ptr,
                                                                         A,
                                                                         PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_OFFSET_VAL_MSK,
                                                                         PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_OFFSET_VAL_OFF,
                                                                         value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_OFFSET_VAL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_OFFSET_VAL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_OFFSET_VAL_get", A, 15);
    /* (0x000004e0 bits 26:18) field PHGEN_FT_OFFSET_VAL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_read( b_ptr,
                                                                                h_ptr,
                                                                                A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_OFFSET_VAL_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_OFFSET_VAL_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_OFFSET_VAL_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_FT_OFFSET_VAL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit,
                                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_FT_OFFSET_VAL_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 start_bit,
                                                                      UINT32 stop_bit,
                                                                      UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_OFFSET_VAL_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_FT_OFFSET_VAL_set", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_OFFSET_VAL_set", stop_bit, 8 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_FT_OFFSET_VAL_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004e0 bits 26:18) field PHGEN_FT_OFFSET_VAL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 8) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 8;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004e0 bits 26:18) field PHGEN_FT_OFFSET_VAL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_field_set( b_ptr,
                                                                             h_ptr,
                                                                             A,
                                                                             subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_OFFSET_VAL_OFF + subfield_offset),
                                                                             PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_OFFSET_VAL_OFF + subfield_offset,
                                                                             value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_FT_OFFSET_VAL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_FT_OFFSET_VAL_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A,
                                                                        UINT32 start_bit,
                                                                        UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_OFFSET_VAL_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_FT_OFFSET_VAL_get", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_OFFSET_VAL_get", stop_bit, 8 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 8) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 8;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004e0 bits 26:18) field PHGEN_FT_OFFSET_VAL of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_read( b_ptr,
                                                                                h_ptr,
                                                                                A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_OFFSET_VAL_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_OFFSET_VAL_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_OFFSET_VAL_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_OFFSET_VAL_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_FT_OFFSET_VAL_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_HARD_MIN_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_HARD_MIN_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_HARD_MIN_LIMIT_set", A, 15);
    if (value > 511)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_HARD_MIN_LIMIT_set", value, 511);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_HARD_MIN_LIMIT_set", A, value );

    /* (0x000004e0 bits 17:9) field PHGEN_FT_HARD_MIN_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_field_set( b_ptr,
                                                                         h_ptr,
                                                                         A,
                                                                         PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_HARD_MIN_LIMIT_MSK,
                                                                         PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_HARD_MIN_LIMIT_OFF,
                                                                         value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_HARD_MIN_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_HARD_MIN_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_HARD_MIN_LIMIT_get", A, 15);
    /* (0x000004e0 bits 17:9) field PHGEN_FT_HARD_MIN_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_read( b_ptr,
                                                                                h_ptr,
                                                                                A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_HARD_MIN_LIMIT_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_HARD_MIN_LIMIT_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_HARD_MIN_LIMIT_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_FT_HARD_MIN_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_FT_HARD_MIN_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_HARD_MIN_LIMIT_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_FT_HARD_MIN_LIMIT_set", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_HARD_MIN_LIMIT_set", stop_bit, 8 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_FT_HARD_MIN_LIMIT_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004e0 bits 17:9) field PHGEN_FT_HARD_MIN_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 8) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 8;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004e0 bits 17:9) field PHGEN_FT_HARD_MIN_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_field_set( b_ptr,
                                                                             h_ptr,
                                                                             A,
                                                                             subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_HARD_MIN_LIMIT_OFF + subfield_offset),
                                                                             PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_HARD_MIN_LIMIT_OFF + subfield_offset,
                                                                             value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_FT_HARD_MIN_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A,
                                                                            UINT32 start_bit,
                                                                            UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_FT_HARD_MIN_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A,
                                                                            UINT32 start_bit,
                                                                            UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_HARD_MIN_LIMIT_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_FT_HARD_MIN_LIMIT_get", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_HARD_MIN_LIMIT_get", stop_bit, 8 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 8) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 8;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004e0 bits 17:9) field PHGEN_FT_HARD_MIN_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_read( b_ptr,
                                                                                h_ptr,
                                                                                A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_HARD_MIN_LIMIT_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_HARD_MIN_LIMIT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_HARD_MIN_LIMIT_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_HARD_MIN_LIMIT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_FT_HARD_MIN_LIMIT_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_SOFT_MIN_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_SOFT_MIN_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_SOFT_MIN_LIMIT_set", A, 15);
    if (value > 511)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_SOFT_MIN_LIMIT_set", value, 511);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_SOFT_MIN_LIMIT_set", A, value );

    /* (0x000004e0 bits 8:0) field PHGEN_FT_SOFT_MIN_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_field_set( b_ptr,
                                                                         h_ptr,
                                                                         A,
                                                                         PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_SOFT_MIN_LIMIT_MSK,
                                                                         PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_SOFT_MIN_LIMIT_OFF,
                                                                         value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_SOFT_MIN_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_SOFT_MIN_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_SOFT_MIN_LIMIT_get", A, 15);
    /* (0x000004e0 bits 8:0) field PHGEN_FT_SOFT_MIN_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_read( b_ptr,
                                                                                h_ptr,
                                                                                A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_SOFT_MIN_LIMIT_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_SOFT_MIN_LIMIT_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_SOFT_MIN_LIMIT_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_FT_SOFT_MIN_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_FT_SOFT_MIN_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_SOFT_MIN_LIMIT_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_FT_SOFT_MIN_LIMIT_set", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_SOFT_MIN_LIMIT_set", stop_bit, 8 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_FT_SOFT_MIN_LIMIT_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004e0 bits 8:0) field PHGEN_FT_SOFT_MIN_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 8) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 8;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004e0 bits 8:0) field PHGEN_FT_SOFT_MIN_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_field_set( b_ptr,
                                                                             h_ptr,
                                                                             A,
                                                                             subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_SOFT_MIN_LIMIT_OFF + subfield_offset),
                                                                             PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_SOFT_MIN_LIMIT_OFF + subfield_offset,
                                                                             value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_FT_SOFT_MIN_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A,
                                                                            UINT32 start_bit,
                                                                            UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_FT_SOFT_MIN_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A,
                                                                            UINT32 start_bit,
                                                                            UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_SOFT_MIN_LIMIT_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_FT_SOFT_MIN_LIMIT_get", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_SOFT_MIN_LIMIT_get", stop_bit, 8 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 8) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 8;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004e0 bits 8:0) field PHGEN_FT_SOFT_MIN_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_read( b_ptr,
                                                                                h_ptr,
                                                                                A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_SOFT_MIN_LIMIT_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_SOFT_MIN_LIMIT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_SOFT_MIN_LIMIT_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_FT_CFG_4_BIT_PHGEN_FT_SOFT_MIN_LIMIT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_FT_SOFT_MIN_LIMIT_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_CT_SOFT_MAX_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_CT_SOFT_MAX_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_CT_SOFT_MAX_LIMIT_set", A, 15);
    if (value > 63)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_SOFT_MAX_LIMIT_set", value, 63);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_SOFT_MAX_LIMIT_set", A, value );

    /* (0x000004e4 bits 28:23) field PHGEN_CT_SOFT_MAX_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_field_set( b_ptr,
                                                                           h_ptr,
                                                                           A,
                                                                           PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SOFT_MAX_LIMIT_MSK,
                                                                           PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SOFT_MAX_LIMIT_OFF,
                                                                           value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CT_SOFT_MAX_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CT_SOFT_MAX_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_CT_SOFT_MAX_LIMIT_get", A, 15);
    /* (0x000004e4 bits 28:23) field PHGEN_CT_SOFT_MAX_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_read( b_ptr,
                                                                                  h_ptr,
                                                                                  A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SOFT_MAX_LIMIT_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SOFT_MAX_LIMIT_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_SOFT_MAX_LIMIT_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_CT_SOFT_MAX_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_CT_SOFT_MAX_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_CT_SOFT_MAX_LIMIT_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_CT_SOFT_MAX_LIMIT_set", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_CT_SOFT_MAX_LIMIT_set", stop_bit, 5 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_CT_SOFT_MAX_LIMIT_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004e4 bits 28:23) field PHGEN_CT_SOFT_MAX_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 5) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 5;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004e4 bits 28:23) field PHGEN_CT_SOFT_MAX_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_field_set( b_ptr,
                                                                               h_ptr,
                                                                               A,
                                                                               subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SOFT_MAX_LIMIT_OFF + subfield_offset),
                                                                               PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SOFT_MAX_LIMIT_OFF + subfield_offset,
                                                                               value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_CT_SOFT_MAX_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A,
                                                                            UINT32 start_bit,
                                                                            UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_CT_SOFT_MAX_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A,
                                                                            UINT32 start_bit,
                                                                            UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_CT_SOFT_MAX_LIMIT_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_CT_SOFT_MAX_LIMIT_get", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_CT_SOFT_MAX_LIMIT_get", stop_bit, 5 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 5) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 5;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004e4 bits 28:23) field PHGEN_CT_SOFT_MAX_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_read( b_ptr,
                                                                                  h_ptr,
                                                                                  A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SOFT_MAX_LIMIT_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SOFT_MAX_LIMIT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SOFT_MAX_LIMIT_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SOFT_MAX_LIMIT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_CT_SOFT_MAX_LIMIT_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_CT_SOFT_MIN_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_CT_SOFT_MIN_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_CT_SOFT_MIN_LIMIT_set", A, 15);
    if (value > 63)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_SOFT_MIN_LIMIT_set", value, 63);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_SOFT_MIN_LIMIT_set", A, value );

    /* (0x000004e4 bits 22:17) field PHGEN_CT_SOFT_MIN_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_field_set( b_ptr,
                                                                           h_ptr,
                                                                           A,
                                                                           PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SOFT_MIN_LIMIT_MSK,
                                                                           PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SOFT_MIN_LIMIT_OFF,
                                                                           value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CT_SOFT_MIN_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CT_SOFT_MIN_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_CT_SOFT_MIN_LIMIT_get", A, 15);
    /* (0x000004e4 bits 22:17) field PHGEN_CT_SOFT_MIN_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_read( b_ptr,
                                                                                  h_ptr,
                                                                                  A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SOFT_MIN_LIMIT_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SOFT_MIN_LIMIT_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_SOFT_MIN_LIMIT_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_CT_SOFT_MIN_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_CT_SOFT_MIN_LIMIT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A,
                                                                          UINT32 start_bit,
                                                                          UINT32 stop_bit,
                                                                          UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_CT_SOFT_MIN_LIMIT_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_CT_SOFT_MIN_LIMIT_set", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_CT_SOFT_MIN_LIMIT_set", stop_bit, 5 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_CT_SOFT_MIN_LIMIT_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004e4 bits 22:17) field PHGEN_CT_SOFT_MIN_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 5) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 5;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004e4 bits 22:17) field PHGEN_CT_SOFT_MIN_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_field_set( b_ptr,
                                                                               h_ptr,
                                                                               A,
                                                                               subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SOFT_MIN_LIMIT_OFF + subfield_offset),
                                                                               PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SOFT_MIN_LIMIT_OFF + subfield_offset,
                                                                               value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_CT_SOFT_MIN_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A,
                                                                            UINT32 start_bit,
                                                                            UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_CT_SOFT_MIN_LIMIT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                            s16_handle_t *h_ptr,
                                                                            UINT32 A,
                                                                            UINT32 start_bit,
                                                                            UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_CT_SOFT_MIN_LIMIT_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_CT_SOFT_MIN_LIMIT_get", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_CT_SOFT_MIN_LIMIT_get", stop_bit, 5 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 5) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 5;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004e4 bits 22:17) field PHGEN_CT_SOFT_MIN_LIMIT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_read( b_ptr,
                                                                                  h_ptr,
                                                                                  A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SOFT_MIN_LIMIT_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SOFT_MIN_LIMIT_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SOFT_MIN_LIMIT_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SOFT_MIN_LIMIT_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_CT_SOFT_MIN_LIMIT_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_MODE_7D6_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_MODE_7D6_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A,
                                                           UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_MODE_7D6_set", A, 15);
    if (value > 3)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_MODE_7D6_set", value, 3);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_MODE_7D6_set", A, value );

    /* (0x000004e4 bits 16:15) field PHGEN_MODE_7D6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_field_set( b_ptr,
                                                                           h_ptr,
                                                                           A,
                                                                           PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_MODE_7D6_MSK,
                                                                           PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_MODE_7D6_OFF,
                                                                           value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_MODE_7D6_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_MODE_7D6_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_MODE_7D6_get", A, 15);
    /* (0x000004e4 bits 16:15) field PHGEN_MODE_7D6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_read( b_ptr,
                                                                                  h_ptr,
                                                                                  A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_MODE_7D6_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_MODE_7D6_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_MODE_7D6_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_MODE_7D6_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_MODE_7D6_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_MODE_7D6_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_MODE_7D6_set", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_MODE_7D6_set", stop_bit, 1 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_MODE_7D6_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004e4 bits 16:15) field PHGEN_MODE_7D6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 1) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 1;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004e4 bits 16:15) field PHGEN_MODE_7D6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_field_set( b_ptr,
                                                                               h_ptr,
                                                                               A,
                                                                               subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_MODE_7D6_OFF + subfield_offset),
                                                                               PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_MODE_7D6_OFF + subfield_offset,
                                                                               value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_MODE_7D6_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_MODE_7D6_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_MODE_7D6_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_MODE_7D6_get", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_MODE_7D6_get", stop_bit, 1 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 1) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 1;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004e4 bits 16:15) field PHGEN_MODE_7D6 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_read( b_ptr,
                                                                                  h_ptr,
                                                                                  A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_MODE_7D6_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_MODE_7D6_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_MODE_7D6_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_MODE_7D6_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_MODE_7D6_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_MODE_5D1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A,
                                                           UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_MODE_5D1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                           s16_handle_t *h_ptr,
                                                           UINT32 A,
                                                           UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_MODE_5D1_set", A, 15);
    if (value > 31)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_MODE_5D1_set", value, 31);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_MODE_5D1_set", A, value );

    /* (0x000004e4 bits 14:10) field PHGEN_MODE_5D1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_field_set( b_ptr,
                                                                           h_ptr,
                                                                           A,
                                                                           PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_MODE_5D1_MSK,
                                                                           PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_MODE_5D1_OFF,
                                                                           value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_MODE_5D1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_MODE_5D1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_MODE_5D1_get", A, 15);
    /* (0x000004e4 bits 14:10) field PHGEN_MODE_5D1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_read( b_ptr,
                                                                                  h_ptr,
                                                                                  A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_MODE_5D1_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_MODE_5D1_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_MODE_5D1_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_MODE_5D1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_MODE_5D1_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 start_bit,
                                                                 UINT32 stop_bit,
                                                                 UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_MODE_5D1_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_MODE_5D1_set", stop_bit, start_bit );
    if (stop_bit > 4) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_MODE_5D1_set", stop_bit, 4 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_MODE_5D1_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004e4 bits 14:10) field PHGEN_MODE_5D1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 4) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 4;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004e4 bits 14:10) field PHGEN_MODE_5D1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_field_set( b_ptr,
                                                                               h_ptr,
                                                                               A,
                                                                               subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_MODE_5D1_OFF + subfield_offset),
                                                                               PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_MODE_5D1_OFF + subfield_offset,
                                                                               value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_MODE_5D1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_MODE_5D1_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_MODE_5D1_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_MODE_5D1_get", stop_bit, start_bit );
    if (stop_bit > 4) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_MODE_5D1_get", stop_bit, 4 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 4) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 4;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004e4 bits 14:10) field PHGEN_MODE_5D1 of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_read( b_ptr,
                                                                                  h_ptr,
                                                                                  A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_MODE_5D1_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_MODE_5D1_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_MODE_5D1_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_MODE_5D1_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_MODE_5D1_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_CT_INVERT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_CT_INVERT_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_CT_INVERT_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_INVERT_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_INVERT_set", A, value );

    /* (0x000004e4 bits 9) field PHGEN_CT_INVERT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_field_set( b_ptr,
                                                                           h_ptr,
                                                                           A,
                                                                           PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_INVERT_MSK,
                                                                           PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_INVERT_OFF,
                                                                           value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CT_INVERT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CT_INVERT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_CT_INVERT_get", A, 15);
    /* (0x000004e4 bits 9) field PHGEN_CT_INVERT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_read( b_ptr,
                                                                                  h_ptr,
                                                                                  A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_INVERT_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_INVERT_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_INVERT_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_ATMSB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_ATMSB_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A,
                                                        UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_ATMSB_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_ATMSB_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_ATMSB_set", A, value );

    /* (0x000004e4 bits 8) field PHGEN_ATMSB of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_field_set( b_ptr,
                                                                           h_ptr,
                                                                           A,
                                                                           PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_ATMSB_MSK,
                                                                           PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_ATMSB_OFF,
                                                                           value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_ATMSB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_ATMSB_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_ATMSB_get", A, 15);
    /* (0x000004e4 bits 8) field PHGEN_ATMSB of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_read( b_ptr,
                                                                                  h_ptr,
                                                                                  A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_ATMSB_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_ATMSB_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_ATMSB_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_CT_SETTLE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_CT_SETTLE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_CT_SETTLE_set", A, 15);
    if (value > 7)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_SETTLE_set", value, 7);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_SETTLE_set", A, value );

    /* (0x000004e4 bits 7:5) field PHGEN_CT_SETTLE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_field_set( b_ptr,
                                                                           h_ptr,
                                                                           A,
                                                                           PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SETTLE_MSK,
                                                                           PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SETTLE_OFF,
                                                                           value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CT_SETTLE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CT_SETTLE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_CT_SETTLE_get", A, 15);
    /* (0x000004e4 bits 7:5) field PHGEN_CT_SETTLE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_read( b_ptr,
                                                                                  h_ptr,
                                                                                  A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SETTLE_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SETTLE_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_SETTLE_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_CT_SETTLE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_CT_SETTLE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit,
                                                                  UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_CT_SETTLE_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_CT_SETTLE_set", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_CT_SETTLE_set", stop_bit, 2 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_CT_SETTLE_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004e4 bits 7:5) field PHGEN_CT_SETTLE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 2) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 2;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004e4 bits 7:5) field PHGEN_CT_SETTLE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_field_set( b_ptr,
                                                                               h_ptr,
                                                                               A,
                                                                               subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SETTLE_OFF + subfield_offset),
                                                                               PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SETTLE_OFF + subfield_offset,
                                                                               value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_CT_SETTLE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_CT_SETTLE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_CT_SETTLE_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_CT_SETTLE_get", stop_bit, start_bit );
    if (stop_bit > 2) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_CT_SETTLE_get", stop_bit, 2 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 2) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 2;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004e4 bits 7:5) field PHGEN_CT_SETTLE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_read( b_ptr,
                                                                                  h_ptr,
                                                                                  A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SETTLE_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SETTLE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SETTLE_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_SETTLE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_CT_SETTLE_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_CT_NUM_CYCLE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_CT_NUM_CYCLE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_CT_NUM_CYCLE_set", A, 15);
    if (value > 3)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_NUM_CYCLE_set", value, 3);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_NUM_CYCLE_set", A, value );

    /* (0x000004e4 bits 4:3) field PHGEN_CT_NUM_CYCLE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_field_set( b_ptr,
                                                                           h_ptr,
                                                                           A,
                                                                           PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_NUM_CYCLE_MSK,
                                                                           PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_NUM_CYCLE_OFF,
                                                                           value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CT_NUM_CYCLE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CT_NUM_CYCLE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_CT_NUM_CYCLE_get", A, 15);
    /* (0x000004e4 bits 4:3) field PHGEN_CT_NUM_CYCLE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_read( b_ptr,
                                                                                  h_ptr,
                                                                                  A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_NUM_CYCLE_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_NUM_CYCLE_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_NUM_CYCLE_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_CT_NUM_CYCLE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_CT_NUM_CYCLE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_CT_NUM_CYCLE_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_CT_NUM_CYCLE_set", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_CT_NUM_CYCLE_set", stop_bit, 1 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_CT_NUM_CYCLE_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004e4 bits 4:3) field PHGEN_CT_NUM_CYCLE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 1) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 1;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004e4 bits 4:3) field PHGEN_CT_NUM_CYCLE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_field_set( b_ptr,
                                                                               h_ptr,
                                                                               A,
                                                                               subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_NUM_CYCLE_OFF + subfield_offset),
                                                                               PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_NUM_CYCLE_OFF + subfield_offset,
                                                                               value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_CT_NUM_CYCLE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_CT_NUM_CYCLE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_CT_NUM_CYCLE_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_CT_NUM_CYCLE_get", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_CT_NUM_CYCLE_get", stop_bit, 1 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 1) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 1;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004e4 bits 4:3) field PHGEN_CT_NUM_CYCLE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_read( b_ptr,
                                                                                  h_ptr,
                                                                                  A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_NUM_CYCLE_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_NUM_CYCLE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_NUM_CYCLE_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_MABC_CFG_1_BIT_PHGEN_CT_NUM_CYCLE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_CT_NUM_CYCLE_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_CT_OVR_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_CT_OVR_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_CT_OVR_EN_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_OVR_EN_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_OVR_EN_set", A, value );

    /* (0x000004e8 bits 17) field PHGEN_CT_OVR_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_CT_OVR_EN_MSK,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_CT_OVR_EN_OFF,
                                                                      value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CT_OVR_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CT_OVR_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_CT_OVR_EN_get", A, 15);
    /* (0x000004e8 bits 17) field PHGEN_CT_OVR_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_CT_OVR_EN_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_CT_OVR_EN_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_OVR_EN_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_CT_OVR_DONE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_CT_OVR_DONE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A,
                                                              UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_CT_OVR_DONE_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_OVR_DONE_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_OVR_DONE_set", A, value );

    /* (0x000004e8 bits 16) field PHGEN_CT_OVR_DONE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_CT_OVR_DONE_MSK,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_CT_OVR_DONE_OFF,
                                                                      value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CT_OVR_DONE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CT_OVR_DONE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                s16_handle_t *h_ptr,
                                                                UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_CT_OVR_DONE_get", A, 15);
    /* (0x000004e8 bits 16) field PHGEN_CT_OVR_DONE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_CT_OVR_DONE_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_CT_OVR_DONE_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_OVR_DONE_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_CT_OVR_VALUE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_CT_OVR_VALUE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_CT_OVR_VALUE_set", A, 15);
    if (value > 63)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_OVR_VALUE_set", value, 63);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_OVR_VALUE_set", A, value );

    /* (0x000004e8 bits 15:10) field PHGEN_CT_OVR_VALUE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_CT_OVR_VALUE_MSK,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_CT_OVR_VALUE_OFF,
                                                                      value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CT_OVR_VALUE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CT_OVR_VALUE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_CT_OVR_VALUE_get", A, 15);
    /* (0x000004e8 bits 15:10) field PHGEN_CT_OVR_VALUE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_CT_OVR_VALUE_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_CT_OVR_VALUE_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_OVR_VALUE_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_CT_OVR_VALUE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_CT_OVR_VALUE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_CT_OVR_VALUE_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_CT_OVR_VALUE_set", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_CT_OVR_VALUE_set", stop_bit, 5 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_CT_OVR_VALUE_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004e8 bits 15:10) field PHGEN_CT_OVR_VALUE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 5) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 5;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004e8 bits 15:10) field PHGEN_CT_OVR_VALUE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_field_set( b_ptr,
                                                                          h_ptr,
                                                                          A,
                                                                          subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_CT_OVR_VALUE_OFF + subfield_offset),
                                                                          PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_CT_OVR_VALUE_OFF + subfield_offset,
                                                                          value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_CT_OVR_VALUE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_CT_OVR_VALUE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_CT_OVR_VALUE_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_CT_OVR_VALUE_get", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_CT_OVR_VALUE_get", stop_bit, 5 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 5) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 5;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004e8 bits 15:10) field PHGEN_CT_OVR_VALUE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_CT_OVR_VALUE_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_CT_OVR_VALUE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_CT_OVR_VALUE_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_CT_OVR_VALUE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_CT_OVR_VALUE_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_OVR_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_OVR_EN_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A,
                                                            UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_OVR_EN_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_OVR_EN_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_OVR_EN_set", A, value );

    /* (0x000004e8 bits 9) field PHGEN_FT_OVR_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_FT_OVR_EN_MSK,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_FT_OVR_EN_OFF,
                                                                      value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_OVR_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_OVR_EN_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_OVR_EN_get", A, 15);
    /* (0x000004e8 bits 9) field PHGEN_FT_OVR_EN of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_FT_OVR_EN_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_FT_OVR_EN_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_OVR_EN_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_OVR_VALUE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_OVR_VALUE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A,
                                                               UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_OVR_VALUE_set", A, 15);
    if (value > 511)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_OVR_VALUE_set", value, 511);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_OVR_VALUE_set", A, value );

    /* (0x000004e8 bits 8:0) field PHGEN_FT_OVR_VALUE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_FT_OVR_VALUE_MSK,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_FT_OVR_VALUE_OFF,
                                                                      value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_OVR_VALUE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_OVR_VALUE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_OVR_VALUE_get", A, 15);
    /* (0x000004e8 bits 8:0) field PHGEN_FT_OVR_VALUE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_FT_OVR_VALUE_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_FT_OVR_VALUE_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_OVR_VALUE_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_FT_OVR_VALUE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_range_PHGEN_FT_OVR_VALUE_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 start_bit,
                                                                     UINT32 stop_bit,
                                                                     UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_OVR_VALUE_set", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_FT_OVR_VALUE_set", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_OVR_VALUE_set", stop_bit, 8 );
    IOLOG( "%s <= A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_FT_OVR_VALUE_set", A, start_bit, stop_bit, value );

    /* don't work hard trying to figure out if this can be changed from a read_modify_write into a pure write */
    if (b_ptr != NULL) {
        l1sys_force_read_modify_write( b_ptr->coalesce_handle);
    }

    /* (0x000004e8 bits 8:0) field PHGEN_FT_OVR_VALUE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1 */
    {
        UINT32 subfield_start_bit;
        UINT32 subfield_stop_bit;
        UINT32 subfield_offset;
        UINT32 subfield_shift;
        UINT32 subfield_num_bits;
        UINT32 subfield_mask;

        if (start_bit > 0) {
            subfield_offset = start_bit - 0;
            subfield_shift = 0;
            subfield_start_bit = start_bit;
        } else {
            subfield_offset = 0;
            subfield_shift = 0 - start_bit;
            subfield_start_bit = 0;
        }
        if (stop_bit < 8) {
            subfield_stop_bit = stop_bit;
        } else {
            subfield_stop_bit = 8;
        }
        subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
        subfield_mask = 0xffffffff >> (32-subfield_num_bits);
        /* (0x000004e8 bits 8:0) field PHGEN_FT_OVR_VALUE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1 */
        s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_field_set( b_ptr,
                                                                          h_ptr,
                                                                          A,
                                                                          subfield_mask << (PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_FT_OVR_VALUE_OFF + subfield_offset),
                                                                          PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_FT_OVR_VALUE_OFF + subfield_offset,
                                                                          value >> subfield_shift);
    }
}

static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_FT_OVR_VALUE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_FT_OVR_VALUE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 start_bit,
                                                                       UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_OVR_VALUE_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_FT_OVR_VALUE_get", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_FT_OVR_VALUE_get", stop_bit, 8 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 8) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 8;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004e8 bits 8:0) field PHGEN_FT_OVR_VALUE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_FT_OVR_VALUE_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_FT_OVR_VALUE_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_FT_OVR_VALUE_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OVR_1_BIT_PHGEN_FT_OVR_VALUE_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_FT_OVR_VALUE_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_VGP_OCC_START_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A,
                                                          UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_VGP_OCC_START_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A,
                                                          UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_VGP_OCC_START_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_VGP_OCC_START_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_VGP_OCC_START_set", A, value );

    /* (0x000004fc bits 15) field VGP_OCC_START of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_VGP_STRT_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_VGP_STRT_CFG_1_field_set( b_ptr,
                                                                         h_ptr,
                                                                         A,
                                                                         PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_VGP_STRT_CFG_1_BIT_VGP_OCC_START_MSK,
                                                                         PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_VGP_STRT_CFG_1_BIT_VGP_OCC_START_OFF,
                                                                         value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_VGP_OCC_START_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_VGP_OCC_START_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_VGP_OCC_START_get", A, 15);
    /* (0x000004fc bits 15) field VGP_OCC_START of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_VGP_STRT_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_VGP_STRT_CFG_1_read( b_ptr,
                                                                                h_ptr,
                                                                                A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_VGP_STRT_CFG_1_BIT_VGP_OCC_START_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_VGP_STRT_CFG_1_BIT_VGP_OCC_START_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_VGP_OCC_START_get", A, value );

    return value;
}

/*
 * ==================================================================================
 * Parameter Access Functions for Paramset config_edge
 * ==================================================================================
 */
static INLINE void s16_mtsb_ctrl_field_CAPTURE_REQ_ALL_STATES_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_CAPTURE_REQ_ALL_STATES_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_CAPTURE_REQ_ALL_STATES_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_CAPTURE_REQ_ALL_STATES_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_CAPTURE_REQ_ALL_STATES_set", A, value );

    /* (0x0000041c bits 8) field CAPTURE_REQ_ALL_STATES of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_field_set( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_CAPTURE_REQ_ALL_STATES_MSK,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_CAPTURE_REQ_ALL_STATES_OFF,
                                                                  value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_CAPTURE_REQ_ALL_STATES_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_CAPTURE_REQ_ALL_STATES_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_CAPTURE_REQ_ALL_STATES_get", A, 15);
    /* (0x0000041c bits 8) field CAPTURE_REQ_ALL_STATES of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_CAPTURE_REQ_ALL_STATES_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_CAPTURE_REQ_ALL_STATES_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_CAPTURE_REQ_ALL_STATES_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PGA_LUT_RD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                       s16_handle_t *h_ptr,
                                                       UINT32 A,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PGA_LUT_RD_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                       s16_handle_t *h_ptr,
                                                       UINT32 A,
                                                       UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PGA_LUT_RD_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PGA_LUT_RD_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PGA_LUT_RD_set", A, value );

    /* (0x000004b8 bits 31) field PGA_LUT_RD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_field_set( b_ptr,
                                                                     h_ptr,
                                                                     A,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_RD_MSK,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_RD_OFF,
                                                                     value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PGA_LUT_RD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PGA_LUT_RD_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PGA_LUT_RD_get", A, 15);
    /* (0x000004b8 bits 31) field PGA_LUT_RD of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_RD_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_RD_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PGA_LUT_RD_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PGA_LUT_WR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                       s16_handle_t *h_ptr,
                                                       UINT32 A,
                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PGA_LUT_WR_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                       s16_handle_t *h_ptr,
                                                       UINT32 A,
                                                       UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PGA_LUT_WR_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PGA_LUT_WR_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PGA_LUT_WR_set", A, value );

    /* (0x000004b8 bits 30) field PGA_LUT_WR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1 */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_field_set( b_ptr,
                                                                     h_ptr,
                                                                     A,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_WR_MSK,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_WR_OFF,
                                                                     value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PGA_LUT_WR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PGA_LUT_WR_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                         s16_handle_t *h_ptr,
                                                         UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PGA_LUT_WR_get", A, 15);
    /* (0x000004b8 bits 30) field PGA_LUT_WR of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_WR_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_CFG_1_BIT_PGA_LUT_WR_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PGA_LUT_WR_get", A, value );

    return value;
}

/*
 * ==================================================================================
 * Parameter Access Functions for Paramset int_active_rising
 * ==================================================================================
 */
static INLINE void s16_mtsb_ctrl_field_ADPT_DONE_I_set_to_clear( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADPT_DONE_I_set_to_clear( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A,
                                                                 UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADPT_DONE_I_set_to_clear", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADPT_DONE_I_set_to_clear", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADPT_DONE_I_set_to_clear", A, value );

    /* (0x0000042c bits 2) field ADPT_DONE_I of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_action_on_write_field_set( b_ptr,
                                                                                         h_ptr,
                                                                                         A,
                                                                                         PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_BIT_ADPT_DONE_I_MSK,
                                                                                         PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_BIT_ADPT_DONE_I_OFF,
                                                                                         value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADPT_DONE_I_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADPT_DONE_I_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADPT_DONE_I_get", A, 15);
    /* (0x0000042c bits 2) field ADPT_DONE_I of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_read( b_ptr,
                                                                                h_ptr,
                                                                                A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_BIT_ADPT_DONE_I_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_BIT_ADPT_DONE_I_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADPT_DONE_I_get", A, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_ADPT_DONE_I_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_ADPT_DONE_I_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  A=%d 0x%08x", "s16_mtsb_ctrl_field_ADPT_DONE_I_poll", A, value );

    /* (0x0000042c bits 2) field ADPT_DONE_I of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT */
    return s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_poll( b_ptr,
                                                                           h_ptr,
                                                                           A,
                                                                           PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_BIT_ADPT_DONE_I_MSK,
                                                                           (value<<PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_BIT_ADPT_DONE_I_OFF),
                                                                           cmp,
                                                                           max_count,
                                                                           num_failed_polls,
                                                                           delay_between_polls_in_microseconds);
}

static INLINE void s16_mtsb_ctrl_field_ALL_CALIB_DONE_I_set_to_clear( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ALL_CALIB_DONE_I_set_to_clear( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ALL_CALIB_DONE_I_set_to_clear", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ALL_CALIB_DONE_I_set_to_clear", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ALL_CALIB_DONE_I_set_to_clear", A, value );

    /* (0x0000042c bits 1) field ALL_CALIB_DONE_I of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_action_on_write_field_set( b_ptr,
                                                                                         h_ptr,
                                                                                         A,
                                                                                         PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_BIT_ALL_CALIB_DONE_I_MSK,
                                                                                         PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_BIT_ALL_CALIB_DONE_I_OFF,
                                                                                         value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ALL_CALIB_DONE_I_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ALL_CALIB_DONE_I_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ALL_CALIB_DONE_I_get", A, 15);
    /* (0x0000042c bits 1) field ALL_CALIB_DONE_I of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_read( b_ptr,
                                                                                h_ptr,
                                                                                A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_BIT_ALL_CALIB_DONE_I_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_BIT_ALL_CALIB_DONE_I_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ALL_CALIB_DONE_I_get", A, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_ALL_CALIB_DONE_I_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_ALL_CALIB_DONE_I_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  A=%d 0x%08x", "s16_mtsb_ctrl_field_ALL_CALIB_DONE_I_poll", A, value );

    /* (0x0000042c bits 1) field ALL_CALIB_DONE_I of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT */
    return s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_poll( b_ptr,
                                                                           h_ptr,
                                                                           A,
                                                                           PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_BIT_ALL_CALIB_DONE_I_MSK,
                                                                           (value<<PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_BIT_ALL_CALIB_DONE_I_OFF),
                                                                           cmp,
                                                                           max_count,
                                                                           num_failed_polls,
                                                                           delay_between_polls_in_microseconds);
}

static INLINE void s16_mtsb_ctrl_field_ADAPT_STATUS_0_I_set_to_clear( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADAPT_STATUS_0_I_set_to_clear( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A,
                                                                      UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_STATUS_0_I_set_to_clear", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADAPT_STATUS_0_I_set_to_clear", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_STATUS_0_I_set_to_clear", A, value );

    /* (0x0000042c bits 0) field ADAPT_STATUS_0_I of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_action_on_write_field_set( b_ptr,
                                                                                         h_ptr,
                                                                                         A,
                                                                                         PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_BIT_ADAPT_STATUS_0_I_MSK,
                                                                                         PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_BIT_ADAPT_STATUS_0_I_OFF,
                                                                                         value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_STATUS_0_I_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_STATUS_0_I_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_STATUS_0_I_get", A, 15);
    /* (0x0000042c bits 0) field ADAPT_STATUS_0_I of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_read( b_ptr,
                                                                                h_ptr,
                                                                                A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_BIT_ADAPT_STATUS_0_I_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_BIT_ADAPT_STATUS_0_I_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_STATUS_0_I_get", A, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_ADAPT_STATUS_0_I_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_ADAPT_STATUS_0_I_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_STATUS_0_I_poll", A, value );

    /* (0x0000042c bits 0) field ADAPT_STATUS_0_I of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT */
    return s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_poll( b_ptr,
                                                                           h_ptr,
                                                                           A,
                                                                           PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_BIT_ADAPT_STATUS_0_I_MSK,
                                                                           (value<<PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EVENT_BIT_ADAPT_STATUS_0_I_OFF),
                                                                           cmp,
                                                                           max_count,
                                                                           num_failed_polls,
                                                                           delay_between_polls_in_microseconds);
}

static INLINE void s16_mtsb_ctrl_field_PHGEN_CT_OVR_LIMIT_INT_I_set_to_clear( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A,
                                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_CT_OVR_LIMIT_INT_I_set_to_clear( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A,
                                                                              UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_CT_OVR_LIMIT_INT_I_set_to_clear", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_OVR_LIMIT_INT_I_set_to_clear", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_OVR_LIMIT_INT_I_set_to_clear", A, value );

    /* (0x000004f4 bits 4) field PHGEN_CT_OVR_LIMIT_INT_I of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_E_action_on_write_field_set( b_ptr,
                                                                                h_ptr,
                                                                                A,
                                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_CT_OVR_LIMIT_INT_I_MSK,
                                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_CT_OVR_LIMIT_INT_I_OFF,
                                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CT_OVR_LIMIT_INT_I_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CT_OVR_LIMIT_INT_I_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_CT_OVR_LIMIT_INT_I_get", A, 15);
    /* (0x000004f4 bits 4) field PHGEN_CT_OVR_LIMIT_INT_I of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_E_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_CT_OVR_LIMIT_INT_I_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_CT_OVR_LIMIT_INT_I_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_OVR_LIMIT_INT_I_get", A, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_PHGEN_CT_OVR_LIMIT_INT_I_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                      s16_handle_t *h_ptr,
                                                                                      UINT32 A,
                                                                                      UINT32 value,
                                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                                      UINT32 max_count,
                                                                                      UINT32 *num_failed_polls,
                                                                                      UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_PHGEN_CT_OVR_LIMIT_INT_I_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                      s16_handle_t *h_ptr,
                                                                                      UINT32 A,
                                                                                      UINT32 value,
                                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                                      UINT32 max_count,
                                                                                      UINT32 *num_failed_polls,
                                                                                      UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_OVR_LIMIT_INT_I_poll", A, value );

    /* (0x000004f4 bits 4) field PHGEN_CT_OVR_LIMIT_INT_I of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E */
    return s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_E_poll( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_CT_OVR_LIMIT_INT_I_MSK,
                                                                  (value<<PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_CT_OVR_LIMIT_INT_I_OFF),
                                                                  cmp,
                                                                  max_count,
                                                                  num_failed_polls,
                                                                  delay_between_polls_in_microseconds);
}

static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_INT_MAX_LIMIT_I_set_to_clear( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                s16_handle_t *h_ptr,
                                                                                UINT32 A,
                                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_INT_MAX_LIMIT_I_set_to_clear( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                s16_handle_t *h_ptr,
                                                                                UINT32 A,
                                                                                UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_INT_MAX_LIMIT_I_set_to_clear", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_INT_MAX_LIMIT_I_set_to_clear", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_INT_MAX_LIMIT_I_set_to_clear", A, value );

    /* (0x000004f4 bits 3) field PHGEN_REGV_INT_MAX_LIMIT_I of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_E_action_on_write_field_set( b_ptr,
                                                                                h_ptr,
                                                                                A,
                                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_REGV_INT_MAX_LIMIT_I_MSK,
                                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_REGV_INT_MAX_LIMIT_I_OFF,
                                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_INT_MAX_LIMIT_I_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_INT_MAX_LIMIT_I_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_INT_MAX_LIMIT_I_get", A, 15);
    /* (0x000004f4 bits 3) field PHGEN_REGV_INT_MAX_LIMIT_I of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_E_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_REGV_INT_MAX_LIMIT_I_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_REGV_INT_MAX_LIMIT_I_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_INT_MAX_LIMIT_I_get", A, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_PHGEN_REGV_INT_MAX_LIMIT_I_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                        s16_handle_t *h_ptr,
                                                                                        UINT32 A,
                                                                                        UINT32 value,
                                                                                        PMC_POLL_COMPARISON_TYPE cmp,
                                                                                        UINT32 max_count,
                                                                                        UINT32 *num_failed_polls,
                                                                                        UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_PHGEN_REGV_INT_MAX_LIMIT_I_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                        s16_handle_t *h_ptr,
                                                                                        UINT32 A,
                                                                                        UINT32 value,
                                                                                        PMC_POLL_COMPARISON_TYPE cmp,
                                                                                        UINT32 max_count,
                                                                                        UINT32 *num_failed_polls,
                                                                                        UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_INT_MAX_LIMIT_I_poll", A, value );

    /* (0x000004f4 bits 3) field PHGEN_REGV_INT_MAX_LIMIT_I of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E */
    return s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_E_poll( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_REGV_INT_MAX_LIMIT_I_MSK,
                                                                  (value<<PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_REGV_INT_MAX_LIMIT_I_OFF),
                                                                  cmp,
                                                                  max_count,
                                                                  num_failed_polls,
                                                                  delay_between_polls_in_microseconds);
}

static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_INT_MIN_LIMIT_I_set_to_clear( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                s16_handle_t *h_ptr,
                                                                                UINT32 A,
                                                                                UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_INT_MIN_LIMIT_I_set_to_clear( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                s16_handle_t *h_ptr,
                                                                                UINT32 A,
                                                                                UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_INT_MIN_LIMIT_I_set_to_clear", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_INT_MIN_LIMIT_I_set_to_clear", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_INT_MIN_LIMIT_I_set_to_clear", A, value );

    /* (0x000004f4 bits 2) field PHGEN_REGV_INT_MIN_LIMIT_I of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_E_action_on_write_field_set( b_ptr,
                                                                                h_ptr,
                                                                                A,
                                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_REGV_INT_MIN_LIMIT_I_MSK,
                                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_REGV_INT_MIN_LIMIT_I_OFF,
                                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_INT_MIN_LIMIT_I_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_INT_MIN_LIMIT_I_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_INT_MIN_LIMIT_I_get", A, 15);
    /* (0x000004f4 bits 2) field PHGEN_REGV_INT_MIN_LIMIT_I of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_E_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_REGV_INT_MIN_LIMIT_I_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_REGV_INT_MIN_LIMIT_I_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_INT_MIN_LIMIT_I_get", A, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_PHGEN_REGV_INT_MIN_LIMIT_I_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                        s16_handle_t *h_ptr,
                                                                                        UINT32 A,
                                                                                        UINT32 value,
                                                                                        PMC_POLL_COMPARISON_TYPE cmp,
                                                                                        UINT32 max_count,
                                                                                        UINT32 *num_failed_polls,
                                                                                        UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_PHGEN_REGV_INT_MIN_LIMIT_I_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                        s16_handle_t *h_ptr,
                                                                                        UINT32 A,
                                                                                        UINT32 value,
                                                                                        PMC_POLL_COMPARISON_TYPE cmp,
                                                                                        UINT32 max_count,
                                                                                        UINT32 *num_failed_polls,
                                                                                        UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_INT_MIN_LIMIT_I_poll", A, value );

    /* (0x000004f4 bits 2) field PHGEN_REGV_INT_MIN_LIMIT_I of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E */
    return s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_E_poll( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_REGV_INT_MIN_LIMIT_I_MSK,
                                                                  (value<<PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_REGV_INT_MIN_LIMIT_I_OFF),
                                                                  cmp,
                                                                  max_count,
                                                                  num_failed_polls,
                                                                  delay_between_polls_in_microseconds);
}

static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_INT_MAX_LIMIT_I_set_to_clear( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A,
                                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_INT_MAX_LIMIT_I_set_to_clear( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A,
                                                                              UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_INT_MAX_LIMIT_I_set_to_clear", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_INT_MAX_LIMIT_I_set_to_clear", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_INT_MAX_LIMIT_I_set_to_clear", A, value );

    /* (0x000004f4 bits 1) field PHGEN_FT_INT_MAX_LIMIT_I of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_E_action_on_write_field_set( b_ptr,
                                                                                h_ptr,
                                                                                A,
                                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_FT_INT_MAX_LIMIT_I_MSK,
                                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_FT_INT_MAX_LIMIT_I_OFF,
                                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_INT_MAX_LIMIT_I_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_INT_MAX_LIMIT_I_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_INT_MAX_LIMIT_I_get", A, 15);
    /* (0x000004f4 bits 1) field PHGEN_FT_INT_MAX_LIMIT_I of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_E_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_FT_INT_MAX_LIMIT_I_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_FT_INT_MAX_LIMIT_I_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_INT_MAX_LIMIT_I_get", A, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_PHGEN_FT_INT_MAX_LIMIT_I_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                      s16_handle_t *h_ptr,
                                                                                      UINT32 A,
                                                                                      UINT32 value,
                                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                                      UINT32 max_count,
                                                                                      UINT32 *num_failed_polls,
                                                                                      UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_PHGEN_FT_INT_MAX_LIMIT_I_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                      s16_handle_t *h_ptr,
                                                                                      UINT32 A,
                                                                                      UINT32 value,
                                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                                      UINT32 max_count,
                                                                                      UINT32 *num_failed_polls,
                                                                                      UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_INT_MAX_LIMIT_I_poll", A, value );

    /* (0x000004f4 bits 1) field PHGEN_FT_INT_MAX_LIMIT_I of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E */
    return s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_E_poll( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_FT_INT_MAX_LIMIT_I_MSK,
                                                                  (value<<PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_FT_INT_MAX_LIMIT_I_OFF),
                                                                  cmp,
                                                                  max_count,
                                                                  num_failed_polls,
                                                                  delay_between_polls_in_microseconds);
}

static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_INT_MIN_LIMIT_I_set_to_clear( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A,
                                                                              UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_INT_MIN_LIMIT_I_set_to_clear( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A,
                                                                              UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_INT_MIN_LIMIT_I_set_to_clear", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_INT_MIN_LIMIT_I_set_to_clear", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_INT_MIN_LIMIT_I_set_to_clear", A, value );

    /* (0x000004f4 bits 0) field PHGEN_FT_INT_MIN_LIMIT_I of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_E_action_on_write_field_set( b_ptr,
                                                                                h_ptr,
                                                                                A,
                                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_FT_INT_MIN_LIMIT_I_MSK,
                                                                                PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_FT_INT_MIN_LIMIT_I_OFF,
                                                                                value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_INT_MIN_LIMIT_I_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_INT_MIN_LIMIT_I_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_INT_MIN_LIMIT_I_get", A, 15);
    /* (0x000004f4 bits 0) field PHGEN_FT_INT_MIN_LIMIT_I of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_E_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_FT_INT_MIN_LIMIT_I_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_FT_INT_MIN_LIMIT_I_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_INT_MIN_LIMIT_I_get", A, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_PHGEN_FT_INT_MIN_LIMIT_I_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                      s16_handle_t *h_ptr,
                                                                                      UINT32 A,
                                                                                      UINT32 value,
                                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                                      UINT32 max_count,
                                                                                      UINT32 *num_failed_polls,
                                                                                      UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_PHGEN_FT_INT_MIN_LIMIT_I_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                      s16_handle_t *h_ptr,
                                                                                      UINT32 A,
                                                                                      UINT32 value,
                                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                                      UINT32 max_count,
                                                                                      UINT32 *num_failed_polls,
                                                                                      UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_INT_MIN_LIMIT_I_poll", A, value );

    /* (0x000004f4 bits 0) field PHGEN_FT_INT_MIN_LIMIT_I of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E */
    return s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_E_poll( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_FT_INT_MIN_LIMIT_I_MSK,
                                                                  (value<<PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_E_BIT_PHGEN_FT_INT_MIN_LIMIT_I_OFF),
                                                                  cmp,
                                                                  max_count,
                                                                  num_failed_polls,
                                                                  delay_between_polls_in_microseconds);
}


/*
 * ==================================================================================
 * Parameter Access Functions for Paramset int_enable
 * ==================================================================================
 */
static INLINE void s16_mtsb_ctrl_field_ADPT_DONE_E_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A,
                                                        UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADPT_DONE_E_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                        s16_handle_t *h_ptr,
                                                        UINT32 A,
                                                        UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADPT_DONE_E_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADPT_DONE_E_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADPT_DONE_E_set", A, value );

    /* (0x00000428 bits 2) field ADPT_DONE_E of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN_BIT_ADPT_DONE_E_MSK,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN_BIT_ADPT_DONE_E_OFF,
                                                                      value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADPT_DONE_E_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADPT_DONE_E_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADPT_DONE_E_get", A, 15);
    /* (0x00000428 bits 2) field ADPT_DONE_E of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN_BIT_ADPT_DONE_E_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN_BIT_ADPT_DONE_E_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADPT_DONE_E_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ALL_CALIB_DONE_E_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ALL_CALIB_DONE_E_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ALL_CALIB_DONE_E_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ALL_CALIB_DONE_E_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ALL_CALIB_DONE_E_set", A, value );

    /* (0x00000428 bits 1) field ALL_CALIB_DONE_E of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN_BIT_ALL_CALIB_DONE_E_MSK,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN_BIT_ALL_CALIB_DONE_E_OFF,
                                                                      value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ALL_CALIB_DONE_E_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ALL_CALIB_DONE_E_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ALL_CALIB_DONE_E_get", A, 15);
    /* (0x00000428 bits 1) field ALL_CALIB_DONE_E of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN_BIT_ALL_CALIB_DONE_E_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN_BIT_ALL_CALIB_DONE_E_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ALL_CALIB_DONE_E_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_ADAPT_STATUS_0_E_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_ADAPT_STATUS_0_E_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A,
                                                             UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_STATUS_0_E_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_ADAPT_STATUS_0_E_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_STATUS_0_E_set", A, value );

    /* (0x00000428 bits 0) field ADAPT_STATUS_0_E of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN_field_set( b_ptr,
                                                                      h_ptr,
                                                                      A,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN_BIT_ADAPT_STATUS_0_E_MSK,
                                                                      PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN_BIT_ADAPT_STATUS_0_E_OFF,
                                                                      value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_STATUS_0_E_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_STATUS_0_E_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_STATUS_0_E_get", A, 15);
    /* (0x00000428 bits 0) field ADAPT_STATUS_0_E of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN_BIT_ADAPT_STATUS_0_E_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_EN_BIT_ADAPT_STATUS_0_E_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_STATUS_0_E_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_CT_OVR_LIMIT_INT_E_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_CT_OVR_LIMIT_INT_E_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_CT_OVR_LIMIT_INT_E_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_OVR_LIMIT_INT_E_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_OVR_LIMIT_INT_E_set", A, value );

    /* (0x000004f0 bits 4) field PHGEN_CT_OVR_LIMIT_INT_E of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_field_set( b_ptr,
                                                              h_ptr,
                                                              A,
                                                              PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_BIT_PHGEN_CT_OVR_LIMIT_INT_E_MSK,
                                                              PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_BIT_PHGEN_CT_OVR_LIMIT_INT_E_OFF,
                                                              value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CT_OVR_LIMIT_INT_E_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CT_OVR_LIMIT_INT_E_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_CT_OVR_LIMIT_INT_E_get", A, 15);
    /* (0x000004f0 bits 4) field PHGEN_CT_OVR_LIMIT_INT_E of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_read( b_ptr,
                                                                     h_ptr,
                                                                     A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_BIT_PHGEN_CT_OVR_LIMIT_INT_E_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_BIT_PHGEN_CT_OVR_LIMIT_INT_E_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_OVR_LIMIT_INT_E_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_INT_MAX_LIMIT_E_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_INT_MAX_LIMIT_E_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_INT_MAX_LIMIT_E_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_INT_MAX_LIMIT_E_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_INT_MAX_LIMIT_E_set", A, value );

    /* (0x000004f0 bits 3) field PHGEN_REGV_INT_MAX_LIMIT_E of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_field_set( b_ptr,
                                                              h_ptr,
                                                              A,
                                                              PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_BIT_PHGEN_REGV_INT_MAX_LIMIT_E_MSK,
                                                              PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_BIT_PHGEN_REGV_INT_MAX_LIMIT_E_OFF,
                                                              value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_INT_MAX_LIMIT_E_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_INT_MAX_LIMIT_E_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_INT_MAX_LIMIT_E_get", A, 15);
    /* (0x000004f0 bits 3) field PHGEN_REGV_INT_MAX_LIMIT_E of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_read( b_ptr,
                                                                     h_ptr,
                                                                     A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_BIT_PHGEN_REGV_INT_MAX_LIMIT_E_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_BIT_PHGEN_REGV_INT_MAX_LIMIT_E_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_INT_MAX_LIMIT_E_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_INT_MIN_LIMIT_E_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_REGV_INT_MIN_LIMIT_E_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A,
                                                                       UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_INT_MIN_LIMIT_E_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_INT_MIN_LIMIT_E_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_INT_MIN_LIMIT_E_set", A, value );

    /* (0x000004f0 bits 2) field PHGEN_REGV_INT_MIN_LIMIT_E of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_field_set( b_ptr,
                                                              h_ptr,
                                                              A,
                                                              PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_BIT_PHGEN_REGV_INT_MIN_LIMIT_E_MSK,
                                                              PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_BIT_PHGEN_REGV_INT_MIN_LIMIT_E_OFF,
                                                              value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_INT_MIN_LIMIT_E_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_INT_MIN_LIMIT_E_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_INT_MIN_LIMIT_E_get", A, 15);
    /* (0x000004f0 bits 2) field PHGEN_REGV_INT_MIN_LIMIT_E of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_read( b_ptr,
                                                                     h_ptr,
                                                                     A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_BIT_PHGEN_REGV_INT_MIN_LIMIT_E_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_BIT_PHGEN_REGV_INT_MIN_LIMIT_E_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_INT_MIN_LIMIT_E_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_INT_MAX_LIMIT_E_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_INT_MAX_LIMIT_E_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_INT_MAX_LIMIT_E_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_INT_MAX_LIMIT_E_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_INT_MAX_LIMIT_E_set", A, value );

    /* (0x000004f0 bits 1) field PHGEN_FT_INT_MAX_LIMIT_E of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_field_set( b_ptr,
                                                              h_ptr,
                                                              A,
                                                              PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_BIT_PHGEN_FT_INT_MAX_LIMIT_E_MSK,
                                                              PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_BIT_PHGEN_FT_INT_MAX_LIMIT_E_OFF,
                                                              value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_INT_MAX_LIMIT_E_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_INT_MAX_LIMIT_E_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_INT_MAX_LIMIT_E_get", A, 15);
    /* (0x000004f0 bits 1) field PHGEN_FT_INT_MAX_LIMIT_E of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_read( b_ptr,
                                                                     h_ptr,
                                                                     A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_BIT_PHGEN_FT_INT_MAX_LIMIT_E_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_BIT_PHGEN_FT_INT_MAX_LIMIT_E_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_INT_MAX_LIMIT_E_get", A, value );

    return value;
}
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_INT_MIN_LIMIT_E_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 value ) ALWAYS_INLINE;
static INLINE void s16_mtsb_ctrl_field_PHGEN_FT_INT_MIN_LIMIT_E_set( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                     s16_handle_t *h_ptr,
                                                                     UINT32 A,
                                                                     UINT32 value )
{
    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_INT_MIN_LIMIT_E_set", A, 15);
    if (value > 1)
        IO_RANGE_CHECK("%s value is 0x%08x but max is 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_INT_MIN_LIMIT_E_set", value, 1);
    IOLOG( "%s <= A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_INT_MIN_LIMIT_E_set", A, value );

    /* (0x000004f0 bits 0) field PHGEN_FT_INT_MIN_LIMIT_E of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT */
    s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_field_set( b_ptr,
                                                              h_ptr,
                                                              A,
                                                              PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_BIT_PHGEN_FT_INT_MIN_LIMIT_E_MSK,
                                                              PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_BIT_PHGEN_FT_INT_MIN_LIMIT_E_OFF,
                                                              value);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_INT_MIN_LIMIT_E_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_INT_MIN_LIMIT_E_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_INT_MIN_LIMIT_E_get", A, 15);
    /* (0x000004f0 bits 0) field PHGEN_FT_INT_MIN_LIMIT_E of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_read( b_ptr,
                                                                     h_ptr,
                                                                     A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_BIT_PHGEN_FT_INT_MIN_LIMIT_E_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_BIT_PHGEN_FT_INT_MIN_LIMIT_E_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_INT_MIN_LIMIT_E_get", A, value );

    return value;
}

/*
 * ==================================================================================
 * Parameter Access Functions for Paramset int_value
 * ==================================================================================
 */
static INLINE UINT32 s16_mtsb_ctrl_field_ADPT_DONE_V_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADPT_DONE_V_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                          s16_handle_t *h_ptr,
                                                          UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADPT_DONE_V_get", A, 15);
    /* (0x00000430 bits 2) field ADPT_DONE_V of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_read( b_ptr,
                                                                          h_ptr,
                                                                          A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_BIT_ADPT_DONE_V_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_BIT_ADPT_DONE_V_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADPT_DONE_V_get", A, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_ADPT_DONE_V_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_ADPT_DONE_V_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A,
                                                                         UINT32 value,
                                                                         PMC_POLL_COMPARISON_TYPE cmp,
                                                                         UINT32 max_count,
                                                                         UINT32 *num_failed_polls,
                                                                         UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  A=%d 0x%08x", "s16_mtsb_ctrl_field_ADPT_DONE_V_poll", A, value );

    /* (0x00000430 bits 2) field ADPT_DONE_V of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT */
    return s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_poll( b_ptr,
                                                                     h_ptr,
                                                                     A,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_BIT_ADPT_DONE_V_MSK,
                                                                     (value<<PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_BIT_ADPT_DONE_V_OFF),
                                                                     cmp,
                                                                     max_count,
                                                                     num_failed_polls,
                                                                     delay_between_polls_in_microseconds);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ALL_CALIB_DONE_V_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ALL_CALIB_DONE_V_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ALL_CALIB_DONE_V_get", A, 15);
    /* (0x00000430 bits 1) field ALL_CALIB_DONE_V of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_read( b_ptr,
                                                                          h_ptr,
                                                                          A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_BIT_ALL_CALIB_DONE_V_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_BIT_ALL_CALIB_DONE_V_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ALL_CALIB_DONE_V_get", A, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_ALL_CALIB_DONE_V_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_ALL_CALIB_DONE_V_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  A=%d 0x%08x", "s16_mtsb_ctrl_field_ALL_CALIB_DONE_V_poll", A, value );

    /* (0x00000430 bits 1) field ALL_CALIB_DONE_V of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT */
    return s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_poll( b_ptr,
                                                                     h_ptr,
                                                                     A,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_BIT_ALL_CALIB_DONE_V_MSK,
                                                                     (value<<PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_BIT_ALL_CALIB_DONE_V_OFF),
                                                                     cmp,
                                                                     max_count,
                                                                     num_failed_polls,
                                                                     delay_between_polls_in_microseconds);
}

static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_STATUS_0_V_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADAPT_STATUS_0_V_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                               s16_handle_t *h_ptr,
                                                               UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADAPT_STATUS_0_V_get", A, 15);
    /* (0x00000430 bits 0) field ADAPT_STATUS_0_V of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_read( b_ptr,
                                                                          h_ptr,
                                                                          A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_BIT_ADAPT_STATUS_0_V_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_BIT_ADAPT_STATUS_0_V_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_STATUS_0_V_get", A, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_ADAPT_STATUS_0_V_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_ADAPT_STATUS_0_V_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A,
                                                                              UINT32 value,
                                                                              PMC_POLL_COMPARISON_TYPE cmp,
                                                                              UINT32 max_count,
                                                                              UINT32 *num_failed_polls,
                                                                              UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  A=%d 0x%08x", "s16_mtsb_ctrl_field_ADAPT_STATUS_0_V_poll", A, value );

    /* (0x00000430 bits 0) field ADAPT_STATUS_0_V of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT */
    return s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_poll( b_ptr,
                                                                     h_ptr,
                                                                     A,
                                                                     PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_BIT_ADAPT_STATUS_0_V_MSK,
                                                                     (value<<PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_STAT_INT_BIT_ADAPT_STATUS_0_V_OFF),
                                                                     cmp,
                                                                     max_count,
                                                                     num_failed_polls,
                                                                     delay_between_polls_in_microseconds);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CT_OVR_LIMIT_INT_V_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CT_OVR_LIMIT_INT_V_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_CT_OVR_LIMIT_INT_V_get", A, 15);
    /* (0x000004f8 bits 4) field PHGEN_CT_OVR_LIMIT_INT_V of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_V_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V_BIT_PHGEN_CT_OVR_LIMIT_INT_V_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V_BIT_PHGEN_CT_OVR_LIMIT_INT_V_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_OVR_LIMIT_INT_V_get", A, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_PHGEN_CT_OVR_LIMIT_INT_V_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                      s16_handle_t *h_ptr,
                                                                                      UINT32 A,
                                                                                      UINT32 value,
                                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                                      UINT32 max_count,
                                                                                      UINT32 *num_failed_polls,
                                                                                      UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_PHGEN_CT_OVR_LIMIT_INT_V_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                      s16_handle_t *h_ptr,
                                                                                      UINT32 A,
                                                                                      UINT32 value,
                                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                                      UINT32 max_count,
                                                                                      UINT32 *num_failed_polls,
                                                                                      UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_OVR_LIMIT_INT_V_poll", A, value );

    /* (0x000004f8 bits 4) field PHGEN_CT_OVR_LIMIT_INT_V of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V */
    return s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_V_poll( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V_BIT_PHGEN_CT_OVR_LIMIT_INT_V_MSK,
                                                                  (value<<PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V_BIT_PHGEN_CT_OVR_LIMIT_INT_V_OFF),
                                                                  cmp,
                                                                  max_count,
                                                                  num_failed_polls,
                                                                  delay_between_polls_in_microseconds);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_INT_MAX_LIMIT_V_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_INT_MAX_LIMIT_V_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_INT_MAX_LIMIT_V_get", A, 15);
    /* (0x000004f8 bits 3) field PHGEN_REGV_INT_MAX_LIMIT_V of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_V_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V_BIT_PHGEN_REGV_INT_MAX_LIMIT_V_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V_BIT_PHGEN_REGV_INT_MAX_LIMIT_V_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_INT_MAX_LIMIT_V_get", A, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_PHGEN_REGV_INT_MAX_LIMIT_V_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                        s16_handle_t *h_ptr,
                                                                                        UINT32 A,
                                                                                        UINT32 value,
                                                                                        PMC_POLL_COMPARISON_TYPE cmp,
                                                                                        UINT32 max_count,
                                                                                        UINT32 *num_failed_polls,
                                                                                        UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_PHGEN_REGV_INT_MAX_LIMIT_V_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                        s16_handle_t *h_ptr,
                                                                                        UINT32 A,
                                                                                        UINT32 value,
                                                                                        PMC_POLL_COMPARISON_TYPE cmp,
                                                                                        UINT32 max_count,
                                                                                        UINT32 *num_failed_polls,
                                                                                        UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_INT_MAX_LIMIT_V_poll", A, value );

    /* (0x000004f8 bits 3) field PHGEN_REGV_INT_MAX_LIMIT_V of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V */
    return s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_V_poll( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V_BIT_PHGEN_REGV_INT_MAX_LIMIT_V_MSK,
                                                                  (value<<PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V_BIT_PHGEN_REGV_INT_MAX_LIMIT_V_OFF),
                                                                  cmp,
                                                                  max_count,
                                                                  num_failed_polls,
                                                                  delay_between_polls_in_microseconds);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_INT_MIN_LIMIT_V_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_INT_MIN_LIMIT_V_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_INT_MIN_LIMIT_V_get", A, 15);
    /* (0x000004f8 bits 2) field PHGEN_REGV_INT_MIN_LIMIT_V of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_V_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V_BIT_PHGEN_REGV_INT_MIN_LIMIT_V_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V_BIT_PHGEN_REGV_INT_MIN_LIMIT_V_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_INT_MIN_LIMIT_V_get", A, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_PHGEN_REGV_INT_MIN_LIMIT_V_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                        s16_handle_t *h_ptr,
                                                                                        UINT32 A,
                                                                                        UINT32 value,
                                                                                        PMC_POLL_COMPARISON_TYPE cmp,
                                                                                        UINT32 max_count,
                                                                                        UINT32 *num_failed_polls,
                                                                                        UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_PHGEN_REGV_INT_MIN_LIMIT_V_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                        s16_handle_t *h_ptr,
                                                                                        UINT32 A,
                                                                                        UINT32 value,
                                                                                        PMC_POLL_COMPARISON_TYPE cmp,
                                                                                        UINT32 max_count,
                                                                                        UINT32 *num_failed_polls,
                                                                                        UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_INT_MIN_LIMIT_V_poll", A, value );

    /* (0x000004f8 bits 2) field PHGEN_REGV_INT_MIN_LIMIT_V of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V */
    return s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_V_poll( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V_BIT_PHGEN_REGV_INT_MIN_LIMIT_V_MSK,
                                                                  (value<<PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V_BIT_PHGEN_REGV_INT_MIN_LIMIT_V_OFF),
                                                                  cmp,
                                                                  max_count,
                                                                  num_failed_polls,
                                                                  delay_between_polls_in_microseconds);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_INT_MAX_LIMIT_V_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_INT_MAX_LIMIT_V_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_INT_MAX_LIMIT_V_get", A, 15);
    /* (0x000004f8 bits 1) field PHGEN_FT_INT_MAX_LIMIT_V of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_V_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V_BIT_PHGEN_FT_INT_MAX_LIMIT_V_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V_BIT_PHGEN_FT_INT_MAX_LIMIT_V_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_INT_MAX_LIMIT_V_get", A, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_PHGEN_FT_INT_MAX_LIMIT_V_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                      s16_handle_t *h_ptr,
                                                                                      UINT32 A,
                                                                                      UINT32 value,
                                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                                      UINT32 max_count,
                                                                                      UINT32 *num_failed_polls,
                                                                                      UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_PHGEN_FT_INT_MAX_LIMIT_V_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                      s16_handle_t *h_ptr,
                                                                                      UINT32 A,
                                                                                      UINT32 value,
                                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                                      UINT32 max_count,
                                                                                      UINT32 *num_failed_polls,
                                                                                      UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_INT_MAX_LIMIT_V_poll", A, value );

    /* (0x000004f8 bits 1) field PHGEN_FT_INT_MAX_LIMIT_V of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V */
    return s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_V_poll( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V_BIT_PHGEN_FT_INT_MAX_LIMIT_V_MSK,
                                                                  (value<<PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V_BIT_PHGEN_FT_INT_MAX_LIMIT_V_OFF),
                                                                  cmp,
                                                                  max_count,
                                                                  num_failed_polls,
                                                                  delay_between_polls_in_microseconds);
}

static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_INT_MIN_LIMIT_V_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_INT_MIN_LIMIT_V_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_INT_MIN_LIMIT_V_get", A, 15);
    /* (0x000004f8 bits 0) field PHGEN_FT_INT_MIN_LIMIT_V of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_V_read( b_ptr,
                                                                       h_ptr,
                                                                       A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V_BIT_PHGEN_FT_INT_MIN_LIMIT_V_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V_BIT_PHGEN_FT_INT_MIN_LIMIT_V_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_INT_MIN_LIMIT_V_get", A, value );

    return value;
}
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_PHGEN_FT_INT_MIN_LIMIT_V_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                      s16_handle_t *h_ptr,
                                                                                      UINT32 A,
                                                                                      UINT32 value,
                                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                                      UINT32 max_count,
                                                                                      UINT32 *num_failed_polls,
                                                                                      UINT32 delay_between_polls_in_microseconds ) ALWAYS_INLINE;
static INLINE PMC_POLL_RETURN_TYPE s16_mtsb_ctrl_field_PHGEN_FT_INT_MIN_LIMIT_V_poll( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                      s16_handle_t *h_ptr,
                                                                                      UINT32 A,
                                                                                      UINT32 value,
                                                                                      PMC_POLL_COMPARISON_TYPE cmp,
                                                                                      UINT32 max_count,
                                                                                      UINT32 *num_failed_polls,
                                                                                      UINT32 delay_between_polls_in_microseconds )
{
    IOLOG( "%s wait until value =  A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_INT_MIN_LIMIT_V_poll", A, value );

    /* (0x000004f8 bits 0) field PHGEN_FT_INT_MIN_LIMIT_V of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V */
    return s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_INT_V_poll( b_ptr,
                                                                  h_ptr,
                                                                  A,
                                                                  PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V_BIT_PHGEN_FT_INT_MIN_LIMIT_V_MSK,
                                                                  (value<<PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_INT_V_BIT_PHGEN_FT_INT_MIN_LIMIT_V_OFF),
                                                                  cmp,
                                                                  max_count,
                                                                  num_failed_polls,
                                                                  delay_between_polls_in_microseconds);
}


/*
 * ==================================================================================
 * Parameter Access Functions for Paramset status
 * ==================================================================================
 */
static INLINE UINT32 s16_mtsb_ctrl_field_ADC_CALIB_PASS_TIMING_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADC_CALIB_PASS_TIMING_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADC_CALIB_PASS_TIMING_OBS_get", A, 15);
    /* (0x0000041c bits 30) field ADC_CALIB_PASS_TIMING_OBS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADC_CALIB_PASS_TIMING_OBS_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADC_CALIB_PASS_TIMING_OBS_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADC_CALIB_PASS_TIMING_OBS_get", A, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_ADC_CALIB_PASS_DATA_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADC_CALIB_PASS_DATA_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                      s16_handle_t *h_ptr,
                                                                      UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADC_CALIB_PASS_DATA_OBS_get", A, 15);
    /* (0x0000041c bits 29) field ADC_CALIB_PASS_DATA_OBS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADC_CALIB_PASS_DATA_OBS_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADC_CALIB_PASS_DATA_OBS_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADC_CALIB_PASS_DATA_OBS_get", A, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_TX_DCD_CALIB_REQUEST_FSM_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_TX_DCD_CALIB_REQUEST_FSM_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                           s16_handle_t *h_ptr,
                                                                           UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_TX_DCD_CALIB_REQUEST_FSM_OBS_get", A, 15);
    /* (0x0000041c bits 24) field TX_DCD_CALIB_REQUEST_FSM_OBS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_TX_DCD_CALIB_REQUEST_FSM_OBS_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_TX_DCD_CALIB_REQUEST_FSM_OBS_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_TX_DCD_CALIB_REQUEST_FSM_OBS_get", A, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_ADC_CALIB_REQUEST_FSM_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADC_CALIB_REQUEST_FSM_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                        s16_handle_t *h_ptr,
                                                                        UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADC_CALIB_REQUEST_FSM_OBS_get", A, 15);
    /* (0x0000041c bits 23) field ADC_CALIB_REQUEST_FSM_OBS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADC_CALIB_REQUEST_FSM_OBS_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADC_CALIB_REQUEST_FSM_OBS_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADC_CALIB_REQUEST_FSM_OBS_get", A, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_TX_DCD_CALIB_DONE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_TX_DCD_CALIB_DONE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_TX_DCD_CALIB_DONE_OBS_get", A, 15);
    /* (0x0000041c bits 22) field TX_DCD_CALIB_DONE_OBS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_TX_DCD_CALIB_DONE_OBS_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_TX_DCD_CALIB_DONE_OBS_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_TX_DCD_CALIB_DONE_OBS_get", A, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_TX_DCD_CALIB_DONE_DIV3_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_TX_DCD_CALIB_DONE_DIV3_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                         s16_handle_t *h_ptr,
                                                                         UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_TX_DCD_CALIB_DONE_DIV3_OBS_get", A, 15);
    /* (0x0000041c bits 21) field TX_DCD_CALIB_DONE_DIV3_OBS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_TX_DCD_CALIB_DONE_DIV3_OBS_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_TX_DCD_CALIB_DONE_DIV3_OBS_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_TX_DCD_CALIB_DONE_DIV3_OBS_get", A, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_ADC_CALIB_DONE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADC_CALIB_DONE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADC_CALIB_DONE_OBS_get", A, 15);
    /* (0x0000041c bits 20) field ADC_CALIB_DONE_OBS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADC_CALIB_DONE_OBS_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_ADC_CALIB_DONE_OBS_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADC_CALIB_DONE_OBS_get", A, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_OCC_STATE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_OCC_STATE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_OCC_STATE_OBS_get", A, 15);
    /* (0x0000041c bits 14:13) field OCC_STATE_OBS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_OCC_STATE_OBS_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_OCC_STATE_OBS_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_OCC_STATE_OBS_get", A, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_range_OCC_STATE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_OCC_STATE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                  s16_handle_t *h_ptr,
                                                                  UINT32 A,
                                                                  UINT32 start_bit,
                                                                  UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_OCC_STATE_OBS_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_OCC_STATE_OBS_get", stop_bit, start_bit );
    if (stop_bit > 1) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_OCC_STATE_OBS_get", stop_bit, 1 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 1) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 1;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000041c bits 14:13) field OCC_STATE_OBS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_OCC_STATE_OBS_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_OCC_STATE_OBS_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_OCC_STATE_OBS_MSK, PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_OCC_STATE_OBS_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_OCC_STATE_OBS_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_CLBRT_STATE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_CLBRT_STATE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_CLBRT_STATE_OBS_get", A, 15);
    /* (0x0000041c bits 12:9) field CLBRT_STATE_OBS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_CLBRT_STATE_OBS_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_CLBRT_STATE_OBS_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_CLBRT_STATE_OBS_get", A, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_range_CLBRT_STATE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_CLBRT_STATE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_CLBRT_STATE_OBS_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_CLBRT_STATE_OBS_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_CLBRT_STATE_OBS_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x0000041c bits 12:9) field CLBRT_STATE_OBS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_read( b_ptr,
                                                                         h_ptr,
                                                                         A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_CLBRT_STATE_OBS_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_CLBRT_STATE_OBS_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_CLBRT_STATE_OBS_MSK, PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_CFG_REG_BIT_CLBRT_STATE_OBS_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_CLBRT_STATE_OBS_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_RTUNE_CAL_DONE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_RTUNE_CAL_DONE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_RTUNE_CAL_DONE_OBS_get", A, 15);
    /* (0x00000424 bits 11) field PHGEN_RTUNE_CAL_DONE_OBS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_BIT_PHGEN_RTUNE_CAL_DONE_OBS_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_BIT_PHGEN_RTUNE_CAL_DONE_OBS_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_RTUNE_CAL_DONE_OBS_get", A, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CTUNE_CAL_DONE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CTUNE_CAL_DONE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_CTUNE_CAL_DONE_OBS_get", A, 15);
    /* (0x00000424 bits 10) field PHGEN_CTUNE_CAL_DONE_OBS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_BIT_PHGEN_CTUNE_CAL_DONE_OBS_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_BIT_PHGEN_CTUNE_CAL_DONE_OBS_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CTUNE_CAL_DONE_OBS_get", A, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FTUNE_CAL_DONE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FTUNE_CAL_DONE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                       s16_handle_t *h_ptr,
                                                                       UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FTUNE_CAL_DONE_OBS_get", A, 15);
    /* (0x00000424 bits 9) field PHGEN_FTUNE_CAL_DONE_OBS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_BIT_PHGEN_FTUNE_CAL_DONE_OBS_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_BIT_PHGEN_FTUNE_CAL_DONE_OBS_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FTUNE_CAL_DONE_OBS_get", A, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_TX_EMI_ROP_RON_CAL_REQUEST_FSM_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_TX_EMI_ROP_RON_CAL_REQUEST_FSM_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                                 s16_handle_t *h_ptr,
                                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_TX_EMI_ROP_RON_CAL_REQUEST_FSM_OBS_get", A, 15);
    /* (0x00000424 bits 8) field TX_EMI_ROP_RON_CAL_REQUEST_FSM_OBS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_BIT_TX_EMI_ROP_RON_CAL_REQUEST_FSM_OBS_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_BIT_TX_EMI_ROP_RON_CAL_REQUEST_FSM_OBS_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_TX_EMI_ROP_RON_CAL_REQUEST_FSM_OBS_get", A, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_RTUNE_CAL_REQUEST_FSM_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_RTUNE_CAL_REQUEST_FSM_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_RTUNE_CAL_REQUEST_FSM_OBS_get", A, 15);
    /* (0x00000424 bits 7) field PHGEN_RTUNE_CAL_REQUEST_FSM_OBS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_BIT_PHGEN_RTUNE_CAL_REQUEST_FSM_OBS_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_BIT_PHGEN_RTUNE_CAL_REQUEST_FSM_OBS_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_RTUNE_CAL_REQUEST_FSM_OBS_get", A, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CTUNE_CAL_REQUEST_FSM_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CTUNE_CAL_REQUEST_FSM_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_CTUNE_CAL_REQUEST_FSM_OBS_get", A, 15);
    /* (0x00000424 bits 6) field PHGEN_CTUNE_CAL_REQUEST_FSM_OBS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_BIT_PHGEN_CTUNE_CAL_REQUEST_FSM_OBS_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_BIT_PHGEN_CTUNE_CAL_REQUEST_FSM_OBS_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CTUNE_CAL_REQUEST_FSM_OBS_get", A, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FTUNE_CAL_REQUEST_FSM_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FTUNE_CAL_REQUEST_FSM_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                              s16_handle_t *h_ptr,
                                                                              UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FTUNE_CAL_REQUEST_FSM_OBS_get", A, 15);
    /* (0x00000424 bits 5) field PHGEN_FTUNE_CAL_REQUEST_FSM_OBS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_BIT_PHGEN_FTUNE_CAL_REQUEST_FSM_OBS_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_BIT_PHGEN_FTUNE_CAL_REQUEST_FSM_OBS_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FTUNE_CAL_REQUEST_FSM_OBS_get", A, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_TX_EMI_ROP_RON_CAL_DONE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_TX_EMI_ROP_RON_CAL_DONE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                          s16_handle_t *h_ptr,
                                                                          UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_TX_EMI_ROP_RON_CAL_DONE_OBS_get", A, 15);
    /* (0x00000424 bits 1) field TX_EMI_ROP_RON_CAL_DONE_OBS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_BIT_TX_EMI_ROP_RON_CAL_DONE_OBS_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_BIT_TX_EMI_ROP_RON_CAL_DONE_OBS_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_TX_EMI_ROP_RON_CAL_DONE_OBS_get", A, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_HOLD_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_HOLD_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_HOLD_OBS_get", A, 15);
    /* (0x00000424 bits 0) field PHGEN_HOLD_OBS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_BIT_PHGEN_HOLD_OBS_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_LANE_N_OBS_2_REG_BIT_PHGEN_HOLD_OBS_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_HOLD_OBS_get", A, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_ADPT_STATE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_ADPT_STATE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                             s16_handle_t *h_ptr,
                                                             UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_ADPT_STATE_OBS_get", A, 15);
    /* (0x00000454 bits 24:21) field ADPT_STATE_OBS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_STS_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_STS_1_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_STS_1_BIT_ADPT_STATE_OBS_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_STS_1_BIT_ADPT_STATE_OBS_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_ADPT_STATE_OBS_get", A, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_range_ADPT_STATE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_ADPT_STATE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A,
                                                                   UINT32 start_bit,
                                                                   UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_ADPT_STATE_OBS_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_ADPT_STATE_OBS_get", stop_bit, start_bit );
    if (stop_bit > 3) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_ADPT_STATE_OBS_get", stop_bit, 3 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 3) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 3;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x00000454 bits 24:21) field ADPT_STATE_OBS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_STS_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_TCB_STS_1_read( b_ptr,
                                                                           h_ptr,
                                                                           A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_STS_1_BIT_ADPT_STATE_OBS_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_STS_1_BIT_ADPT_STATE_OBS_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_STS_1_BIT_ADPT_STATE_OBS_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_TCB_STS_1_BIT_ADPT_STATE_OBS_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_ADPT_STATE_OBS_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_PGA_LUT_RD_DATA_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PGA_LUT_RD_DATA_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PGA_LUT_RD_DATA_get", A, 15);
    /* (0x000004bc bits 20:0) field PGA_LUT_RD_DATA of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_STS_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_PGA_LUT_TBL_STS_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_STS_1_BIT_PGA_LUT_RD_DATA_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_STS_1_BIT_PGA_LUT_RD_DATA_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PGA_LUT_RD_DATA_get", A, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_range_PGA_LUT_RD_DATA_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PGA_LUT_RD_DATA_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PGA_LUT_RD_DATA_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PGA_LUT_RD_DATA_get", stop_bit, start_bit );
    if (stop_bit > 20) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PGA_LUT_RD_DATA_get", stop_bit, 20 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 20) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 20;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004bc bits 20:0) field PGA_LUT_RD_DATA of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_STS_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_PGA_LUT_TBL_STS_1_read( b_ptr,
                                                                            h_ptr,
                                                                            A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_STS_1_BIT_PGA_LUT_RD_DATA_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_STS_1_BIT_PGA_LUT_RD_DATA_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_STS_1_BIT_PGA_LUT_RD_DATA_MSK, PCBI_REG_DIGI120_MTSB_CTRL_PGA_LUT_TBL_STS_1_BIT_PGA_LUT_RD_DATA_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PGA_LUT_RD_DATA_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CTUNE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CTUNE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_CTUNE_OBS_get", A, 15);
    /* (0x000004ec bits 18:13) field PHGEN_CTUNE_OBS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_BIT_PHGEN_CTUNE_OBS_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_BIT_PHGEN_CTUNE_OBS_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CTUNE_OBS_get", A, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_CTUNE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_CTUNE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_CTUNE_OBS_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_CTUNE_OBS_get", stop_bit, start_bit );
    if (stop_bit > 5) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_CTUNE_OBS_get", stop_bit, 5 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 5) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 5;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004ec bits 18:13) field PHGEN_CTUNE_OBS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_BIT_PHGEN_CTUNE_OBS_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_BIT_PHGEN_CTUNE_OBS_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_BIT_PHGEN_CTUNE_OBS_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_BIT_PHGEN_CTUNE_OBS_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_CTUNE_OBS_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FTUNE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FTUNE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                              s16_handle_t *h_ptr,
                                                              UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FTUNE_OBS_get", A, 15);
    /* (0x000004ec bits 12:4) field PHGEN_FTUNE_OBS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_BIT_PHGEN_FTUNE_OBS_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_BIT_PHGEN_FTUNE_OBS_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FTUNE_OBS_get", A, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_FTUNE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_range_PHGEN_FTUNE_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A,
                                                                    UINT32 start_bit,
                                                                    UINT32 stop_bit )
{
    UINT32 value = 0;
    UINT32 field_value;
    UINT32 reg_value;
    UINT32 subfield_start_bit;
    UINT32 subfield_stop_bit;
    UINT32 subfield_offset;
    UINT32 subfield_shift;
    UINT32 subfield_num_bits;
    UINT32 subfield_mask;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_range_PHGEN_FTUNE_OBS_get", A, 15);
    if (start_bit > stop_bit) IO_RANGE_CHECK("%s error: stop_bit:%d > start_bit:%d", "s16_mtsb_ctrl_field_range_PHGEN_FTUNE_OBS_get", stop_bit, start_bit );
    if (stop_bit > 8) IO_RANGE_CHECK("%s error: stop_bit:%d > %d", "s16_mtsb_ctrl_field_range_PHGEN_FTUNE_OBS_get", stop_bit, 8 );
    if (start_bit > 0) {
        subfield_offset = start_bit - 0;
        subfield_shift = 0;
        subfield_start_bit = start_bit;
    } else {
        subfield_offset = 0;
        subfield_shift = 0 - start_bit;
        subfield_start_bit = 0;
    }
    if (stop_bit < 8) {
        subfield_stop_bit = stop_bit;
    } else {
        subfield_stop_bit = 8;
    }
    subfield_num_bits = subfield_stop_bit - subfield_start_bit + 1;
    subfield_mask = 0xffffffff >> (32-subfield_num_bits);
    /* (0x000004ec bits 12:4) field PHGEN_FTUNE_OBS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    field_value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_BIT_PHGEN_FTUNE_OBS_MSK)
                  >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_BIT_PHGEN_FTUNE_OBS_OFF;
    IOLOG(  "field_value = (%08x & 0x%x) >> %d; // (%08x)", reg_value, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_BIT_PHGEN_FTUNE_OBS_MSK, PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_BIT_PHGEN_FTUNE_OBS_OFF, field_value );
    value |= ((field_value >> subfield_offset) & subfield_mask) << subfield_shift;
    IOLOG(  "value |= ((%08x >> %d) & 0x%x << %d); // (%08x)", field_value, subfield_offset, subfield_mask, subfield_shift, ((field_value >> subfield_offset) & subfield_mask) << subfield_shift );
    IOLOG( "%s -> A=%d start_bit=%d stop_bit=%d 0x%08x", "s16_mtsb_ctrl_field_range_PHGEN_FTUNE_OBS_get", A, start_bit, stop_bit, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_DLYCOR_DATA_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_DLYCOR_DATA_OBS_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                    s16_handle_t *h_ptr,
                                                                    UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_DLYCOR_DATA_OBS_get", A, 15);
    /* (0x000004ec bits 3) field PHGEN_DLYCOR_DATA_OBS of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_BIT_PHGEN_DLYCOR_DATA_OBS_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_BIT_PHGEN_DLYCOR_DATA_OBS_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_DLYCOR_DATA_OBS_get", A, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_TIMER_OUT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_REGV_TIMER_OUT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                   s16_handle_t *h_ptr,
                                                                   UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_REGV_TIMER_OUT_get", A, 15);
    /* (0x000004ec bits 2) field PHGEN_REGV_TIMER_OUT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_BIT_PHGEN_REGV_TIMER_OUT_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_BIT_PHGEN_REGV_TIMER_OUT_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_REGV_TIMER_OUT_get", A, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_TIMER_OUT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_FT_TIMER_OUT_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                                 s16_handle_t *h_ptr,
                                                                 UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_FT_TIMER_OUT_get", A, 15);
    /* (0x000004ec bits 1) field PHGEN_FT_TIMER_OUT of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_BIT_PHGEN_FT_TIMER_OUT_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_BIT_PHGEN_FT_TIMER_OUT_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_FT_TIMER_OUT_get", A, value );

    return value;
}
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CT_DONE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A ) ATTRIBUTE_WARN_UNUSED_RESULT ALWAYS_INLINE;
static INLINE UINT32 s16_mtsb_ctrl_field_PHGEN_CT_DONE_get( s16_mtsb_ctrl_buffer_t *b_ptr,
                                                            s16_handle_t *h_ptr,
                                                            UINT32 A )
{
    UINT32 value = 0;
    UINT32 reg_value;

    if (A > 15)
        IO_RANGE_CHECK("%s A is %d but max is %d", "s16_mtsb_ctrl_field_PHGEN_CT_DONE_get", A, 15);
    /* (0x000004ec bits 0) field PHGEN_CT_DONE of register PMC_PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1 */
    reg_value = s16_mtsb_ctrl_reg_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_read( b_ptr,
                                                                             h_ptr,
                                                                             A);
    value = (reg_value & PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_BIT_PHGEN_CT_DONE_MSK) >> PCBI_REG_DIGI120_MTSB_CTRL_GLOBAL_PHGEN_OBS_1_BIT_PHGEN_CT_DONE_OFF;
    IOLOG( "%s -> A=%d 0x%08x", "s16_mtsb_ctrl_field_PHGEN_CT_DONE_get", A, value );

    return value;
}

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* _S16_MTSB_CTRL_IO_INLINE_H */
